{"query_id": "10016.sql", "original_sql": "\nSELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    c.kind AS cast_type,\n    STRING_AGG(DISTINCT k.keyword, ', ') AS movie_keywords\nFROM \n    aka_name AS a\nJOIN \n    cast_info AS ci ON a.person_id = ci.person_id\nJOIN \n    aka_title AS t ON ci.movie_id = t.movie_id\nJOIN \n    comp_cast_type AS c ON ci.person_role_id = c.id\nLEFT JOIN \n    movie_keyword AS mk ON t.id = mk.movie_id\nLEFT JOIN \n    keyword AS k ON mk.keyword_id = k.id\nGROUP BY \n    a.name, t.title, t.production_year, c.kind\nORDER BY \n    t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT DISTINCT a.name AS actor_name,\n                t.title AS movie_title,\n                t.production_year,\n                c.kind AS cast_type,\n                t.id AS movie_id\nFROM aka_name AS a\nJOIN cast_info AS ci ON a.person_id = ci.person_id\nJOIN aka_title AS t ON ci.movie_id = t.movie_id\nJOIN comp_cast_type AS c ON ci.person_role_id = c.id;", "sql2": "SELECT s1.actor_name,\n       s1.movie_title,\n       s1.production_year,\n       s1.cast_type,\n       STRING_AGG(DISTINCT k.keyword, ', ') AS movie_keywords\nFROM s1\nLEFT JOIN movie_keyword AS mk ON s1.movie_id = mk.movie_id\nLEFT JOIN keyword AS k ON mk.keyword_id = k.id\nGROUP BY s1.actor_name, s1.movie_title, s1.production_year, s1.cast_type\nORDER BY s1.production_year DESC, s1.actor_name;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "10159.sql", "original_sql": "SELECT \n    a.name AS aka_name, \n    t.title AS movie_title, \n    c.note AS cast_note, \n    cn.name AS company_name, \n    kv.keyword AS keyword_used\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    aka_title t ON c.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword kv ON mk.keyword_id = kv.id\nWHERE \n    t.production_year > 2000\nORDER BY \n    t.production_year DESC, \n    a.name;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 115, in _run_on_datafusion\n    return df.to_arrow_table()\n           ^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/dataframe.py\", line 1164, in to_arrow_table\n    return self.df.to_arrow_table()\n           ^^^^^^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: ResourcesExhausted(\"Additional allocation failed with top memory consumers (across reservations) as:\\n  ExternalSorter[33]#2662(can spill: true) consumed 1747.1 MB, peak 1747.1 MB,\\n  ExternalSorter[34]#2665(can spill: true) consumed 1555.8 MB, peak 1555.8 MB,\\n  ExternalSorter[58]#2737(can spill: true) consumed 1531.1 MB, peak 1531.1 MB,\\n  ExternalSorter[118]#2917(can spill: true) consumed 1510.4 MB, peak 1510.4 MB,\\n  ExternalSorter[173]#3082(can spill: true) consumed 1476.9 MB, peak 1476.9 MB.\\nError: Failed to allocate additional 1259.7 KB for ExternalSorterMerge[112] with 0.0 B already allocated for this reservation - 527.5 KB remain available for the total pool\")\n", "engine_mem_mb": 500000}
{"query_id": "10175.sql", "original_sql": "SELECT \n    t.title AS movie_title,\n    p.info AS person_info,\n    a.name AS actor_name,\n    ka.keyword AS movie_keyword,\n    co.name AS company_name,\n    ct.kind AS company_type\nFROM \n    title t\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    aka_name a ON cc.subject_id = a.person_id\nJOIN \n    person_info p ON a.person_id = p.person_id\nLEFT JOIN \n    movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN \n    keyword ka ON mk.keyword_id = ka.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name co ON mc.company_id = co.id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.production_year DESC, \n    t.title;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS movie_id,\n       t.title AS movie_title,\n       t.production_year AS prod_year,\n       co.name AS company_name,\n       ct.kind AS company_type\nFROM title t\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_name co ON mc.company_id = co.id\nJOIN company_type ct ON mc.company_type_id = ct.id\nWHERE t.production_year >= 2000", "sql2": "SELECT s1.movie_title,\n       p.info AS person_info,\n       a.name AS actor_name,\n       ka.keyword AS movie_keyword,\n       s1.company_name,\n       s1.company_type\nFROM s1\nJOIN complete_cast cc ON s1.movie_id = cc.movie_id\nJOIN aka_name a ON cc.subject_id = a.person_id\nJOIN person_info p ON a.person_id = p.person_id\nLEFT JOIN movie_keyword mk ON s1.movie_id = mk.movie_id\nLEFT JOIN keyword ka ON mk.keyword_id = ka.id\nORDER BY s1.prod_year DESC, s1.movie_title", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "10215.sql", "original_sql": "SELECT \n    a.name AS alias_name,\n    t.title AS movie_title,\n    p.name AS actor_name,\n    c.role_id AS role_id,\n    m.info AS movie_info\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    title t ON c.movie_id = t.id\nJOIN \n    name p ON c.person_id = p.imdb_id\nJOIN \n    movie_info m ON t.id = m.movie_id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT a.person_id,\n       a.name AS alias_name,\n       c.movie_id,\n       c.role_id,\n       t.title AS movie_title,\n       t.production_year\nFROM   aka_name a\nJOIN   cast_info c ON a.person_id = c.person_id\nJOIN   title t ON c.movie_id = t.id\nWHERE  t.production_year >= 2000;", "sql2": "SELECT s1.alias_name,\n       s1.movie_title,\n       p.name AS actor_name,\n       s1.role_id,\n       m.info AS movie_info\nFROM   s1\nJOIN   name p ON s1.person_id = p.imdb_id\nJOIN   movie_info m ON s1.movie_id = m.movie_id\nORDER BY s1.production_year DESC, s1.alias_name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "10228.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    m.title AS movie_title,\n    m.production_year,\n    c.kind AS cast_type,\n    k.keyword AS movie_keyword\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    aka_title m ON ci.movie_id = m.id\nJOIN \n    comp_cast_type c ON ci.person_role_id = c.id\nJOIN \n    movie_keyword mk ON m.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    m.production_year > 2000\nORDER BY \n    m.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT a.person_id AS person_id,\n       a.name AS actor_name,\n       ci.movie_id,\n       m.title AS movie_title,\n       m.production_year,\n       c.kind AS cast_type\nFROM   aka_name a\nJOIN   cast_info ci ON a.person_id = ci.person_id\nJOIN   aka_title m ON ci.movie_id = m.id\nJOIN   comp_cast_type c ON ci.person_role_id = c.id\nWHERE  m.production_year > 2000;", "sql2": "SELECT s1.actor_name,\n       s1.movie_title,\n       s1.production_year,\n       s1.cast_type,\n       k.keyword AS movie_keyword\nFROM   s1\nJOIN   movie_keyword mk ON s1.movie_id = mk.movie_id\nJOIN   keyword k ON mk.keyword_id = k.id\nORDER BY s1.production_year DESC, s1.actor_name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "10239.sql", "original_sql": "SELECT \n    t.title,\n    a.name AS actor_name,\n    k.keyword AS movie_keyword,\n    c.name AS company_name,\n    ty.kind AS company_type,\n    p.info AS person_info\nFROM \n    aka_title AS t\nJOIN \n    cast_info AS ci ON t.id = ci.movie_id\nJOIN \n    aka_name AS a ON ci.person_id = a.person_id\nJOIN \n    movie_keyword AS mk ON t.id = mk.movie_id\nJOIN \n    keyword AS k ON mk.keyword_id = k.id\nJOIN \n    movie_companies AS mc ON t.id = mc.movie_id\nJOIN \n    company_name AS c ON mc.company_id = c.id\nJOIN \n    company_type AS ty ON mc.company_type_id = ty.id\nJOIN \n    person_info AS p ON a.person_id = p.person_id\nORDER BY \n    t.production_year DESC, \n    t.title \nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT id, title, production_year FROM aka_title ORDER BY production_year DESC, title LIMIT 100;", "sql2": "SELECT s1.title,\n       a.name AS actor_name,\n       k.keyword AS movie_keyword,\n       c.name AS company_name,\n       ty.kind AS company_type,\n       p.info AS person_info\nFROM s1\nJOIN cast_info ci ON s1.id = ci.movie_id\nJOIN aka_name a ON ci.person_id = a.person_id\nJOIN movie_keyword mk ON s1.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nJOIN movie_companies mc ON s1.id = mc.movie_id\nJOIN company_name c ON mc.company_id = c.id\nJOIN company_type ty ON mc.company_type_id = ty.id\nJOIN person_info p ON a.person_id = p.person_id;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "10506.sql", "original_sql": "SELECT \n    t.title AS movie_title,\n    a.name AS actor_name,\n    ci.nr_order AS cast_order,\n    ct.kind AS company_type,\n    k.keyword AS movie_keyword\nFROM \n    title t\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info ci ON cc.subject_id = ci.id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.title, ci.nr_order;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    t.id AS movie_id,\n    t.title AS movie_title,\n    a.name AS actor_name,\n    ci.nr_order AS cast_order,\n    ct.kind AS company_type,\n    k.keyword AS movie_keyword\nFROM title t\nJOIN complete_cast cc ON t.id = cc.movie_id\nJOIN cast_info ci ON cc.subject_id = ci.id\nJOIN aka_name a ON ci.person_id = a.person_id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type ct ON mc.company_type_id = ct.id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE t.production_year >= 2000;", "sql2": "SELECT movie_title, actor_name, cast_order, company_type, movie_keyword\nFROM s1\nORDER BY movie_title, cast_order;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "10575.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    p.name AS person_name,\n    c.note AS cast_note,\n    k.keyword AS movie_keyword,\n    ci.kind AS company_type\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    title t ON c.movie_id = t.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type ci ON mc.company_type_id = ci.id\nJOIN \n    name p ON a.person_id = p.imdb_id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.production_year DESC, a.name;\n", "status": "killed", "exitcode": -11, "signal": 11, "engine_mem_mb": 500000}
{"query_id": "10611.sql", "original_sql": "SELECT \n    a.id AS aka_id,\n    a.name AS aka_name,\n    t.id AS title_id,\n    t.title AS title_name,\n    c.id AS cast_id,\n    c.note AS cast_note,\n    p.id AS person_id,\n    p.name AS person_name,\n    r.role AS person_role\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    title t ON c.movie_id = t.id\nJOIN \n    name p ON a.person_id = p.id\nJOIN \n    role_type r ON c.role_id = r.id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    c.person_id,\n    c.id AS cast_id,\n    c.note AS cast_note,\n    c.role_id,\n    t.id AS title_id,\n    t.title AS title_name,\n    t.production_year\nFROM cast_info c\nJOIN title t ON c.movie_id = t.id\nWHERE t.production_year >= 2000;", "sql2": "SELECT\n    a.id AS aka_id,\n    a.name AS aka_name,\n    s.title_id,\n    s.title_name,\n    s.cast_id,\n    s.cast_note,\n    p.id AS person_id,\n    p.name AS person_name,\n    r.role AS person_role\nFROM s1 s\nJOIN aka_name a ON a.person_id = s.person_id\nJOIN name p ON a.person_id = p.id\nJOIN role_type r ON s.role_id = r.id\nORDER BY s.production_year DESC, a.name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "10776.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    c.kind AS cast_type,\n    k.keyword AS movie_keyword\nFROM \n    aka_name AS a\nJOIN \n    cast_info AS ci ON a.person_id = ci.person_id\nJOIN \n    aka_title AS t ON ci.movie_id = t.movie_id\nJOIN \n    movie_keyword AS mk ON t.id = mk.movie_id\nJOIN \n    keyword AS k ON mk.keyword_id = k.id\nJOIN \n    comp_cast_type AS c ON ci.role_id = c.id\nORDER BY \n    t.production_year DESC, \n    a.name;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT a.person_id, a.name AS actor_name, ci.movie_id, c.kind AS cast_type FROM aka_name AS a JOIN cast_info AS ci ON a.person_id = ci.person_id JOIN comp_cast_type AS c ON ci.role_id = c.id", "sql2": "SELECT s1.actor_name, t.title AS movie_title, t.production_year, s1.cast_type, k.keyword AS movie_keyword FROM s1 JOIN aka_title AS t ON s1.movie_id = t.movie_id JOIN movie_keyword AS mk ON t.id = mk.movie_id JOIN keyword AS k ON mk.keyword_id = k.id ORDER BY t.production_year DESC, s1.actor_name", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "10883.sql", "original_sql": "SELECT \n    t.title AS movie_title,\n    n.name AS person_name,\n    a.name AS aka_name,\n    c.kind AS company_type,\n    k.keyword AS movie_keyword,\n    r.role AS person_role\nFROM \n    title t\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    cast_info ci ON t.id = ci.movie_id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    name n ON a.person_id = n.imdb_id\nJOIN \n    role_type r ON ci.role_id = r.id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.title, n.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS movie_id,\n       t.title AS movie_title,\n       k.keyword AS movie_keyword\nFROM title t\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE t.production_year >= 2000;", "sql2": "SELECT \n    s1.movie_title,\n    n.name AS person_name,\n    a.name AS aka_name,\n    c.kind AS company_type,\n    s1.movie_keyword,\n    r.role AS person_role\nFROM s1\nJOIN movie_companies mc ON s1.movie_id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nJOIN cast_info ci ON s1.movie_id = ci.movie_id\nJOIN aka_name a ON ci.person_id = a.person_id\nJOIN name n ON a.person_id = n.id\nJOIN role_type r ON ci.role_id = r.id\nORDER BY s1.movie_title, n.name;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "11035.sql", "original_sql": "SELECT \n    t.title,\n    a.name AS actor_name,\n    c.kind AS company_type,\n    k.keyword AS keyword\nFROM \n    title t\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info ci ON cc.subject_id = ci.id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT id, title, production_year FROM title WHERE production_year >= 2000", "sql2": "SELECT \n    s1.title,\n    a.name AS actor_name,\n    c.kind AS company_type,\n    k.keyword AS keyword\nFROM \n    s1\nJOIN \n    movie_keyword mk ON s1.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    complete_cast cc ON s1.id = cc.movie_id\nJOIN \n    cast_info ci ON cc.subject_id = ci.id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    movie_companies mc ON s1.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nORDER BY \n    s1.production_year DESC,\n    a.name", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11085.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    c.kind AS company_type,\n    ki.keyword AS movie_keyword\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    aka_title t ON ci.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword ki ON mk.keyword_id = ki.id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT a.name AS actor_name,\n       t.id AS movie_id,\n       t.title AS movie_title,\n       t.production_year\nFROM aka_name a\nJOIN cast_info ci ON a.person_id = ci.person_id\nJOIN aka_title t ON ci.movie_id = t.movie_id\nWHERE t.production_year >= 2000", "sql2": "SELECT s1.actor_name,\n       s1.movie_title,\n       s1.production_year,\n       c.kind AS company_type,\n       ki.keyword AS movie_keyword\nFROM s1\nJOIN movie_companies mc ON s1.movie_id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nJOIN movie_keyword mk ON s1.movie_id = mk.movie_id\nJOIN keyword ki ON mk.keyword_id = ki.id\nORDER BY s1.production_year DESC, s1.actor_name", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11245.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    c.note AS cast_note,\n    n.name AS person_name,\n    k.keyword AS movie_keyword\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    aka_title t ON c.movie_id = t.movie_id\nJOIN \n    name n ON a.person_id = n.imdb_id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.production_year ASC, \n    a.name ASC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    t.id AS movie_id,\n    t.title AS movie_title,\n    t.production_year,\n    k.keyword AS movie_keyword\nFROM aka_title t\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE t.production_year >= 2000;", "sql2": "SELECT \n    a.name AS aka_name,\n    s1.movie_title,\n    c.note AS cast_note,\n    n.name AS person_name,\n    s1.movie_keyword\nFROM aka_name a\nJOIN cast_info c ON a.person_id = c.person_id\nJOIN name n ON a.person_id = n.imdb_id\nJOIN s1 ON c.movie_id = s1.movie_id\nORDER BY s1.production_year ASC, a.name ASC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11280.sql", "original_sql": "SELECT \n    t.title AS movie_title,\n    a.name AS actor_name,\n    p.info AS person_info,\n    c.kind AS cast_type,\n    k.keyword AS movie_keyword\nFROM \n    title t\nJOIN \n    movie_info mi ON t.id = mi.movie_id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info ci ON cc.subject_id = ci.id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    person_info p ON a.person_id = p.person_id\nJOIN \n    comp_cast_type c ON ci.role_id = c.id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.production_year DESC, \n    a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS movie_id,\n       t.title AS movie_title,\n       t.production_year\nFROM   title t\nWHERE  t.production_year >= 2000;", "sql2": "SELECT s1.movie_title,\n       a.name          AS actor_name,\n       p.info          AS person_info,\n       c.kind          AS cast_type,\n       k.keyword       AS movie_keyword\nFROM   s1\nJOIN   movie_info mi      ON s1.movie_id = mi.movie_id\nJOIN   movie_keyword mk   ON s1.movie_id = mk.movie_id\nJOIN   keyword k          ON mk.keyword_id = k.id\nJOIN   complete_cast cc  ON s1.movie_id = cc.movie_id\nJOIN   cast_info ci       ON cc.subject_id = ci.id\nJOIN   aka_name a         ON ci.person_id = a.person_id\nJOIN   person_info p      ON a.person_id = p.person_id\nJOIN   comp_cast_type c   ON ci.role_id = c.id\nORDER BY s1.production_year DESC,\n         a.name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11433.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    r.role AS actor_role,\n    c.kind AS company_type\nFROM \n    cast_info ci\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    aka_title t ON ci.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    role_type r ON ci.role_id = r.id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT at.id AS movie_id,\n       at.title AS movie_title,\n       at.production_year,\n       ct.kind AS company_type\nFROM   aka_title at\nJOIN   movie_companies mc ON at.id = mc.movie_id\nJOIN   company_type ct   ON mc.company_type_id = ct.id\nWHERE  at.production_year >= 2000", "sql2": "SELECT a.name AS actor_name,\n       s1.movie_title,\n       s1.production_year,\n       r.role AS actor_role,\n       s1.company_type\nFROM   cast_info ci\nJOIN   aka_name a   ON ci.person_id = a.person_id\nJOIN   role_type r  ON ci.role_id = r.id\nJOIN   s1          ON ci.movie_id = s1.movie_id\nORDER BY s1.production_year DESC,\n         a.name", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "11485.sql", "original_sql": "SELECT a.name AS actor_name, t.title AS movie_title, c.kind AS company_type, k.keyword AS movie_keyword \nFROM aka_name a\nJOIN cast_info ci ON a.person_id = ci.person_id\nJOIN aka_title t ON ci.movie_id = t.movie_id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE t.production_year > 2000\nORDER BY t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT a.name AS actor_name, t.title AS movie_title, t.id AS movie_id, t.production_year FROM aka_name a JOIN cast_info ci ON a.person_id = ci.person_id JOIN aka_title t ON ci.movie_id = t.movie_id WHERE t.production_year > 2000", "sql2": "SELECT s1.actor_name, s1.movie_title, c.kind AS company_type, k.keyword AS movie_keyword FROM s1 JOIN movie_companies mc ON s1.movie_id = mc.movie_id JOIN company_type c ON mc.company_type_id = c.id JOIN movie_keyword mk ON s1.movie_id = mk.movie_id JOIN keyword k ON mk.keyword_id = k.id ORDER BY s1.production_year DESC, s1.actor_name", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11644.sql", "original_sql": "SELECT \n    t.title AS movie_title,\n    ak.name AS actor_name,\n    c.kind AS company_type,\n    m.info AS movie_info\nFROM \n    title t\nJOIN \n    aka_title ak_t ON ak_t.movie_id = t.id\nJOIN \n    aka_name ak ON ak.person_id = ak_t.id\nJOIN \n    cast_info ci ON ci.movie_id = t.id AND ci.person_id = ak.person_id\nJOIN \n    movie_companies mc ON mc.movie_id = t.id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_info m ON m.movie_id = t.id\nWHERE \n    t.production_year > 2000\nORDER BY \n    t.production_year DESC, ak.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT DISTINCT id AS movie_id, production_year\nFROM title\nWHERE production_year > 2000;", "sql2": "SELECT \n    t.title AS movie_title,\n    ak.name AS actor_name,\n    c.kind AS company_type,\n    m.info AS movie_info\nFROM s1\nJOIN title t ON t.id = s1.movie_id\nJOIN aka_title ak_t ON ak_t.movie_id = t.id\nJOIN aka_name ak ON ak.person_id = ak_t.id\nJOIN cast_info ci ON ci.movie_id = t.id AND ci.person_id = ak.person_id\nJOIN movie_companies mc ON mc.movie_id = t.id\nJOIN company_type c ON mc.company_type_id = c.id\nJOIN movie_info m ON m.movie_id = t.id\nORDER BY s1.production_year DESC, ak.name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11681.sql", "original_sql": "SELECT\n    t.title,\n    a.name AS actor_name,\n    c.kind AS company_type,\n    m.info AS movie_info,\n    k.keyword AS movie_keyword\nFROM\n    title t\nJOIN\n    movie_info m ON t.id = m.movie_id\nJOIN\n    movie_keyword mk ON t.id = mk.movie_id\nJOIN\n    keyword k ON mk.keyword_id = k.id\nJOIN\n    movie_companies mc ON t.id = mc.movie_id\nJOIN\n    company_type c ON mc.company_type_id = c.id\nJOIN\n    complete_cast cc ON t.id = cc.movie_id\nJOIN\n    cast_info ci ON cc.subject_id = ci.person_id\nJOIN\n    aka_name a ON ci.person_id = a.person_id\nWHERE\n    t.production_year > 2000\nORDER BY\n    t.title, a.name;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "11690.sql", "original_sql": "SELECT \n    t.title,\n    a.name AS actor_name,\n    r.role AS role,\n    c.note AS cast_note,\n    co.name AS company_name,\n    ki.keyword AS movie_keyword\nFROM \n    title t\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info c ON cc.subject_id = c.id\nJOIN \n    aka_name a ON c.person_id = a.person_id\nJOIN \n    role_type r ON c.role_id = r.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name co ON mc.company_id = co.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword ki ON mk.keyword_id = ki.id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.title;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT id, title FROM title WHERE production_year >= 2000", "sql2": "SELECT s1.title,\n       a.name AS actor_name,\n       r.role AS role,\n       c.note AS cast_note,\n       co.name AS company_name,\n       ki.keyword AS movie_keyword\nFROM s1\nJOIN complete_cast cc ON s1.id = cc.movie_id\nJOIN cast_info c ON cc.subject_id = c.id\nJOIN aka_name a ON c.person_id = a.person_id\nJOIN role_type r ON c.role_id = r.id\nJOIN movie_companies mc ON s1.id = mc.movie_id\nJOIN company_name co ON mc.company_id = co.id\nJOIN movie_keyword mk ON s1.id = mk.movie_id\nJOIN keyword ki ON mk.keyword_id = ki.id\nORDER BY s1.title;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11718.sql", "original_sql": "SELECT \n    t.title AS movie_title,\n    a.name AS actor_name,\n    p.info AS actor_info,\n    c.kind AS cast_type,\n    k.keyword AS movie_keyword,\n    m.info AS movie_info\nFROM \n    title t\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info ci ON cc.subject_id = ci.id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    person_info p ON a.person_id = p.person_id\nJOIN \n    comp_cast_type c ON ci.role_id = c.id\nJOIN \n    movie_info m ON t.id = m.movie_id\nWHERE \n    t.production_year > 2000\nORDER BY \n    t.production_year DESC, t.title;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    t.id AS movie_id,\n    t.title AS movie_title,\n    t.production_year,\n    k.keyword AS movie_keyword,\n    m.info AS movie_info\nFROM title t\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nJOIN movie_info m ON t.id = m.movie_id\nWHERE t.production_year > 2000;", "sql2": "SELECT \n    s1.movie_title,\n    a.name AS actor_name,\n    p.info AS actor_info,\n    c.kind AS cast_type,\n    s1.movie_keyword,\n    s1.movie_info\nFROM s1\nJOIN complete_cast cc ON s1.movie_id = cc.movie_id\nJOIN cast_info ci ON cc.subject_id = ci.id\nJOIN aka_name a ON ci.person_id = a.person_id\nJOIN person_info p ON a.person_id = p.person_id\nJOIN comp_cast_type c ON ci.role_id = c.id\nORDER BY s1.production_year DESC, s1.movie_title;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11727.sql", "original_sql": "SELECT \n    n.name AS actor_name,\n    t.title AS movie_title,\n    c.nr_order AS role_order,\n    k.keyword AS movie_keyword,\n    r.role AS role_type\nFROM \n    cast_info c\nJOIN \n    aka_name n ON c.person_id = n.person_id\nJOIN \n    aka_title t ON c.movie_id = t.movie_id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    role_type r ON c.role_id = r.id\nWHERE \n    t.production_year BETWEEN 2000 AND 2023\nORDER BY \n    t.production_year DESC, c.nr_order;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT c.person_id,\n       c.movie_id,\n       c.nr_order,\n       c.role_id,\n       n.name AS actor_name,\n       t.title AS movie_title,\n       t.production_year\nFROM cast_info c\nJOIN aka_name n ON c.person_id = n.person_id\nJOIN aka_title t ON c.movie_id = t.movie_id\nWHERE t.production_year BETWEEN 2000 AND 2023;", "sql2": "SELECT s1.actor_name,\n       s1.movie_title,\n       s1.nr_order,\n       k.keyword AS movie_keyword,\n       r.role AS role_type\nFROM s1\nJOIN movie_keyword mk ON s1.movie_id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nJOIN role_type r ON s1.role_id = r.id\nORDER BY s1.production_year DESC, s1.nr_order;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "11744.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    c.nr_order AS cast_order,\n    n.name AS actor_name,\n    ci.kind AS company_type\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    title t ON c.movie_id = t.id\nJOIN \n    name n ON a.person_id = n.imdb_id\nJOIN \n    movie_companies mc ON mc.movie_id = t.id\nJOIN \n    company_type ci ON mc.company_type_id = ci.id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.production_year DESC, c.nr_order;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT t.id AS movie_id,\n       t.title AS movie_title,\n       t.production_year,\n       ci.kind AS company_type\nFROM title t\nJOIN movie_companies mc ON mc.movie_id = t.id\nJOIN company_type ci ON mc.company_type_id = ci.id\nWHERE t.production_year >= 2000", "sql2": "SELECT a.name AS aka_name,\n       s1.movie_title,\n       c.nr_order AS cast_order,\n       n.name AS actor_name,\n       s1.company_type\nFROM s1\nJOIN cast_info c ON c.movie_id = s1.movie_id\nJOIN aka_name a ON a.person_id = c.person_id\nJOIN name n ON a.person_id = n.imdb_id\nORDER BY s1.production_year DESC, c.nr_order", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11793.sql", "original_sql": "SELECT \n    t.title, \n    ak.name AS aka_name, \n    c.person_id, \n    p.info AS person_info, \n    k.keyword \nFROM \n    title t\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info c ON cc.subject_id = c.id\nJOIN \n    aka_name ak ON c.person_id = ak.person_id\nJOIN \n    person_info p ON c.person_id = p.person_id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.production_year DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT id, title, production_year FROM title WHERE production_year >= 2000", "sql2": "SELECT s1.title,\n       ak.name AS aka_name,\n       c.person_id,\n       p.info AS person_info,\n       k.keyword\nFROM   s1\nJOIN   movie_companies mc ON s1.id = mc.movie_id\nJOIN   company_name cn ON mc.company_id = cn.id\nJOIN   complete_cast cc ON s1.id = cc.movie_id\nJOIN   cast_info c ON cc.subject_id = c.id\nJOIN   aka_name ak ON c.person_id = ak.person_id\nJOIN   person_info p ON c.person_id = p.person_id\nJOIN   movie_keyword mk ON s1.id = mk.movie_id\nJOIN   keyword k ON mk.keyword_id = k.id\nORDER BY s1.production_year DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11870.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    c.kind AS company_type,\n    k.keyword AS movie_keyword\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    aka_title t ON ci.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    t.production_year > 2000\nORDER BY \n    t.production_year DESC, a.name;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 115, in _run_on_datafusion\n    return df.to_arrow_table()\n           ^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/dataframe.py\", line 1164, in to_arrow_table\n    return self.df.to_arrow_table()\n           ^^^^^^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Shared(ResourcesExhausted(\"Additional allocation failed with top memory consumers (across reservations) as:\\n  ExternalSorter[131]#904(can spill: true) consumed 3.8 GB, peak 3.9 GB,\\n  ExternalSorter[234]#1216(can spill: true) consumed 3.7 GB, peak 3.7 GB,\\n  ExternalSorter[54]#420(can spill: true) consumed 3.7 GB, peak 3.7 GB,\\n  ExternalSorter[164]#1006(can spill: true) consumed 3.6 GB, peak 3.6 GB,\\n  ExternalSorter[187]#1075(can spill: true) consumed 3.5 GB, peak 3.5 GB.\\nError: Failed to allocate additional 81.3 MB for RepartitionExec[84] with 0.0 B already allocated for this reservation - 35.0 MB remain available for the total pool\"))\n", "engine_mem_mb": 500000}
{"query_id": "11914.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    r.role AS actor_role,\n    c.kind AS company_type\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    role_type r ON ci.role_id = r.id\nWHERE \n    t.production_year > 2000\nORDER BY \n    t.production_year DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS movie_id,\n       t.title,\n       t.production_year,\n       c.kind AS company_type\nFROM title t\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nWHERE t.production_year > 2000;", "sql2": "SELECT a.name AS actor_name,\n       s1.title AS movie_title,\n       s1.production_year,\n       r.role AS actor_role,\n       s1.company_type\nFROM s1\nJOIN cast_info ci ON s1.movie_id = ci.movie_id\nJOIN aka_name a ON ci.person_id = a.person_id\nJOIN role_type r ON ci.role_id = r.id\nORDER BY s1.production_year DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "12014.sql", "original_sql": "SELECT\n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.nr_order AS cast_order,\n    ct.kind AS company_type,\n    m.info AS movie_info,\n    k.keyword AS movie_keyword\nFROM\n    aka_name a\nJOIN\n    cast_info c ON a.person_id = c.person_id\nJOIN\n    aka_title t ON c.movie_id = t.movie_id\nJOIN\n    movie_companies mc ON t.id = mc.movie_id\nJOIN\n    company_type ct ON mc.company_type_id = ct.id\nJOIN\n    movie_info m ON t.id = m.movie_id\nJOIN\n    movie_keyword mk ON t.id = mk.movie_id\nJOIN\n    keyword k ON mk.keyword_id = k.id\nWHERE\n    m.info_type_id = (SELECT id FROM info_type WHERE info = 'Some Info Type')\nORDER BY\n    t.production_year DESC, a.name, t.title;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "12070.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    p.name AS person_name,\n    c.role_id AS role_id,\n    m.info AS movie_info\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    title t ON c.movie_id = t.id\nJOIN \n    movie_info m ON t.id = m.movie_id\nJOIN \n    name p ON a.person_id = p.imdb_id\nWHERE \n    t.production_year > 2000\nORDER BY \n    t.production_year, a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS movie_id,\n       t.title AS movie_title,\n       t.production_year,\n       m.info AS movie_info\nFROM title t\nJOIN movie_info m ON t.id = m.movie_id\nWHERE t.production_year > 2000;", "sql2": "SELECT a.name AS aka_name,\n       s1.movie_title,\n       p.name AS person_name,\n       c.role_id,\n       s1.movie_info\nFROM aka_name a\nJOIN cast_info c ON a.person_id = c.person_id\nJOIN name p ON a.person_id = p.imdb_id\nJOIN s1 ON c.movie_id = s1.movie_id\nORDER BY s1.production_year, a.name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "12174.sql", "original_sql": "SELECT \n    t.title AS movie_title,\n    ak.name AS actor_name,\n    ct.kind AS company_type,\n    ki.keyword AS movie_keyword,\n    ci.note AS cast_note,\n    pi.info AS person_info\nFROM \n    title t\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword ki ON mk.keyword_id = ki.id\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info ci ON cc.subject_id = ci.person_id\nJOIN \n    aka_name ak ON ci.person_id = ak.person_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nJOIN \n    person_info pi ON ak.person_id = pi.person_id\nWHERE \n    t.production_year >= 2000 \nORDER BY \n    t.production_year DESC, \n    ak.name;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'person_id' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column ci.person_id\", span: None }, DiagnosticNote { message: \"possible column ci.person_role_id\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"person_id\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"person_id\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"movie_id\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"person_role_id\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"note\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"nr_order\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"role_id\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "12188.sql", "original_sql": "\nSELECT\n    t.title,\n    a.name AS actor_name,\n    t.production_year,\n    COUNT(c.id) AS total_cast_members\nFROM\n    title t\nJOIN\n    movie_companies mc ON t.id = mc.movie_id\nJOIN\n    company_name cn ON mc.company_id = cn.id\nJOIN\n    cast_info c ON t.id = c.movie_id\nJOIN\n    aka_name a ON c.person_id = a.person_id\nWHERE\n    t.production_year >= 2000\nGROUP BY\n    t.title, a.name, t.production_year\nORDER BY\n    t.production_year DESC, total_cast_members DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT c.movie_id, a.name AS actor_name, COUNT(c.id) AS total_cast_members FROM cast_info c JOIN aka_name a ON c.person_id = a.person_id JOIN title t ON c.movie_id = t.id WHERE t.production_year >= 2000 GROUP BY c.movie_id, a.name", "sql2": "SELECT t.title, s1.actor_name, t.production_year, s1.total_cast_members FROM s1 JOIN title t ON s1.movie_id = t.id JOIN movie_companies mc ON t.id = mc.movie_id JOIN company_name cn ON mc.company_id = cn.id ORDER BY t.production_year DESC, s1.total_cast_members DESC", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "12200.sql", "original_sql": "SELECT \n    t.title AS movie_title,\n    a.name AS actor_name,\n    r.role AS actor_role,\n    c.note AS cast_note,\n    ti.info AS movie_info\nFROM \n    title t\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    cast_info c ON t.id = c.movie_id\nJOIN \n    aka_name a ON c.person_id = a.person_id\nJOIN \n    role_type r ON c.role_id = r.id\nLEFT JOIN \n    movie_info ti ON t.id = ti.movie_id\nWHERE \n    cn.country_code = 'USA'\nORDER BY \n    t.production_year DESC, \n    a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT DISTINCT t.id AS title_id,\n                t.title,\n                t.production_year\nFROM title t\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nWHERE cn.country_code = 'USA'", "sql2": "SELECT \n    s1.title AS movie_title,\n    a.name AS actor_name,\n    r.role AS actor_role,\n    c.note AS cast_note,\n    ti.info AS movie_info\nFROM s1\nJOIN cast_info c ON s1.title_id = c.movie_id\nJOIN aka_name a ON c.person_id = a.person_id\nJOIN role_type r ON c.role_id = r.id\nLEFT JOIN movie_info ti ON s1.title_id = ti.movie_id\nORDER BY s1.production_year DESC, a.name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "12371.sql", "original_sql": "SELECT \n    t.title AS movie_title,\n    a.name AS actor_name,\n    c.kind AS character_type,\n    k.keyword AS movie_keyword,\n    p.info AS person_info,\n    m.note AS movie_note\nFROM \n    title t\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    aka_name a ON cc.subject_id = a.person_id\nJOIN \n    cast_info ci ON a.person_id = ci.person_id AND ci.movie_id = t.id\nJOIN \n    comp_cast_type c ON ci.person_role_id = c.id\nJOIN \n    person_info p ON a.person_id = p.person_id\nJOIN \n    movie_info m ON t.id = m.movie_id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.production_year DESC, a.name;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'movie_id' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column cc.movie_id\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"movie_id\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"cc\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"cc\" }), name: \"movie_id\" }, Column { relation: Some(Bare { table: \"cc\" }), name: \"subject_id\" }, Column { relation: Some(Bare { table: \"cc\" }), name: \"status_id\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "12377.sql", "original_sql": "SELECT\n    t.title,\n    a.name AS actor_name,\n    k.keyword,\n    c.kind AS company_type,\n    i.info AS movie_info\nFROM\n    title t\nJOIN\n    movie_keyword mk ON t.id = mk.movie_id\nJOIN\n    keyword k ON mk.keyword_id = k.id\nJOIN\n    movie_companies mc ON t.id = mc.movie_id\nJOIN\n    company_type c ON mc.company_type_id = c.id\nJOIN\n    complete_cast cc ON t.id = cc.movie_id\nJOIN\n    aka_name a ON cc.subject_id = a.person_id\nJOIN\n    movie_info mi ON t.id = mi.movie_id\nJOIN\n    info_type i ON mi.info_type_id = i.id\nWHERE\n    t.production_year >= 2000\nORDER BY\n    t.title, a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    t.id AS title_id,\n    t.title,\n    a.name AS actor_name,\n    k.keyword,\n    c.kind AS company_type\nFROM title t\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nJOIN complete_cast cc ON t.id = cc.movie_id\nJOIN aka_name a ON cc.subject_id = a.person_id\nWHERE t.production_year >= 2000;", "sql2": "SELECT\n    s1.title,\n    s1.actor_name,\n    s1.keyword,\n    s1.company_type,\n    i.info AS movie_info\nFROM s1\nJOIN movie_info mi ON s1.title_id = mi.movie_id\nJOIN info_type i ON mi.info_type_id = i.id\nORDER BY s1.title, s1.actor_name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "12715.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    c.nr_order AS cast_order,\n    p.name AS person_name,\n    co.name AS company_name,\n    k.keyword AS keyword\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    title t ON c.movie_id = t.id\nJOIN \n    name p ON c.person_id = p.imdb_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name co ON mc.company_id = co.imdb_id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    t.production_year > 2000\nORDER BY \n    t.production_year DESC, c.nr_order;\n", "status": "killed", "exitcode": -6, "signal": 6, "engine_mem_mb": 500000}
{"query_id": "13056.sql", "original_sql": "SELECT \n    t.title AS movie_title,\n    a.name AS actor_name,\n    c.role_id AS role_id,\n    m.name AS company_name,\n    k.keyword AS movie_keyword\nFROM \n    title t\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info c ON cc.subject_id = c.person_id\nJOIN \n    aka_name a ON c.person_id = a.person_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name m ON mc.company_id = m.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    t.production_year > 2000\nORDER BY \n    t.production_year, a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    t.id AS movie_id,\n    t.title AS movie_title,\n    t.production_year,\n    a.name AS actor_name,\n    c.role_id,\n    m.name AS company_name\nFROM title t\nJOIN complete_cast cc ON t.id = cc.movie_id\nJOIN cast_info c ON cc.subject_id = c.person_id\nJOIN aka_name a ON c.person_id = a.person_id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_name m ON mc.company_id = m.id\nWHERE t.production_year > 2000", "sql2": "SELECT \n    s1.movie_title,\n    s1.actor_name,\n    s1.role_id,\n    s1.company_name,\n    k.keyword AS movie_keyword\nFROM s1\nJOIN movie_keyword mk ON s1.movie_id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nORDER BY s1.production_year, s1.actor_name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "13057.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    c.note AS cast_note,\n    n.name AS person_name,\n    rt.role AS role,\n    ci.kind AS comp_cast_type\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    title t ON c.movie_id = t.id\nJOIN \n    name n ON a.person_id = n.imdb_id\nJOIN \n    role_type rt ON c.role_id = rt.id\nJOIN \n    comp_cast_type ci ON c.person_role_id = ci.id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    a.person_id,\n    a.name AS aka_name,\n    c.id AS cast_id,\n    c.note AS cast_note,\n    c.role_id,\n    c.person_role_id,\n    t.id AS title_id,\n    t.title AS movie_title,\n    t.production_year\nFROM aka_name a\nJOIN cast_info c ON a.person_id = c.person_id\nJOIN title t ON c.movie_id = t.id\nWHERE t.production_year >= 2000", "sql2": "SELECT \n    s1.aka_name,\n    s1.movie_title,\n    s1.cast_note,\n    n.name AS person_name,\n    rt.role AS role,\n    ci.kind AS comp_cast_type\nFROM s1\nLEFT JOIN name n ON s1.person_id = n.imdb_id\nLEFT JOIN role_type rt ON s1.role_id = rt.id\nLEFT JOIN comp_cast_type ci ON s1.person_role_id = ci.id\nORDER BY s1.production_year DESC, s1.aka_name", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "13178.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    c.nr_order,\n    r.role,\n    p.info AS person_info,\n    m.info AS movie_info\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    title t ON c.movie_id = t.id\nJOIN \n    role_type r ON c.role_id = r.id\nJOIN \n    person_info p ON a.person_id = p.person_id\nJOIN \n    movie_info m ON t.id = m.movie_id\nWHERE \n    m.info_type_id IN (SELECT id FROM info_type WHERE info = 'Some Info Criteria') \n    AND c.nr_order IS NOT NULL \nORDER BY \n    t.production_year DESC, \n    a.name;", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT movie_id, info FROM movie_info WHERE info_type_id IN (SELECT id FROM info_type WHERE info = 'Some Info Criteria');", "sql2": "SELECT a.name AS aka_name,\n       t.title AS movie_title,\n       c.nr_order,\n       r.role,\n       p.info AS person_info,\n       s1.info AS movie_info\nFROM aka_name a\nJOIN cast_info c ON a.person_id = c.person_id\nJOIN title t ON c.movie_id = t.id\nJOIN role_type r ON c.role_id = r.id\nJOIN person_info p ON a.person_id = p.person_id\nJOIN s1 ON t.id = s1.movie_id\nWHERE c.nr_order IS NOT NULL\nORDER BY t.production_year DESC, a.name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "13244.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    c.name AS company_name,\n    r.role AS role \nFROM \n    cast_info ci\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    aka_title t ON ci.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name c ON mc.company_id = c.id\nJOIN \n    role_type r ON ci.role_id = r.id\nWHERE \n    t.production_year BETWEEN 1990 AND 2020\nORDER BY \n    t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT id, title, production_year FROM aka_title WHERE production_year BETWEEN 1990 AND 2020", "sql2": "SELECT a.name AS actor_name, s1.title AS movie_title, s1.production_year, c.name AS company_name, r.role AS role FROM s1 JOIN cast_info ci ON ci.movie_id = s1.id JOIN aka_name a ON ci.person_id = a.person_id JOIN movie_companies mc ON s1.id = mc.movie_id JOIN company_name c ON mc.company_id = c.id JOIN role_type r ON ci.role_id = r.id ORDER BY s1.production_year DESC, a.name", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "13323.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    c.note AS cast_note,\n    cn.name AS company_name,\n    kt.keyword AS movie_keyword,\n    mt.kind AS company_type,\n    p.info AS person_info\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    aka_title t ON c.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    company_type mt ON mc.company_type_id = mt.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword kt ON mk.keyword_id = kt.id\nJOIN \n    person_info p ON a.person_id = p.person_id\nWHERE \n    p.info_type_id IN (SELECT id FROM info_type WHERE info = 'biography')\nORDER BY \n    t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT DISTINCT a.person_id,\n       a.name AS aka_name,\n       p.info AS person_info\nFROM   aka_name a\nJOIN   person_info p ON a.person_id = p.person_id\nWHERE  p.info_type_id IN (SELECT id FROM info_type WHERE info = 'biography');", "sql2": "SELECT \n    s1.aka_name,\n    t.title AS movie_title,\n    c.note AS cast_note,\n    cn.name AS company_name,\n    kt.keyword AS movie_keyword,\n    mt.kind AS company_type,\n    s1.person_info\nFROM   s1\nJOIN   cast_info c ON s1.person_id = c.person_id\nJOIN   aka_title t ON c.movie_id = t.movie_id\nJOIN   movie_companies mc ON t.id = mc.movie_id\nJOIN   company_name cn ON mc.company_id = cn.id\nJOIN   company_type mt ON mc.company_type_id = mt.id\nJOIN   movie_keyword mk ON t.id = mk.movie_id\nJOIN   keyword kt ON mk.keyword_id = kt.id\nORDER BY t.production_year DESC, s1.aka_name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "13434.sql", "original_sql": "SELECT \n    t.title AS movie_title,\n    a.name AS actor_name,\n    r.role AS actor_role,\n    c.name AS company_name,\n    m.info AS movie_info\nFROM \n    title t\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name c ON mc.company_id = c.id\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info ci ON cc.subject_id = ci.person_id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    role_type r ON ci.role_id = r.id\nLEFT JOIN \n    movie_info m ON t.id = m.movie_id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.production_year DESC, \n    a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    t.id AS movie_id,\n    t.title AS movie_title,\n    t.production_year,\n    a.name AS actor_name,\n    r.role AS actor_role,\n    c.name AS company_name\nFROM title t\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_name c ON mc.company_id = c.id\nJOIN complete_cast cc ON t.id = cc.movie_id\nJOIN cast_info ci ON cc.subject_id = ci.person_id\nJOIN aka_name a ON ci.person_id = a.person_id\nJOIN role_type r ON ci.role_id = r.id\nWHERE t.production_year >= 2000", "sql2": "SELECT \n    s1.movie_title,\n    s1.actor_name,\n    s1.actor_role,\n    s1.company_name,\n    m.info AS movie_info\nFROM s1\nLEFT JOIN movie_info m ON s1.movie_id = m.movie_id\nORDER BY s1.production_year DESC, s1.actor_name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "13568.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    c.note AS cast_note,\n    cn.name AS company_name,\n    k.keyword AS movie_keyword,\n    pi.info AS person_info\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    aka_title t ON c.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    person_info pi ON a.person_id = pi.person_id\nWHERE \n    pi.info_type_id = (SELECT id FROM info_type WHERE info = 'Biography')\nORDER BY \n    t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT a.person_id,\n       a.name AS aka_name,\n       c.movie_id,\n       c.note AS cast_note,\n       pi.info AS person_info\nFROM   aka_name a\nJOIN   cast_info c ON a.person_id = c.person_id\nJOIN   person_info pi ON a.person_id = pi.person_id\nWHERE  pi.info_type_id = (SELECT id FROM info_type WHERE info = 'Biography');", "sql2": "SELECT s1.aka_name,\n       t.title AS movie_title,\n       s1.cast_note,\n       cn.name AS company_name,\n       k.keyword AS movie_keyword,\n       s1.person_info\nFROM   s1\nJOIN   aka_title t ON s1.movie_id = t.movie_id\nJOIN   movie_companies mc ON t.id = mc.movie_id\nJOIN   company_name cn ON mc.company_id = cn.id\nJOIN   movie_keyword mk ON t.id = mk.movie_id\nJOIN   keyword k ON mk.keyword_id = k.id\nORDER BY t.production_year DESC, s1.aka_name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "13620.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    c.note AS cast_note,\n    k.keyword AS movie_keyword,\n    co.name AS company_name,\n    ct.kind AS company_type\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    aka_title t ON c.movie_id = t.movie_id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name co ON mc.company_id = co.id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT id, movie_id, title, production_year FROM aka_title WHERE production_year >= 2000;", "sql2": "SELECT a.name AS aka_name,\n       s1.title AS movie_title,\n       c.note AS cast_note,\n       k.keyword AS movie_keyword,\n       co.name AS company_name,\n       ct.kind AS company_type\nFROM   aka_name a\nJOIN   cast_info c ON a.person_id = c.person_id\nJOIN   s1 ON c.movie_id = s1.movie_id\nJOIN   movie_keyword mk ON s1.id = mk.movie_id\nJOIN   keyword k ON mk.keyword_id = k.id\nJOIN   movie_companies mc ON s1.id = mc.movie_id\nJOIN   company_name co ON mc.company_id = co.id\nJOIN   company_type ct ON mc.company_type_id = ct.id\nORDER BY s1.production_year DESC, a.name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "13622.sql", "original_sql": "SELECT \n    t.title,\n    a.name AS actor_name,\n    c.kind AS role\nFROM \n    title t\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info ci ON cc.subject_id = ci.person_id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    comp_cast_type c ON ci.person_role_id = c.id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.production_year DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS movie_id,\n       t.title,\n       t.production_year,\n       cc.subject_id\nFROM   title t\nJOIN   complete_cast cc ON t.id = cc.movie_id\nWHERE  t.production_year >= 2000;", "sql2": "SELECT s1.title,\n       a.name AS actor_name,\n       c.kind AS role\nFROM   s1\nJOIN   cast_info ci ON ci.movie_id = s1.movie_id AND ci.person_id = s1.subject_id\nJOIN   aka_name a ON ci.person_id = a.person_id\nJOIN   comp_cast_type c ON ci.person_role_id = c.id\nORDER BY s1.production_year DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "13681.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    ct.kind AS company_type,\n    c.name AS company_name,\n    COUNT(DISTINCT mc.company_id) AS number_of_companies\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    aka_title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name c ON mc.company_id = c.id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nGROUP BY \n    a.name, t.title, t.production_year, c.name, ct.kind\nORDER BY \n    t.production_year DESC, a.name;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'movie_id' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column mc.movie_id\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"movie_id\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"mc\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"mc\" }), name: \"movie_id\" }, Column { relation: Some(Bare { table: \"mc\" }), name: \"company_id\" }, Column { relation: Some(Bare { table: \"mc\" }), name: \"company_type_id\" }, Column { relation: Some(Bare { table: \"mc\" }), name: \"note\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "13685.sql", "original_sql": "SELECT\n    a.name AS actor_name,\n    t.title AS movie_title,\n    m.production_year,\n    c.kind AS company_type,\n    k.keyword AS movie_keyword\nFROM\n    aka_name a\nJOIN\n    cast_info ci ON a.person_id = ci.person_id\nJOIN\n    aka_title t ON ci.movie_id = t.id\nJOIN\n    movie_companies mc ON t.id = mc.movie_id\nJOIN\n    company_name cn ON mc.company_id = cn.id\nJOIN\n    company_type c ON mc.company_type_id = c.id\nJOIN\n    movie_keyword mk ON t.id = mk.movie_id\nJOIN\n    keyword k ON mk.keyword_id = k.id\nJOIN\n    title m ON t.id = m.id\nWHERE\n    m.production_year >= 2000\nORDER BY\n    m.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    m.id AS movie_id,\n    m.title AS movie_title,\n    m.production_year,\n    k.keyword AS movie_keyword\nFROM title m\nJOIN movie_keyword mk ON m.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE m.production_year >= 2000", "sql2": "SELECT\n    a.name AS actor_name,\n    s1.movie_title,\n    s1.production_year,\n    ct.kind AS company_type,\n    s1.movie_keyword\nFROM s1\nJOIN cast_info ci ON s1.movie_id = ci.movie_id\nJOIN aka_name a ON a.person_id = ci.person_id\nJOIN movie_companies mc ON s1.movie_id = mc.movie_id\nJOIN company_type ct ON mc.company_type_id = ct.id", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "13686.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    c.note AS cast_note,\n    n.name AS actor_name,\n    ct.kind AS company_type,\n    mi.info AS movie_info,\n    kw.keyword AS movie_keyword\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    title t ON c.movie_id = t.id\nJOIN \n    name n ON c.person_id = n.imdb_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nJOIN \n    movie_info mi ON t.id = mi.movie_id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword kw ON mk.keyword_id = kw.id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.production_year DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    c.note AS cast_note,\n    n.name AS actor_name,\n    ct.kind AS company_type,\n    mi.info AS movie_info,\n    kw.keyword AS movie_keyword,\n    t.production_year\nFROM aka_name a\nJOIN cast_info c ON a.person_id = c.person_id\nJOIN title t ON c.movie_id = t.id\nJOIN name n ON c.person_id = n.imdb_id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type ct ON mc.company_type_id = ct.id\nJOIN movie_info mi ON t.id = mi.movie_id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword kw ON mk.keyword_id = kw.id\nWHERE t.production_year >= 2000;", "sql2": "SELECT aka_name,\n       movie_title,\n       cast_note,\n       actor_name,\n       company_type,\n       movie_info,\n       movie_keyword\nFROM s1\nORDER BY production_year DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "13719.sql", "original_sql": "SELECT \n    ak.name AS aka_name,\n    t.title AS movie_title,\n    ci.nr_order,\n    ci.note AS cast_note,\n    cn.name AS company_name,\n    mt.kind AS company_type,\n    k.keyword AS movie_keyword\nFROM \n    aka_name ak\nJOIN \n    cast_info ci ON ak.person_id = ci.person_id\nJOIN \n    aka_title t ON ci.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    company_type mt ON mc.company_type_id = mt.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    t.production_year BETWEEN 2000 AND 2023\nORDER BY \n    t.production_year DESC, ak.name;\n", "status": "oom", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 178, in _run_single_node\n    out_tbl = self._run_on_duckdb(node.sql)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 104, in _run_on_duckdb\n    return self.con.execute(sql).arrow()\n           ^^^^^^^^^^^^^^^^^^^^^\nduckdb.duckdb.OutOfMemoryException: Out of Memory Error: Failed to allocate block of 196759552 bytes (bad allocation)\n", "engine_mem_mb": 500000}
{"query_id": "13732.sql", "original_sql": "SELECT \n    a.name AS aka_name, \n    t.title AS movie_title, \n    c.nr_order AS cast_order, \n    r.role AS role_type, \n    m.info AS movie_info \nFROM \n    aka_name a \nJOIN \n    cast_info c ON a.person_id = c.person_id \nJOIN \n    title t ON c.movie_id = t.id \nJOIN \n    role_type r ON c.role_id = r.id \nJOIN \n    movie_info m ON t.id = m.movie_id \nWHERE \n    m.info_type_id = (SELECT id FROM info_type WHERE info = 'summary')\nORDER BY \n    t.production_year DESC, c.nr_order ASC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT mi.movie_id, mi.info FROM movie_info mi JOIN info_type it ON mi.info_type_id = it.id WHERE it.info = 'summary'", "sql2": "SELECT a.name AS aka_name,\n       t.title AS movie_title,\n       c.nr_order AS cast_order,\n       r.role AS role_type,\n       s1.info AS movie_info\nFROM aka_name a\nJOIN cast_info c ON a.person_id = c.person_id\nJOIN title t ON c.movie_id = t.id\nJOIN role_type r ON c.role_id = r.id\nJOIN s1 ON t.id = s1.movie_id\nORDER BY t.production_year DESC, c.nr_order ASC", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "13860.sql", "original_sql": "SELECT \n    t.title AS movie_title,\n    ak.name AS actor_name,\n    p.info AS person_info,\n    kt.keyword AS movie_keyword,\n    c.name AS company_name,\n    r.role AS role_type\nFROM \n    title t\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name c ON mc.company_id = c.id\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info ci ON cc.subject_id = ci.id\nJOIN \n    aka_name ak ON ci.person_id = ak.person_id\nJOIN \n    person_info p ON ak.person_id = p.person_id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword kt ON mk.keyword_id = kt.id\nJOIN \n    role_type r ON ci.role_id = r.id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.production_year DESC, t.title;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS movie_id,\n       t.title AS movie_title,\n       c.name AS company_name,\n       kt.keyword AS movie_keyword\nFROM title t\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_name c ON mc.company_id = c.id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword kt ON mk.keyword_id = kt.id\nWHERE t.production_year >= 2000", "sql2": "SELECT s1.movie_title,\n       ak.name AS actor_name,\n       p.info AS person_info,\n       s1.movie_keyword,\n       s1.company_name,\n       r.role AS role_type\nFROM s1\nJOIN complete_cast cc ON s1.movie_id = cc.movie_id\nJOIN cast_info ci ON cc.subject_id = ci.id\nJOIN aka_name ak ON ci.person_id = ak.person_id\nJOIN person_info p ON ak.person_id = p.person_id\nJOIN role_type r ON ci.role_id = r.id", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "13863.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    c.kind AS company_type,\n    k.keyword AS movie_keyword\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    aka_title t ON ci.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    t.production_year > 2000\nORDER BY \n    t.production_year DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS movie_id,\n       t.title AS movie_title,\n       t.production_year,\n       c.kind AS company_type,\n       k.keyword AS movie_keyword\nFROM title t\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE t.production_year > 2000;", "sql2": "SELECT a.name AS actor_name,\n       s1.movie_title,\n       s1.production_year,\n       s1.company_type,\n       s1.movie_keyword\nFROM s1\nJOIN cast_info ci ON s1.movie_id = ci.movie_id\nJOIN aka_name a ON a.person_id = ci.person_id\nORDER BY s1.production_year DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "13902.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    r.role AS role,\n    c.kind AS company_type\nFROM \n    cast_info ci\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    aka_title t ON ci.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    role_type r ON ci.role_id = r.id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT id AS aka_id, movie_id, title, production_year FROM aka_title WHERE production_year >= 2000;", "sql2": "SELECT a.name AS actor_name, s1.title AS movie_title, s1.production_year, r.role AS role, c.kind AS company_type FROM cast_info ci JOIN s1 ON ci.movie_id = s1.movie_id JOIN aka_name a ON ci.person_id = a.person_id JOIN movie_companies mc ON mc.movie_id = s1.aka_id JOIN company_type c ON mc.company_type_id = c.id JOIN role_type r ON ci.role_id = r.id ORDER BY s1.production_year DESC, a.name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "14064.sql", "original_sql": "SELECT t.title, a.name, p.info\nFROM title AS t\nJOIN movie_companies AS mc ON t.id = mc.movie_id\nJOIN company_name AS c ON mc.company_id = c.id\nJOIN cast_info AS ci ON t.id = ci.movie_id\nJOIN aka_name AS a ON ci.person_id = a.person_id\nJOIN person_info AS p ON a.person_id = p.person_id\nWHERE t.production_year >= 2000\n  AND c.country_code = 'USA'\nORDER BY t.production_year DESC, t.title;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS movie_id,\n       t.title,\n       t.production_year\nFROM title AS t\nJOIN movie_companies AS mc ON t.id = mc.movie_id\nJOIN company_name AS c ON mc.company_id = c.id\nWHERE t.production_year >= 2000\n  AND c.country_code = 'USA'", "sql2": "SELECT s1.title,\n       a.name,\n       p.info\nFROM s1\nJOIN cast_info AS ci ON s1.movie_id = ci.movie_id\nJOIN aka_name AS a ON ci.person_id = a.person_id\nJOIN person_info AS p ON a.person_id = p.person_id\nORDER BY s1.production_year DESC,\n         s1.title", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "14113.sql", "original_sql": "SELECT \n    a.name AS actor_name, \n    t.title AS movie_title, \n    t.production_year, \n    c.kind AS company_type \nFROM \n    aka_name a \nJOIN \n    cast_info ci ON a.person_id = ci.person_id \nJOIN \n    aka_title t ON ci.movie_id = t.id \nJOIN \n    movie_companies mc ON t.id = mc.movie_id \nJOIN \n    company_type c ON mc.company_type_id = c.id \nWHERE \n    t.production_year > 2000 \nORDER BY \n    t.production_year DESC, \n    a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT a.name AS actor_name,\n       t.title AS movie_title,\n       t.production_year,\n       c.kind AS company_type\nFROM   aka_name a\nJOIN   cast_info ci ON a.person_id = ci.person_id\nJOIN   aka_title t ON ci.movie_id = t.id\nJOIN   movie_companies mc ON t.id = mc.movie_id\nJOIN   company_type c ON mc.company_type_id = c.id\nWHERE  t.production_year > 2000;", "sql2": "SELECT actor_name,\n       movie_title,\n       production_year,\n       company_type\nFROM   s1\nORDER BY production_year DESC,\n         actor_name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "14210.sql", "original_sql": "SELECT\n    ak.name AS aka_name,\n    t.title AS movie_title,\n    p.name AS person_name,\n    r.role AS person_role,\n    c.note AS cast_note,\n    comp.name AS company_name,\n    m.info AS movie_info\nFROM\n    aka_name ak\nJOIN\n    cast_info c ON ak.person_id = c.person_id\nJOIN\n    title t ON c.movie_id = t.id\nJOIN\n    name p ON c.person_id = p.imdb_id\nJOIN\n    role_type r ON c.role_id = r.id\nJOIN\n    movie_companies mc ON t.id = mc.movie_id\nJOIN\n    company_name comp ON mc.company_id = comp.id\nJOIN\n    movie_info m ON t.id = m.movie_id\nWHERE\n    t.production_year >= 2000\nORDER BY\n    t.production_year DESC, ak.name;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 115, in _run_on_datafusion\n    return df.to_arrow_table()\n           ^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/dataframe.py\", line 1164, in to_arrow_table\n    return self.df.to_arrow_table()\n           ^^^^^^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Shared(ResourcesExhausted(\"Additional allocation failed with top memory consumers (across reservations) as:\\n  ExternalSorter[175]#2064(can spill: true) consumed 2.7 GB, peak 2.7 GB,\\n  ExternalSorter[99]#1580(can spill: true) consumed 2.6 GB, peak 2.6 GB,\\n  ExternalSorter[204]#2407(can spill: true) consumed 2.5 GB, peak 2.5 GB,\\n  ExternalSorter[81]#1526(can spill: true) consumed 2.5 GB, peak 2.5 GB,\\n  ExternalSorter[34]#1385(can spill: true) consumed 2.4 GB, peak 2.4 GB.\\nError: Failed to allocate additional 4.4 MB for RepartitionExec[0] with 470.5 MB already allocated for this reservation - 1834.1 KB remain available for the total pool\"))\n", "engine_mem_mb": 500000}
{"query_id": "14248.sql", "original_sql": "SELECT \n    a.name AS aka_name, \n    t.title AS movie_title, \n    c.note AS cast_note, \n    k.keyword AS movie_keyword, \n    m.info AS movie_info, \n    n.name AS person_name, \n    r.role AS role_type\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    title t ON c.movie_id = t.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    movie_info m ON t.id = m.movie_id\nJOIN \n    name n ON c.person_id = n.imdb_id\nJOIN \n    role_type r ON c.role_id = r.id\nORDER BY \n    t.production_year DESC, \n    a.name;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "14263.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    p.name AS person_name,\n    c.kind AS company_type,\n    m.info AS movie_info,\n    k.keyword AS movie_keyword\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_info m ON t.id = m.movie_id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    name p ON ci.person_id = p.imdb_id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.production_year DESC, a.name;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "14273.sql", "original_sql": "SELECT \n    a.name AS aka_name, \n    t.title AS movie_title, \n    m.name AS company_name, \n    p.info AS person_info\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    aka_title t ON c.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name m ON mc.company_id = m.id\nJOIN \n    person_info p ON a.person_id = p.person_id\nWHERE \n    t.production_year >= 2000\n    AND m.country_code = 'USA'\nORDER BY \n    t.production_year DESC, \n    a.name;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT DISTINCT c.person_id,\n                c.movie_id,\n                m.name AS company_name,\n                t.production_year\nFROM cast_info c\nJOIN aka_title t ON c.movie_id = t.movie_id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_name m ON mc.company_id = m.id\nWHERE t.production_year >= 2000\n  AND m.country_code = 'USA'", "sql2": "SELECT \n    a.name AS aka_name,\n    at.title AS movie_title,\n    s1.company_name,\n    p.info AS person_info\nFROM s1\nJOIN aka_name a ON a.person_id = s1.person_id\nJOIN aka_title at ON at.movie_id = s1.movie_id\nJOIN person_info p ON p.person_id = s1.person_id\nORDER BY s1.production_year DESC,\n         a.name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "14467.sql", "original_sql": "SELECT \n    t.title AS movie_title,\n    a.name AS actor_name,\n    r.role AS role_type,\n    c.kind AS comp_cast_type,\n    m.info AS movie_info\nFROM \n    title t\nJOIN \n    movie_info m ON t.id = m.movie_id\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info ci ON cc.subject_id = ci.person_id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    role_type r ON ci.role_id = r.id\nJOIN \n    comp_cast_type c ON ci.person_role_id = c.id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.title, a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS movie_id,\n       t.title AS movie_title,\n       m.info AS movie_info\nFROM title t\nJOIN movie_info m ON t.id = m.movie_id\nWHERE t.production_year >= 2000;", "sql2": "SELECT s1.movie_title,\n       a.name AS actor_name,\n       r.role AS role_type,\n       c.kind AS comp_cast_type,\n       s1.movie_info\nFROM s1\nJOIN complete_cast cc ON s1.movie_id = cc.movie_id\nJOIN cast_info ci ON cc.subject_id = ci.person_id\nJOIN aka_name a ON ci.person_id = a.person_id\nJOIN role_type r ON ci.role_id = r.id\nJOIN comp_cast_type c ON ci.person_role_id = c.id\nORDER BY s1.movie_title, a.name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "14588.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.kind AS company_kind,\n    i.info AS movie_info\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    aka_title t ON ci.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_info mi ON t.id = mi.movie_id\nJOIN \n    info_type i ON mi.info_type_id = i.id\nWHERE \n    c.kind LIKE '%Production%'\n    AND t.production_year > 2000\nORDER BY \n    t.production_year DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.kind AS company_kind,\n    i.info AS movie_info,\n    t.production_year\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    aka_title t ON ci.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_info mi ON t.id = mi.movie_id\nJOIN \n    info_type i ON mi.info_type_id = i.id\nWHERE \n    c.kind LIKE '%Production%'\n    AND t.production_year > 2000;", "sql2": "SELECT actor_name, movie_title, company_kind, movie_info\nFROM s1\nORDER BY production_year DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "14603.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    c.note AS cast_note,\n    co.name AS company_name,\n    k.keyword AS movie_keyword,\n    r.role AS role_name\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    aka_title t ON c.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name co ON mc.company_id = co.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    role_type r ON c.role_id = r.id\nWHERE \n    t.production_year > 2000\nORDER BY \n    t.production_year DESC, \n    a.name;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 115, in _run_on_datafusion\n    return df.to_arrow_table()\n           ^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/dataframe.py\", line 1164, in to_arrow_table\n    return self.df.to_arrow_table()\n           ^^^^^^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: ResourcesExhausted(\"Additional allocation failed with top memory consumers (across reservations) as:\\n  ExternalSorter[56]#427(can spill: true) consumed 1732.9 MB, peak 1732.9 MB,\\n  ExternalSorter[31]#352(can spill: true) consumed 1702.7 MB, peak 1702.7 MB,\\n  ExternalSorter[187]#820(can spill: true) consumed 1658.4 MB, peak 1658.4 MB,\\n  ExternalSorter[210]#889(can spill: true) consumed 1649.0 MB, peak 1649.0 MB,\\n  ExternalSorter[148]#703(can spill: true) consumed 1615.5 MB, peak 1615.5 MB.\\nError: Failed to allocate additional 1245.8 KB for ExternalSorterMerge[125] with 120.4 MB already allocated for this reservation - 515.5 KB remain available for the total pool\")\n", "engine_mem_mb": 500000}
{"query_id": "14827.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    c.nr_order AS cast_order,\n    n.name AS actor_name,\n    p.info AS actor_info\nFROM \n    aka_title t\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info c ON cc.subject_id = c.person_id\nJOIN \n    aka_name a ON c.person_id = a.person_id\nJOIN \n    name n ON n.id = a.person_id\nLEFT JOIN \n    person_info p ON n.id = p.person_id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.production_year DESC, \n    c.nr_order;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    c.nr_order AS cast_order,\n    n.name AS actor_name,\n    n.id AS actor_id,\n    t.production_year\nFROM aka_title t\nJOIN complete_cast cc ON t.id = cc.movie_id\nJOIN cast_info c ON cc.subject_id = c.person_id\nJOIN aka_name a ON c.person_id = a.person_id\nJOIN name n ON n.id = a.person_id\nWHERE t.production_year >= 2000;", "sql2": "SELECT \n    s1.aka_name,\n    s1.movie_title,\n    s1.cast_order,\n    s1.actor_name,\n    p.info AS actor_info\nFROM s1\nLEFT JOIN person_info p ON s1.actor_id = p.person_id\nORDER BY s1.production_year DESC, s1.cast_order;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "14830.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    c.note AS cast_note,\n    r.role AS role_type,\n    ci.name AS company_name,\n    mn.info AS movie_info\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    title t ON c.movie_id = t.id\nJOIN \n    role_type r ON c.role_id = r.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name ci ON mc.company_id = ci.id\nJOIN \n    movie_info mn ON t.id = mn.movie_id\nWHERE \n    mn.info_type_id = (SELECT id FROM info_type WHERE info = 'Genre')\nORDER BY \n    t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT mi.movie_id,\n       t.title,\n       t.production_year,\n       mi.info AS genre_info\nFROM movie_info mi\nJOIN title t ON mi.movie_id = t.id\nWHERE mi.info_type_id = (SELECT id FROM info_type WHERE info = 'Genre')", "sql2": "SELECT \n    a.name AS aka_name,\n    s1.title AS movie_title,\n    c.note AS cast_note,\n    r.role AS role_type,\n    ci.name AS company_name,\n    s1.genre_info AS movie_info\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    role_type r ON c.role_id = r.id\nJOIN \n    movie_companies mc ON c.movie_id = mc.movie_id\nJOIN \n    company_name ci ON mc.company_id = ci.id\nJOIN \n    s1 ON c.movie_id = s1.movie_id\nORDER BY \n    s1.production_year DESC, a.name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "14855.sql", "original_sql": "\nSELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    c.nr_order AS cast_order,\n    k.keyword AS movie_keyword,\n    ct.kind AS company_type\nFROM \n    cast_info c\nJOIN \n    aka_name a ON c.person_id = a.person_id\nJOIN \n    aka_title t ON c.movie_id = t.movie_id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nLEFT JOIN \n    movie_companies mc ON t.id = mc.movie_id\nLEFT JOIN \n    company_type ct ON mc.company_type_id = ct.id\nGROUP BY \n    a.name, \n    t.title, \n    t.production_year, \n    c.nr_order, \n    k.keyword, \n    ct.kind\nORDER BY \n    t.production_year DESC, \n    c.nr_order;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    c.nr_order AS cast_order,\n    k.keyword AS movie_keyword,\n    t.id AS movie_id\nFROM cast_info c\nJOIN aka_name a ON c.person_id = a.person_id\nJOIN aka_title t ON c.movie_id = t.movie_id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nGROUP BY a.name, t.title, t.production_year, c.nr_order, k.keyword, t.id;", "sql2": "SELECT \n    s1.actor_name,\n    s1.movie_title,\n    s1.production_year,\n    s1.cast_order,\n    s1.movie_keyword,\n    ct.kind AS company_type\nFROM s1\nLEFT JOIN movie_companies mc ON s1.movie_id = mc.movie_id\nLEFT JOIN company_type ct ON mc.company_type_id = ct.id\nGROUP BY s1.actor_name, s1.movie_title, s1.production_year, s1.cast_order, s1.movie_keyword, ct.kind\nORDER BY s1.production_year DESC, s1.cast_order;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "14990.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    c.nr_order AS cast_order,\n    p.gender AS person_gender,\n    ct.kind AS company_type,\n    ki.keyword AS movie_keyword\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    title t ON c.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword ki ON mk.keyword_id = ki.id\nJOIN \n    name p ON a.person_id = p.imdb_id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.production_year DESC, \n    c.nr_order ASC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS movie_id,\n       t.title AS movie_title,\n       t.production_year,\n       ct.kind AS company_type,\n       ki.keyword AS movie_keyword\nFROM title t\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type ct ON mc.company_type_id = ct.id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword ki ON mk.keyword_id = ki.id\nWHERE t.production_year >= 2000", "sql2": "SELECT a.name AS aka_name,\n       s1.movie_title,\n       c.nr_order AS cast_order,\n       p.gender AS person_gender,\n       s1.company_type,\n       s1.movie_keyword\nFROM s1\nJOIN cast_info c ON s1.movie_id = c.movie_id\nJOIN aka_name a ON a.person_id = c.person_id\nJOIN name p ON p.id = a.person_id\nORDER BY s1.production_year DESC, c.nr_order ASC", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "15084.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    c.note AS role_note,\n    co.name AS company_name\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    aka_title t ON c.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name co ON mc.company_id = co.id\nWHERE \n    t.production_year > 2000\nORDER BY \n    t.title;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT a.person_id,\n       a.name AS aka_name,\n       c.note AS role_note,\n       t.id AS movie_id,\n       t.title AS movie_title\nFROM   aka_name a\nJOIN   cast_info c ON a.person_id = c.person_id\nJOIN   aka_title t ON c.movie_id = t.movie_id\nWHERE  t.production_year > 2000", "sql2": "SELECT s1.aka_name,\n       s1.movie_title,\n       s1.role_note,\n       co.name AS company_name\nFROM   s1\nJOIN   movie_companies mc ON s1.movie_id = mc.movie_id\nJOIN   company_name co ON mc.company_id = co.id\nORDER BY s1.movie_title;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "15157.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    p.info AS person_info,\n    r.role AS person_role\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    title t ON c.movie_id = t.id\nJOIN \n    role_type r ON c.role_id = r.id\nJOIN \n    person_info p ON a.person_id = p.person_id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.production_year DESC\nLIMIT 10;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT c.person_id,\n       t.title,\n       t.production_year,\n       r.role AS person_role\nFROM cast_info AS c\nJOIN title AS t ON c.movie_id = t.id\nJOIN role_type AS r ON c.role_id = r.id\nWHERE t.production_year >= 2000\nORDER BY t.production_year DESC\nLIMIT 10;", "sql2": "SELECT a.name AS aka_name,\n       s1.title AS movie_title,\n       p.info AS person_info,\n       s1.person_role\nFROM s1\nJOIN aka_name AS a ON a.person_id = s1.person_id\nJOIN person_info AS p ON p.person_id = s1.person_id;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "15185.sql", "original_sql": "SELECT \n    t.title AS movie_title, \n    a.name AS actor_name, \n    c.kind AS company_type\nFROM \n    title t\nJOIN \n    cast_info ci ON t.id = ci.movie_id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nWHERE \n    t.production_year > 2000\nORDER BY \n    t.production_year DESC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT t.id AS movie_id,\n       t.title AS movie_title,\n       t.production_year,\n       c.kind AS company_type\nFROM title t\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nWHERE t.production_year > 2000;", "sql2": "SELECT s1.movie_title,\n       a.name AS actor_name,\n       s1.company_type\nFROM s1\nJOIN cast_info ci ON s1.movie_id = ci.movie_id\nJOIN aka_name a ON ci.person_id = a.person_id\nORDER BY s1.production_year DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "15220.sql", "original_sql": "SELECT \n    t.title, \n    a.name AS actor_name,\n    c.kind AS company_type\nFROM \n    title t\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info ci ON cc.subject_id = ci.id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.title;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS title_id,\n       t.title,\n       c.kind AS company_type\nFROM title t\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nWHERE t.production_year >= 2000;", "sql2": "SELECT s1.title,\n       a.name AS actor_name,\n       s1.company_type\nFROM s1\nJOIN complete_cast cc ON s1.title_id = cc.movie_id\nJOIN cast_info ci ON cc.subject_id = ci.id\nJOIN aka_name a ON ci.person_id = a.person_id\nORDER BY s1.title;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "15278.sql", "original_sql": "SELECT \n    t.title,\n    a.name AS actor_name,\n    c.role_id,\n    m.info AS movie_info,\n    k.keyword\nFROM \n    title t\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    cast_info c ON t.id = c.movie_id\nJOIN \n    aka_name a ON c.person_id = a.person_id\nJOIN \n    movie_info m ON t.id = m.movie_id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    t.production_year = 2023;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "15286.sql", "original_sql": "SELECT a.name AS actor_name, t.title AS movie_title, c.kind AS company_type\nFROM aka_name a\nJOIN cast_info ci ON a.person_id = ci.person_id\nJOIN aka_title t ON ci.movie_id = t.id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nWHERE t.production_year = 2020\nORDER BY a.name, t.title;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'movie_id' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column ci.movie_id\", span: None }, DiagnosticNote { message: \"possible column ci.role_id\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"movie_id\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"person_id\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"movie_id\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"person_role_id\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"note\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"nr_order\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"role_id\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "15287.sql", "original_sql": "SELECT \n    t.title,\n    a.name,\n    c.person_role_id,\n    ci.kind\nFROM \n    title t\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    cast_info c ON t.id = c.movie_id\nJOIN \n    aka_name a ON c.person_id = a.person_id\nJOIN \n    comp_cast_type ci ON c.person_role_id = ci.id\nWHERE \n    t.production_year = 2020\nORDER BY \n    t.title;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT id, title FROM title WHERE production_year = 2020;", "sql2": "SELECT t.title, a.name, c.person_role_id, ci.kind\nFROM s1 AS t\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN cast_info c ON t.id = c.movie_id\nJOIN aka_name a ON c.person_id = a.person_id\nJOIN comp_cast_type ci ON c.person_role_id = ci.id\nORDER BY t.title;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "15394.sql", "original_sql": "SELECT a.name AS actor_name, t.title AS movie_title, c.kind AS company_type\nFROM aka_name a\nJOIN cast_info ci ON a.person_id = ci.person_id\nJOIN aka_title t ON ci.movie_id = t.movie_id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nWHERE t.production_year >= 2000\nORDER BY t.production_year DESC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT t.id AS movie_id,\n       t.title AS movie_title,\n       t.production_year,\n       c.kind AS company_type\nFROM aka_title AS t\nJOIN movie_companies AS mc ON t.id = mc.movie_id\nJOIN company_type AS c ON mc.company_type_id = c.id\nWHERE t.production_year >= 2000;", "sql2": "SELECT a.name AS actor_name,\n       s1.movie_title,\n       s1.company_type\nFROM aka_name AS a\nJOIN cast_info AS ci ON a.person_id = ci.person_id\nJOIN s1 ON ci.movie_id = s1.movie_id\nORDER BY s1.production_year DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "15545.sql", "original_sql": "SELECT \n    t.title,\n    a.name AS actor_name,\n    c.kind AS company_type\nFROM \n    aka_title t\nJOIN \n    cast_info ci ON t.id = ci.movie_id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nWHERE \n    t.production_year = 2023\nORDER BY \n    t.title;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS movie_id,\n       t.title,\n       c.kind AS company_type\nFROM   aka_title t\nJOIN   movie_companies mc ON t.id = mc.movie_id\nJOIN   company_type c ON mc.company_type_id = c.id\nWHERE  t.production_year = 2023;", "sql2": "SELECT s1.title,\n       a.name AS actor_name,\n       s1.company_type\nFROM   s1\nJOIN   cast_info ci ON s1.movie_id = ci.movie_id\nJOIN   aka_name a ON ci.person_id = a.person_id\nORDER BY s1.title;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "15597.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    c.note AS cast_note,\n    co.name AS company_name,\n    k.keyword AS movie_keyword\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    aka_title t ON c.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name co ON mc.company_id = co.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    t.production_year > 2000\nORDER BY \n    t.production_year DESC;\n", "status": "killed", "exitcode": -11, "signal": 11, "engine_mem_mb": 500000}
{"query_id": "15633.sql", "original_sql": "SELECT \n    t.title, \n    a.name AS actor_name, \n    c.kind AS role \nFROM \n    title t \nJOIN \n    movie_companies mc ON t.id = mc.movie_id \nJOIN \n    cast_info ci ON mc.movie_id = ci.movie_id \nJOIN \n    aka_name a ON ci.person_id = a.person_id \nJOIN \n    comp_cast_type c ON ci.person_role_id = c.id \nWHERE \n    t.production_year = 2020 \nORDER BY \n    t.title;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT DISTINCT t.id AS movie_id, t.title FROM title t JOIN movie_companies mc ON t.id = mc.movie_id WHERE t.production_year = 2020;", "sql2": "SELECT s1.title, a.name AS actor_name, c.kind AS role FROM s1 JOIN cast_info ci ON s1.movie_id = ci.movie_id JOIN aka_name a ON ci.person_id = a.person_id JOIN comp_cast_type c ON ci.person_role_id = c.id ORDER BY s1.title;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "15782.sql", "original_sql": "SELECT \n    ak.name AS aka_name,\n    t.title AS movie_title,\n    p.name AS person_name,\n    c.kind AS company_type\nFROM \n    aka_name ak\nJOIN \n    cast_info ci ON ak.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    name p ON ak.person_id = p.imdb_id\nWHERE \n    t.production_year > 2000\nORDER BY \n    t.production_year DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    ci.person_id,\n    ci.movie_id,\n    c.kind AS company_type,\n    t.production_year,\n    t.title AS movie_title\nFROM cast_info ci\nJOIN title t ON ci.movie_id = t.id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nWHERE t.production_year > 2000;", "sql2": "SELECT \n    ak.name AS aka_name,\n    s1.movie_title,\n    p.name AS person_name,\n    s1.company_type\nFROM s1\nJOIN aka_name ak ON ak.person_id = s1.person_id\nJOIN name p ON ak.person_id = p.imdb_id\nORDER BY s1.production_year DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "16060.sql", "original_sql": "SELECT a.name AS actor_name, t.title AS movie_title, c.kind AS company_type\nFROM aka_name a\nJOIN cast_info ci ON a.person_id = ci.person_id\nJOIN aka_title t ON ci.movie_id = t.id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nWHERE t.production_year >= 2000\nORDER BY t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT t.id AS movie_id,\n       t.title AS movie_title,\n       c.kind AS company_type,\n       t.production_year\nFROM aka_title t\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nWHERE t.production_year >= 2000;", "sql2": "SELECT a.name AS actor_name,\n       s1.movie_title,\n       s1.company_type\nFROM s1\nJOIN cast_info ci ON ci.movie_id = s1.movie_id\nJOIN aka_name a ON a.person_id = ci.person_id\nORDER BY s1.production_year DESC, a.name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "16065.sql", "original_sql": "SELECT \n    t.title,\n    a.name AS actor_name,\n    c.kind AS company_type,\n    k.keyword\nFROM \n    title t\nJOIN \n    cast_info ci ON t.id = ci.movie_id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    t.production_year = 2022\nORDER BY \n    t.title;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS title_id,\n       t.title,\n       a.name AS actor_name\nFROM   title t\nJOIN   cast_info ci ON t.id = ci.movie_id\nJOIN   aka_name a   ON ci.person_id = a.person_id\nWHERE  t.production_year = 2022;", "sql2": "SELECT s1.title,\n       s1.actor_name,\n       c.kind AS company_type,\n       k.keyword\nFROM   s1\nJOIN   movie_companies mc ON s1.title_id = mc.movie_id\nJOIN   company_type c     ON mc.company_type_id = c.id\nJOIN   movie_keyword mk   ON s1.title_id = mk.movie_id\nJOIN   keyword k          ON mk.keyword_id = k.id\nORDER BY s1.title;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "16306.sql", "original_sql": "SELECT \n    t.title, \n    a.name, \n    c.note, \n    k.keyword \nFROM \n    title t \nJOIN \n    movie_keyword mk ON t.id = mk.movie_id \nJOIN \n    keyword k ON mk.keyword_id = k.id \nJOIN \n    complete_cast cc ON t.id = cc.movie_id \nJOIN \n    aka_name a ON cc.subject_id = a.person_id \nJOIN \n    cast_info c ON a.id = c.person_id AND cc.movie_id = c.movie_id \nWHERE \n    t.production_year > 2000 \nORDER BY \n    t.title;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "16374.sql", "original_sql": "SELECT \n    t.title,\n    a.name AS actor_name,\n    c.kind AS company_type\nFROM \n    title t\nJOIN \n    cast_info ci ON t.id = ci.movie_id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nWHERE \n    t.production_year > 2000\nORDER BY \n    t.production_year DESC;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "16476.sql", "original_sql": "SELECT \n    t.title,\n    p.name AS person_name,\n    r.role\nFROM \n    title t\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name c ON mc.company_id = c.id\nJOIN \n    cast_info ci ON t.id = ci.movie_id\nJOIN \n    aka_name p ON ci.person_id = p.person_id\nJOIN \n    role_type r ON ci.role_id = r.id\nWHERE \n    c.country_code = 'USA'\nORDER BY \n    t.production_year DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT DISTINCT t.id AS movie_id,\n                t.title,\n                t.production_year\nFROM title t\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_name c ON mc.company_id = c.id\nWHERE c.country_code = 'USA'", "sql2": "SELECT s1.title,\n       p.name AS person_name,\n       r.role\nFROM s1\nJOIN cast_info ci ON s1.movie_id = ci.movie_id\nJOIN aka_name p ON ci.person_id = p.person_id\nJOIN role_type r ON ci.role_id = r.id\nORDER BY s1.production_year DESC", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "1659.sql", "original_sql": "WITH ranked_movies AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        ROW_NUMBER() OVER (PARTITION BY t.production_year ORDER BY t.id) AS rank\n    FROM \n        aka_title t\n    WHERE \n        t.production_year IS NOT NULL\n),\nactor_info AS (\n    SELECT \n        a.person_id,\n        a.name,\n        COUNT(DISTINCT ci.movie_id) AS movie_count,\n        STRING_AGG(DISTINCT t.title, ', ') AS movie_titles\n    FROM \n        aka_name a\n    LEFT JOIN \n        cast_info ci ON a.person_id = ci.person_id\n    LEFT JOIN \n        ranked_movies t ON ci.movie_id = t.movie_id\n    GROUP BY \n        a.person_id, a.name\n),\ncompany_stats AS (\n    SELECT \n        mc.movie_id,\n        COUNT(DISTINCT cn.id) AS company_count,\n        STRING_AGG(DISTINCT cn.name, ', ') AS company_names\n    FROM \n        movie_companies mc\n    JOIN \n        company_name cn ON mc.company_id = cn.id\n    GROUP BY \n        mc.movie_id\n),\nmovie_details AS (\n    SELECT \n        rm.movie_id,\n        rm.title,\n        rm.production_year,\n        ai.movie_count,\n        ai.movie_titles,\n        cs.company_count,\n        cs.company_names\n    FROM \n        ranked_movies rm\n    LEFT JOIN \n        actor_info ai ON rm.movie_id = ai.movie_count\n    LEFT JOIN \n        company_stats cs ON rm.movie_id = cs.movie_id\n)\nSELECT \n    md.title,\n    md.production_year,\n    COALESCE(md.movie_count, 0) AS actor_count,\n    COALESCE(md.company_count, 0) AS company_count,\n    CASE \n        WHEN md.movie_count IS NULL THEN 'No Actors'\n        ELSE md.movie_titles \n    END AS actor_titles,\n    CASE \n        WHEN md.company_count IS NULL THEN 'No Companies'\n        ELSE md.company_names \n    END AS listed_companies\nFROM \n    movie_details md\nORDER BY \n    md.production_year DESC, \n    md.title ASC;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "16610.sql", "original_sql": "SELECT \n    t.title, \n    a.name AS actor_name, \n    c.kind AS company_type \nFROM \n    title t \nJOIN \n    movie_companies mc ON t.id = mc.movie_id \nJOIN \n    company_type c ON mc.company_type_id = c.id \nJOIN \n    cast_info ci ON t.id = ci.movie_id \nJOIN \n    aka_name a ON ci.person_id = a.person_id \nWHERE \n    t.production_year >= 2020 \nORDER BY \n    t.production_year DESC, \n    a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS title_id,\n       t.title,\n       t.production_year,\n       c.kind AS company_type\nFROM title t\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nWHERE t.production_year >= 2020;", "sql2": "SELECT s1.title,\n       a.name AS actor_name,\n       s1.company_type\nFROM s1\nJOIN cast_info ci ON s1.title_id = ci.movie_id\nJOIN aka_name a ON ci.person_id = a.person_id\nORDER BY s1.production_year DESC, a.name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "16675.sql", "original_sql": "SELECT \n    t.title,\n    a.name AS actor_name,\n    c.kind AS company_type\nFROM \n    title t\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    cast_info ci ON t.id = ci.movie_id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.production_year DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id,\n       t.title,\n       t.production_year,\n       c.kind AS company_type\nFROM   title t\nJOIN   movie_companies mc ON t.id = mc.movie_id\nJOIN   company_type c ON mc.company_type_id = c.id\nWHERE  t.production_year >= 2000;", "sql2": "SELECT s1.title,\n       a.name AS actor_name,\n       s1.company_type\nFROM   s1\nJOIN   cast_info ci ON s1.id = ci.movie_id\nJOIN   aka_name a ON ci.person_id = a.person_id\nORDER BY s1.production_year DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "16710.sql", "original_sql": "SELECT \n    t.title AS movie_title,\n    a.name AS actor_name,\n    c.role_id\nFROM \n    title t\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    cast_info c ON t.id = c.movie_id\nJOIN \n    aka_name a ON c.person_id = a.person_id\nWHERE \n    t.production_year = 2023\nORDER BY \n    t.title;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT id, title FROM title WHERE production_year = 2023", "sql2": "SELECT s1.title AS movie_title,\n       a.name AS actor_name,\n       c.role_id\nFROM s1\nJOIN movie_companies mc ON s1.id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN cast_info c ON s1.id = c.movie_id\nJOIN aka_name a ON c.person_id = a.person_id\nORDER BY s1.title;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "16766.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    c.note AS cast_note,\n    k.keyword AS movie_keyword\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    aka_title t ON c.movie_id = t.movie_id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    t.production_year > 2000\nORDER BY \n    t.production_year DESC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 231, in run\n    self._register_downstream_aliases(nid, tbl, id_to_node, adj)\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 169, in _register_downstream_aliases\n    self._register_input_duckdb(alias, tbl)\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 81, in _register_input_duckdb\n    self.con.register(name, obj)\nduckdb.duckdb.InvalidInputException: Invalid Input Error: Provided table/dataframe must have at least one column\n", "engine_mem_mb": 500000}
{"query_id": "16851.sql", "original_sql": "SELECT \n    t.title, \n    a.name AS actor_name, \n    p.info AS actor_info \nFROM \n    title t\nJOIN \n    cast_info c ON t.id = c.movie_id\nJOIN \n    aka_name a ON c.person_id = a.person_id\nJOIN \n    person_info p ON a.person_id = p.person_id\nWHERE \n    t.production_year = 2023\nAND \n    p.info_type_id = (SELECT id FROM info_type WHERE info = 'Biography')\nORDER BY \n    t.title, \n    a.name;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT pi.person_id, pi.info\nFROM person_info pi\nJOIN info_type it ON pi.info_type_id = it.id\nWHERE it.info = 'Biography';", "sql2": "SELECT t.title,\n       a.name AS actor_name,\n       s1.info AS actor_info\nFROM title t\nJOIN cast_info c ON t.id = c.movie_id\nJOIN aka_name a ON c.person_id = a.person_id\nJOIN s1 ON a.person_id = s1.person_id\nWHERE t.production_year = 2023\nORDER BY t.title, a.name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "16893.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    ci.note AS cast_note,\n    c.name AS company_name,\n    k.keyword AS movie_keyword\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    aka_title t ON ci.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name c ON mc.company_id = c.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    t.production_year > 2000\nORDER BY \n    t.production_year DESC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT\n    a.name AS aka_name,\n    t.title AS movie_title,\n    ci.note AS cast_note,\n    t.id AS aka_title_id,\n    t.production_year\nFROM aka_name AS a\nJOIN cast_info AS ci ON a.person_id = ci.person_id\nJOIN aka_title AS t ON ci.movie_id = t.movie_id\nWHERE t.production_year > 2000", "sql2": "SELECT\n    s1.aka_name,\n    s1.movie_title,\n    s1.cast_note,\n    c.name AS company_name,\n    k.keyword AS movie_keyword\nFROM s1\nJOIN movie_companies AS mc ON s1.aka_title_id = mc.movie_id\nJOIN company_name AS c ON mc.company_id = c.id\nJOIN movie_keyword AS mk ON s1.aka_title_id = mk.movie_id\nJOIN keyword AS k ON mk.keyword_id = k.id\nORDER BY s1.production_year DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "17154.sql", "original_sql": "SELECT \n    t.title, \n    a.name AS actor_name, \n    p.info AS actor_info\nFROM \n    title t\nJOIN \n    movie_info mi ON t.id = mi.movie_id\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info ci ON cc.subject_id = ci.id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    person_info p ON a.person_id = p.person_id\nWHERE \n    mi.info_type_id = (SELECT id FROM info_type WHERE info = 'summary')\n    AND t.production_year > 2000\nORDER BY \n    t.production_year DESC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'title_id' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column cc.movie_id\", span: None }, DiagnosticNote { message: \"possible column cc.status_id\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"title_id\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"cc\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"cc\" }), name: \"movie_id\" }, Column { relation: Some(Bare { table: \"cc\" }), name: \"subject_id\" }, Column { relation: Some(Bare { table: \"cc\" }), name: \"status_id\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "17233.sql", "original_sql": "SELECT \n    t.title, \n    a.name AS actor_name, \n    r.role\nFROM \n    title t\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name c ON mc.company_id = c.id\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info ci ON cc.subject_id = ci.person_id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    role_type r ON ci.role_id = r.id\nWHERE \n    t.production_year > 2000\nORDER BY \n    t.title;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT id AS title_id, title FROM title WHERE production_year > 2000", "sql2": "SELECT s1.title,\n       a.name AS actor_name,\n       r.role\nFROM   s1\nJOIN   movie_companies mc ON s1.title_id = mc.movie_id\nJOIN   company_name c ON mc.company_id = c.id\nJOIN   complete_cast cc ON s1.title_id = cc.movie_id\nJOIN   cast_info ci ON cc.subject_id = ci.person_id\nJOIN   aka_name a ON ci.person_id = a.person_id\nJOIN   role_type r ON ci.role_id = r.id\nORDER BY s1.title;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "17394.sql", "original_sql": "SELECT \n    t.title AS movie_title,\n    ak.name AS actor_name,\n    ci.nr_order AS cast_order\nFROM \n    title t\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info ci ON cc.subject_id = ci.id\nJOIN \n    aka_name ak ON ci.person_id = ak.person_id\nWHERE \n    t.production_year = 2020\nORDER BY \n    t.title, ci.nr_order;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT id AS title_id,\n       title AS movie_title\nFROM title\nWHERE production_year = 2020;", "sql2": "SELECT \n    s1.movie_title,\n    ak.name AS actor_name,\n    ci.nr_order AS cast_order\nFROM s1\nJOIN movie_companies mc ON s1.title_id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN complete_cast cc ON s1.title_id = cc.movie_id\nJOIN cast_info ci ON cc.subject_id = ci.id\nJOIN aka_name ak ON ci.person_id = ak.person_id\nORDER BY s1.movie_title, ci.nr_order;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "17632.sql", "original_sql": "SELECT \n    t.title,\n    a.name AS actor_name,\n    c.kind AS company_type\nFROM \n    title AS t\nJOIN \n    cast_info AS ci ON t.id = ci.movie_id\nJOIN \n    aka_name AS a ON ci.person_id = a.person_id\nJOIN \n    movie_companies AS mc ON t.id = mc.movie_id\nJOIN \n    company_type AS c ON mc.company_type_id = c.id\nWHERE \n    t.production_year > 2000\nORDER BY \n    t.production_year DESC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'id' not found in 't'\", span: None, notes: [DiagnosticNote { message: \"possible column ci.id\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"t\" }), name: \"id\" }, valid_fields: [Column { relation: Some(Bare { table: \"t\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"person_id\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"movie_id\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"person_role_id\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"note\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"nr_order\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"role_id\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "18114.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    ct.kind AS company_type,\n    ki.keyword AS movie_keyword\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    aka_title t ON ci.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.movie_id = mc.movie_id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nJOIN \n    movie_keyword mk ON t.movie_id = mk.movie_id\nJOIN \n    keyword ki ON mk.keyword_id = ki.id\nWHERE \n    t.production_year = 2020\nORDER BY \n    a.name, t.title;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT id AS movie_id, title AS movie_title FROM title WHERE production_year = 2020;", "sql2": "SELECT a.name AS actor_name,\n       s1.movie_title,\n       ct.kind AS company_type,\n       ki.keyword AS movie_keyword\nFROM s1\nJOIN cast_info ci ON s1.movie_id = ci.movie_id\nJOIN aka_name a ON ci.person_id = a.person_id\nJOIN movie_companies mc ON s1.movie_id = mc.movie_id\nJOIN company_type ct ON mc.company_type_id = ct.id\nJOIN movie_keyword mk ON s1.movie_id = mk.movie_id\nJOIN keyword ki ON mk.keyword_id = ki.id\nORDER BY a.name, s1.movie_title;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "18199.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.nr_order AS cast_order,\n    m.info AS movie_info\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    aka_title t ON c.movie_id = t.movie_id\nJOIN \n    movie_info m ON t.id = m.movie_id\nWHERE \n    m.info_type_id = (SELECT id FROM info_type WHERE info = 'box office')\nORDER BY \n    c.nr_order;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT movie_id, info FROM movie_info WHERE info_type_id = (SELECT id FROM info_type WHERE info = 'box office')", "sql2": "SELECT a.name AS actor_name,\n       t.title AS movie_title,\n       c.nr_order AS cast_order,\n       s1.info AS movie_info\nFROM aka_name a\nJOIN cast_info c ON a.person_id = c.person_id\nJOIN aka_title t ON c.movie_id = t.movie_id\nJOIN s1 ON t.id = s1.movie_id\nORDER BY c.nr_order;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "18529.sql", "original_sql": "SELECT \n    ak.name AS aka_name,\n    t.title AS movie_title,\n    c.person_role_id,\n    ci.kind,\n    m.name AS company_name\nFROM \n    aka_name ak\nJOIN \n    cast_info c ON ak.person_id = c.person_id\nJOIN \n    title t ON c.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name m ON mc.company_id = m.id\nJOIN \n    comp_cast_type ci ON c.person_role_id = ci.id\nWHERE \n    t.production_year = 2023\nORDER BY \n    ak.name, t.title;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS movie_id,\n       t.title AS movie_title,\n       m.name AS company_name\nFROM   title t\nJOIN   movie_companies mc ON t.id = mc.movie_id\nJOIN   company_name m ON mc.company_id = m.id\nWHERE  t.production_year = 2023;", "sql2": "SELECT ak.name AS aka_name,\n       s1.movie_title,\n       c.person_role_id,\n       ci.kind,\n       s1.company_name\nFROM   aka_name ak\nJOIN   cast_info c ON ak.person_id = c.person_id\nJOIN   s1 ON c.movie_id = s1.movie_id\nJOIN   comp_cast_type ci ON c.person_role_id = ci.id\nORDER BY ak.name, s1.movie_title;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "18700.sql", "original_sql": "SELECT \n    t.title,\n    a.name AS actor_name,\n    p.info AS actor_info\nFROM \n    title t\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name c ON mc.company_id = c.id\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info ci ON cc.subject_id = ci.id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    person_info p ON a.person_id = p.person_id\nWHERE \n    t.production_year >= 2000\nORDER BY \n    t.production_year DESC\nLIMIT 10;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'id' not found in 't'\", span: None, notes: [DiagnosticNote { message: \"possible column mc.id\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"t\" }), name: \"id\" }, valid_fields: [Column { relation: Some(Bare { table: \"t\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"mc\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"mc\" }), name: \"movie_id\" }, Column { relation: Some(Bare { table: \"mc\" }), name: \"company_id\" }, Column { relation: Some(Bare { table: \"mc\" }), name: \"company_type_id\" }, Column { relation: Some(Bare { table: \"mc\" }), name: \"note\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "18738.sql", "original_sql": "SELECT \n    t.title, \n    a.name AS actor_name, \n    c.kind AS cast_type\nFROM \n    title t\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    cast_info ci ON t.id = ci.movie_id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    comp_cast_type c ON ci.person_role_id = c.id\nWHERE \n    cn.country_code = 'USA' \n    AND t.production_year >= 2000\nORDER BY \n    t.production_year DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT DISTINCT t.id AS movie_id,\n                t.title,\n                t.production_year\nFROM title t\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nWHERE cn.country_code = 'USA'\n  AND t.production_year >= 2000;", "sql2": "SELECT s1.title,\n       a.name AS actor_name,\n       c.kind AS cast_type\nFROM s1\nJOIN cast_info ci ON s1.movie_id = ci.movie_id\nJOIN aka_name a ON ci.person_id = a.person_id\nJOIN comp_cast_type c ON ci.person_role_id = c.id\nORDER BY s1.production_year DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "19022.sql", "original_sql": "SELECT \n    t.title,\n    a.name AS actor_name,\n    c.kind AS company_type\nFROM \n    title t\nJOIN \n    cast_info ci ON t.id = ci.movie_id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nWHERE \n    t.production_year = 2020\nORDER BY \n    t.title, a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS title_id,\n       t.title,\n       a.name AS actor_name\nFROM title t\nJOIN cast_info ci ON t.id = ci.movie_id\nJOIN aka_name a ON ci.person_id = a.person_id\nWHERE t.production_year = 2020;", "sql2": "SELECT s1.title,\n       s1.actor_name,\n       c.kind AS company_type\nFROM s1\nJOIN movie_companies mc ON s1.title_id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nORDER BY s1.title, s1.actor_name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "19156.sql", "original_sql": "SELECT \n    t.title,\n    a.name AS actor_name,\n    c.kind AS company_type,\n    m.info AS movie_info\nFROM \n    aka_title t\nJOIN \n    cast_info ci ON t.id = ci.movie_id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_info m ON t.id = m.movie_id\nWHERE \n    c.kind = 'Producer' \n    AND t.production_year >= 2000 \nORDER BY \n    t.production_year DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT DISTINCT t.id AS movie_id,\n                t.title,\n                t.production_year,\n                c.kind AS company_type\nFROM   aka_title t\nJOIN   movie_companies mc ON t.id = mc.movie_id\nJOIN   company_type c ON mc.company_type_id = c.id\nWHERE  c.kind = 'Producer'\n  AND  t.production_year >= 2000;", "sql2": "SELECT \n    s1.title,\n    a.name AS actor_name,\n    s1.company_type,\n    m.info AS movie_info\nFROM   s1\nJOIN   cast_info ci ON s1.movie_id = ci.movie_id\nJOIN   aka_name a ON ci.person_id = a.person_id\nJOIN   movie_info m ON s1.movie_id = m.movie_id;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "19187.sql", "original_sql": "SELECT \n    t.title,\n    a.name AS actor_name,\n    p.info AS actor_info\nFROM \n    title t\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name c ON mc.company_id = c.id\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info ci ON cc.subject_id = ci.person_id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    person_info p ON a.person_id = p.person_id\nWHERE \n    t.production_year = 2020\nORDER BY \n    t.title, a.name;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "19235.sql", "original_sql": "SELECT \n    t.title, \n    a.name, \n    c.role_id \nFROM \n    title t \nJOIN \n    movie_companies mc ON t.id = mc.movie_id \nJOIN \n    company_name cn ON mc.company_id = cn.id \nJOIN \n    cast_info c ON t.id = c.movie_id \nJOIN \n    aka_name a ON c.person_id = a.person_id \nWHERE \n    t.production_year > 2000 \nORDER BY \n    t.production_year DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id, t.title, t.production_year, a.name, c.role_id FROM title t JOIN movie_companies mc ON t.id = mc.movie_id JOIN company_name cn ON mc.company_id = cn.id JOIN cast_info c ON t.id = c.movie_id JOIN aka_name a ON c.person_id = a.person_id WHERE t.production_year > 2000;", "sql2": "SELECT title, name, role_id FROM s1 ORDER BY production_year DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "19356.sql", "original_sql": "SELECT \n    t.title,\n    a.name AS actor_name,\n    p.info AS actor_info\nFROM \n    title t\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info ci ON cc.subject_id = ci.person_id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    person_info p ON ci.person_id = p.person_id\nWHERE \n    t.production_year > 2000\nORDER BY \n    t.production_year DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS title_id, t.title, t.production_year, ci.person_id FROM title t JOIN complete_cast cc ON t.id = cc.movie_id JOIN cast_info ci ON cc.subject_id = ci.person_id WHERE t.production_year > 2000", "sql2": "SELECT s1.title, a.name AS actor_name, p.info AS actor_info FROM s1 JOIN aka_name a ON s1.person_id = a.person_id JOIN person_info p ON s1.person_id = p.person_id ORDER BY s1.production_year DESC", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "19655.sql", "original_sql": "SELECT \n    t.title, \n    a.name, \n    c.note \nFROM \n    title t \nJOIN \n    movie_companies mc ON t.id = mc.movie_id \nJOIN \n    company_name cn ON mc.company_id = cn.id \nJOIN \n    cast_info c ON t.id = c.movie_id \nJOIN \n    aka_name a ON c.person_id = a.person_id \nWHERE \n    t.production_year = 2023 \nORDER BY \n    t.title;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT id, title FROM title WHERE production_year = 2023;", "sql2": "SELECT t.title, a.name, c.note FROM s1 t JOIN movie_companies mc ON t.id = mc.movie_id JOIN company_name cn ON mc.company_id = cn.id JOIN cast_info c ON t.id = c.movie_id JOIN aka_name a ON c.person_id = a.person_id ORDER BY t.title;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "20149.sql", "original_sql": "\nWITH RecursiveMovieCTE AS (\n    SELECT \n        t.id AS title_id,\n        t.title,\n        t.production_year,\n        COALESCE(COUNT(ci.person_id), 0) AS cast_count,\n        COALESCE(SUM(CASE WHEN ci.nr_order IS NULL THEN 0 ELSE 1 END), 0) AS valid_cast_count\n    FROM \n        aka_title t\n    LEFT JOIN \n        cast_info ci ON t.id = ci.movie_id\n    GROUP BY \n        t.id, t.title, t.production_year\n),\nFilteredMovies AS (\n    SELECT \n        title_id,\n        title,\n        production_year,\n        cast_count,\n        valid_cast_count,\n        NTILE(10) OVER (ORDER BY production_year DESC) AS decade_bucket\n    FROM \n        RecursiveMovieCTE\n    WHERE \n        production_year IS NOT NULL\n),\nMovieGenres AS (\n    SELECT \n        mt.movie_id,\n        STRING_AGG(DISTINCT k.keyword, ', ') AS genres\n    FROM \n        movie_keyword mk\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    JOIN \n        aka_title mt ON mk.movie_id = mt.id\n    GROUP BY \n        mt.movie_id\n),\nMovieInfo AS (\n    SELECT \n        mt.id AS movie_id,\n        mt.title AS movie_title,\n        fi.info AS additional_info,\n        vi.note AS info_note\n    FROM \n        aka_title mt\n    LEFT JOIN \n        movie_info fi ON mt.id = fi.movie_id\n    LEFT JOIN \n        movie_info_idx vi ON mt.id = vi.movie_id AND fi.info_type_id = vi.info_type_id\n)\nSELECT \n    fl.title AS movie_title,\n    fl.production_year,\n    fl.cast_count,\n    fl.valid_cast_count,\n    COALESCE(mg.genres, 'No Genre') AS genre_list,\n    mi.additional_info,\n    mi.info_note,\n    CASE \n        WHEN fl.cast_count > 100 THEN 'Large Ensemble'\n        WHEN fl.cast_count BETWEEN 50 AND 100 THEN 'Medium Ensemble'\n        ELSE 'Small Ensemble'\n    END AS cast_size_category\nFROM \n    FilteredMovies fl\nLEFT JOIN \n    MovieGenres mg ON fl.title_id = mg.movie_id\nLEFT JOIN \n    MovieInfo mi ON fl.title_id = mi.movie_id\nWHERE \n    (fl.production_year >= 1990 OR fl.production_year IS NULL)\nAND \n    (fl.cast_count IS NOT NULL OR fl.valid_cast_count IS NOT NULL)\nORDER BY \n    fl.production_year DESC, \n    fl.cast_count DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH RecursiveMovieCTE AS (\n    SELECT \n        t.id AS title_id,\n        COUNT(ci.person_id) AS cast_count,\n        SUM(CASE WHEN ci.nr_order IS NULL THEN 0 ELSE 1 END) AS valid_cast_count\n    FROM aka_title t\n    LEFT JOIN cast_info ci ON t.id = ci.movie_id\n    GROUP BY t.id\n),\nFilteredMovies AS (\n    SELECT \n        r.title_id,\n        t.title,\n        t.production_year,\n        r.cast_count,\n        r.valid_cast_count,\n        NTILE(10) OVER (ORDER BY t.production_year DESC) AS decade_bucket\n    FROM RecursiveMovieCTE r\n    JOIN aka_title t ON r.title_id = t.id\n    WHERE t.production_year IS NOT NULL\n)\nSELECT title_id, title, production_year, cast_count, valid_cast_count FROM FilteredMovies;", "sql2": "WITH MovieGenres AS (\n    SELECT \n        mt.id AS movie_id,\n        STRING_AGG(DISTINCT k.keyword, ', ') AS genres\n    FROM movie_keyword mk\n    JOIN keyword k ON mk.keyword_id = k.id\n    JOIN aka_title mt ON mk.movie_id = mt.id\n    GROUP BY mt.id\n),\nMovieInfo AS (\n    SELECT \n        mt.id AS movie_id,\n        fi.info AS additional_info,\n        vi.note AS info_note\n    FROM aka_title mt\n    LEFT JOIN movie_info fi ON mt.id = fi.movie_id\n    LEFT JOIN movie_info_idx vi ON mt.id = vi.movie_id AND fi.info_type_id = vi.info_type_id\n)\nSELECT \n    s.title AS movie_title,\n    s.production_year,\n    s.cast_count,\n    s.valid_cast_count,\n    COALESCE(mg.genres, 'No Genre') AS genre_list,\n    mi.additional_info,\n    mi.info_note,\n    CASE \n        WHEN s.cast_count > 100 THEN 'Large Ensemble'\n        WHEN s.cast_count BETWEEN 50 AND 100 THEN 'Medium Ensemble'\n        ELSE 'Small Ensemble'\n    END AS cast_size_category\nFROM s1 s\nLEFT JOIN MovieGenres mg ON s.title_id = mg.movie_id\nLEFT JOIN MovieInfo mi ON s.title_id = mi.movie_id\nWHERE (s.production_year >= 1990 OR s.production_year IS NULL)\n  AND (s.cast_count IS NOT NULL OR s.valid_cast_count IS NOT NULL)\nORDER BY s.production_year DESC, s.cast_count DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "20260.sql", "original_sql": "\nWITH RankedTitles AS (\n    SELECT \n        at.id AS title_id,\n        at.title,\n        at.production_year,\n        ROW_NUMBER() OVER (PARTITION BY at.production_year ORDER BY at.title ASC) AS title_rank\n    FROM \n        aka_title at\n    WHERE \n        at.production_year IS NOT NULL\n),\nActorMovieCount AS (\n    SELECT \n        ci.person_id,\n        COUNT(DISTINCT ci.movie_id) AS movie_count\n    FROM \n        cast_info ci\n    JOIN \n        RankedTitles rt ON ci.movie_id = rt.title_id\n    GROUP BY \n        ci.person_id\n),\nDistinctActors AS (\n    SELECT \n        ak.name,\n        ak.id AS actor_id,\n        amc.movie_count\n    FROM \n        aka_name ak\n    LEFT JOIN \n        ActorMovieCount amc ON ak.person_id = amc.person_id\n    WHERE \n        ak.name IS NOT NULL\n),\nMovieCompanyDetails AS (\n    SELECT \n        mc.movie_id,\n        STRING_AGG(DISTINCT cn.name, ', ') AS company_names,\n        COUNT(DISTINCT mc.company_id) AS total_companies\n    FROM \n        movie_companies mc\n    JOIN \n        company_name cn ON mc.company_id = cn.id\n    GROUP BY \n        mc.movie_id\n)\nSELECT \n    dt.actor_id,\n    dt.name AS actor_name,\n    dt.movie_count,\n    mt.title,\n    mt.production_year,\n    mcd.company_names,\n    mcd.total_companies\nFROM \n    DistinctActors dt\nJOIN \n    cast_info ci ON dt.actor_id = ci.person_id\nJOIN \n    RankedTitles mt ON ci.movie_id = mt.title_id\nLEFT JOIN \n    MovieCompanyDetails mcd ON mt.title_id = mcd.movie_id\nWHERE \n    dt.movie_count >= (\n        SELECT \n            AVG(movie_count) \n        FROM \n            ActorMovieCount\n    )\n    AND mcd.total_companies > 1 \nORDER BY \n    dt.name ASC, mt.production_year DESC;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "2031.sql", "original_sql": "WITH ranked_movies AS (\n    SELECT \n        m.id AS movie_id,\n        m.title,\n        m.production_year,\n        ROW_NUMBER() OVER (PARTITION BY m.production_year ORDER BY m.title) AS rank_in_year\n    FROM \n        aka_title m\n    WHERE \n        m.production_year IS NOT NULL\n),\n\nmovie_details AS (\n    SELECT \n        rm.movie_id,\n        rm.title,\n        rm.production_year,\n        COALESCE(SUM(mc.company_id), 0) AS total_companies,\n        COUNT(DISTINCT ki.keyword) AS total_keywords\n    FROM \n        ranked_movies rm\n    LEFT JOIN \n        movie_companies mc ON rm.movie_id = mc.movie_id\n    LEFT JOIN \n        movie_keyword mk ON rm.movie_id = mk.movie_id\n    LEFT JOIN \n        keyword ki ON mk.keyword_id = ki.id\n    GROUP BY \n        rm.movie_id, rm.title, rm.production_year\n),\n\nactors_in_movies AS (\n    SELECT \n        c.movie_id,\n        COUNT(DISTINCT a.id) AS total_actors\n    FROM \n        cast_info c\n    INNER JOIN \n        aka_name a ON c.person_id = a.person_id\n    WHERE \n        a.name IS NOT NULL\n    GROUP BY \n        c.movie_id\n)\n\nSELECT \n    md.movie_id,\n    md.title,\n    md.production_year,\n    md.total_companies,\n    md.total_keywords,\n    COALESCE(a.total_actors, 0) AS total_actors,\n    CASE \n        WHEN md.production_year >= 2000 THEN 'Modern'\n        ELSE 'Classic' \n    END AS movie_era\nFROM \n    movie_details md\nLEFT JOIN \n    actors_in_movies a ON md.movie_id = a.movie_id\nWHERE \n    md.total_companies > 0\nORDER BY \n    md.production_year DESC, md.title;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    rm.id AS movie_id,\n    rm.title,\n    rm.production_year,\n    COALESCE(SUM(mc.company_id), 0) AS total_companies,\n    COUNT(DISTINCT ki.keyword) AS total_keywords\nFROM (\n    SELECT \n        m.id,\n        m.title,\n        m.production_year,\n        ROW_NUMBER() OVER (PARTITION BY m.production_year ORDER BY m.title) AS rank_in_year\n    FROM aka_title m\n    WHERE m.production_year IS NOT NULL\n) rm\nLEFT JOIN movie_companies mc ON rm.id = mc.movie_id\nLEFT JOIN movie_keyword mk ON rm.id = mk.movie_id\nLEFT JOIN keyword ki ON mk.keyword_id = ki.id\nGROUP BY rm.id, rm.title, rm.production_year;", "sql2": "WITH actors_in_movies AS (\n    SELECT \n        c.movie_id,\n        COUNT(DISTINCT a.id) AS total_actors\n    FROM cast_info c\n    INNER JOIN aka_name a ON c.person_id = a.person_id\n    WHERE a.name IS NOT NULL\n    GROUP BY c.movie_id\n)\nSELECT \n    md.movie_id,\n    md.title,\n    md.production_year,\n    md.total_companies,\n    md.total_keywords,\n    COALESCE(a.total_actors, 0) AS total_actors,\n    CASE \n        WHEN md.production_year >= 2000 THEN 'Modern'\n        ELSE 'Classic'\n    END AS movie_era\nFROM s1 md\nLEFT JOIN actors_in_movies a ON md.movie_id = a.movie_id\nWHERE md.total_companies > 0\nORDER BY md.production_year DESC, md.title;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "22671.sql", "original_sql": "WITH RECURSIVE movie_hierarchy AS (\n    SELECT \n        mt.id AS movie_id,\n        mt.title,\n        mt.production_year,\n        ml.linked_movie_id,\n        1 AS level\n    FROM \n        aka_title mt\n    LEFT JOIN \n        movie_link ml ON mt.id = ml.movie_id\n    WHERE \n        mt.production_year IS NOT NULL\n    \n    UNION ALL\n    \n    SELECT \n        mh.movie_id,\n        mt.title,\n        mt.production_year,\n        ml.linked_movie_id,\n        mh.level + 1\n    FROM \n        movie_hierarchy mh\n    JOIN \n        movie_link ml ON mh.linked_movie_id = ml.movie_id\n    JOIN \n        aka_title mt ON ml.linked_movie_id = mt.id\n    WHERE \n        mh.level < 5\n),\ntitle_info AS (\n    SELECT \n        t.title,\n        COUNT(DISTINCT ci.person_id) AS cast_count,\n        AVG(CASE WHEN ci.nr_order IS NOT NULL THEN ci.nr_order ELSE 0 END) AS avg_order\n    FROM \n        aka_title t\n    LEFT JOIN \n        cast_info ci ON ci.movie_id = t.id\n    WHERE \n        t.production_year = (SELECT MAX(production_year) FROM aka_title)\n    GROUP BY \n        t.title\n),\nkeyword_info AS (\n    SELECT \n        kt.keyword,\n        COUNT(mk.movie_id) AS movie_count\n    FROM \n        keyword kt\n    LEFT JOIN \n        movie_keyword mk ON kt.id = mk.keyword_id\n    GROUP BY \n        kt.keyword\n    HAVING \n        COUNT(mk.movie_id) > 5\n),\ncompany_summary AS (\n    SELECT \n        c.name AS company_name,\n        COUNT(mc.movie_id) AS movies_produced\n    FROM \n        company_name c\n    LEFT JOIN \n        movie_companies mc ON c.id = mc.company_id\n    WHERE \n        c.country_code IS NOT NULL\n    GROUP BY \n        c.name\n    HAVING \n        COUNT(mc.movie_id) > 10\n)\nSELECT \n    th.title,\n    th.cast_count,\n    th.avg_order,\n    kw.keyword,\n    kw.movie_count,\n    cs.company_name,\n    cs.movies_produced\nFROM \n    title_info th\nJOIN \n    keyword_info kw ON th.cast_count > 10\nLEFT JOIN \n    company_summary cs ON cs.movies_produced > th.cast_count\nWHERE \n    th.avg_order IS NOT NULL\nORDER BY \n    th.cast_count DESC, cs.movies_produced ASC\nLIMIT 50;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'cast_count' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column s1.count\", span: None }, DiagnosticNote { message: \"possible column kw.movie_count\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"cast_count\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"kw\" }), name: \"keyword\" }, Column { relation: Some(Bare { table: \"kw\" }), name: \"movie_count\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "23044.sql", "original_sql": "WITH RankedMovies AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        ROW_NUMBER() OVER (PARTITION BY t.production_year ORDER BY t.title) AS year_rank\n    FROM \n        aka_title t\n    WHERE \n        t.production_year IS NOT NULL\n),\nMoviesWithGenres AS (\n    SELECT \n        m.movie_id,\n        m.title,\n        m.production_year,\n        STRING_AGG(DISTINCT g.keyword, ', ') AS genres\n    FROM \n        RankedMovies m\n    LEFT JOIN \n        movie_keyword mk ON m.movie_id = mk.movie_id\n    LEFT JOIN \n        keyword g ON mk.keyword_id = g.id\n    GROUP BY \n        m.movie_id, m.title, m.production_year\n),\nMovieCastInfo AS (\n    SELECT \n        c.movie_id,\n        COUNT(DISTINCT c.person_id) AS total_cast,\n        SUM(CASE WHEN r.role = 'Director' THEN 1 ELSE 0 END) AS director_count\n    FROM \n        cast_info c\n    JOIN \n        role_type r ON c.role_id = r.id\n    GROUP BY \n        c.movie_id\n)\nSELECT \n    mw.movie_id,\n    mw.title,\n    mw.production_year,\n    mw.genres,\n    COALESCE(ci.total_cast, 0) AS total_cast,\n    COALESCE(ci.director_count, 0) AS director_count,\n    CASE \n        WHEN mw.production_year IS NOT NULL AND mw.genres IS NOT NULL THEN 'Valid Movie'\n        WHEN mw.production_year IS NULL AND mw.genres IS NULL THEN 'Unknown'\n        ELSE 'Incomplete Data'\n    END AS movie_status\nFROM \n    MoviesWithGenres mw\nLEFT JOIN \n    MovieCastInfo ci ON mw.movie_id = ci.movie_id\nWHERE \n    mw.production_year BETWEEN 2000 AND 2023\nORDER BY \n    mw.production_year DESC, mw.title ASC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH RankedMovies AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        ROW_NUMBER() OVER (PARTITION BY t.production_year ORDER BY t.title) AS year_rank\n    FROM aka_title t\n    WHERE t.production_year IS NOT NULL\n      AND t.production_year BETWEEN 2000 AND 2023\n)\nSELECT \n    rm.movie_id,\n    rm.title,\n    rm.production_year,\n    STRING_AGG(DISTINCT k.keyword, ', ') AS genres\nFROM RankedMovies rm\nLEFT JOIN movie_keyword mk ON rm.movie_id = mk.movie_id\nLEFT JOIN keyword k ON mk.keyword_id = k.id\nGROUP BY rm.movie_id, rm.title, rm.production_year;", "sql2": "WITH MovieCastInfo AS (\n    SELECT \n        c.movie_id,\n        COUNT(DISTINCT c.person_id) AS total_cast,\n        SUM(CASE WHEN r.role = 'Director' THEN 1 ELSE 0 END) AS director_count\n    FROM cast_info c\n    JOIN role_type r ON c.role_id = r.id\n    GROUP BY c.movie_id\n)\nSELECT \n    s1.movie_id,\n    s1.title,\n    s1.production_year,\n    s1.genres,\n    COALESCE(ci.total_cast, 0) AS total_cast,\n    COALESCE(ci.director_count, 0) AS director_count,\n    CASE \n        WHEN s1.production_year IS NOT NULL AND s1.genres IS NOT NULL THEN 'Valid Movie'\n        WHEN s1.production_year IS NULL AND s1.genres IS NULL THEN 'Unknown'\n        ELSE 'Incomplete Data'\n    END AS movie_status\nFROM s1\nLEFT JOIN MovieCastInfo ci ON s1.movie_id = ci.movie_id\nORDER BY s1.production_year DESC, s1.title ASC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "23142.sql", "original_sql": "\nWITH RecursiveMovieCTE AS (\n    SELECT \n        mt.id AS movie_id, \n        mt.title, \n        mt.production_year, \n        COALESCE(AVG(CASE WHEN ci.role_id IS NOT NULL THEN 1 END), 0) AS avg_starring_roles,\n        COUNT(DISTINCT ci.person_id) AS full_cast_count,\n        STRING_AGG(DISTINCT an.name, ', ') AS actors_list\n    FROM \n        aka_title mt\n    LEFT JOIN \n        cast_info ci ON mt.movie_id = ci.movie_id\n    LEFT JOIN \n        aka_name an ON ci.person_id = an.person_id\n    GROUP BY \n        mt.id, mt.title, mt.production_year\n    HAVING \n        COUNT(DISTINCT ci.person_id) > 5\n), FilteredMovies AS (\n    SELECT \n        movie_id,\n        title,\n        production_year,\n        avg_starring_roles,\n        full_cast_count,\n        actors_list\n    FROM \n        RecursiveMovieCTE\n    WHERE \n        production_year IS NOT NULL AND (production_year < 2000 OR avg_starring_roles > 2)\n), MovieKeywordCTE AS (\n    SELECT \n        km.movie_id,\n        STRING_AGG(DISTINCT k.keyword, ', ') AS keywords\n    FROM \n        movie_keyword km\n    JOIN \n        keyword k ON km.keyword_id = k.id\n    GROUP BY \n        km.movie_id\n), FinalMovieInfo AS (\n    SELECT \n        fm.movie_id,\n        fm.title,\n        fm.production_year,\n        fm.avg_starring_roles,\n        fm.full_cast_count,\n        fm.actors_list,\n        COALESCE(mk.keywords, 'None') AS keywords\n    FROM \n        FilteredMovies fm\n    LEFT JOIN \n        MovieKeywordCTE mk ON fm.movie_id = mk.movie_id\n)\nSELECT \n    f.movie_id,\n    f.title,\n    f.production_year,\n    f.avg_starring_roles,\n    f.full_cast_count,\n    f.actors_list,\n    f.keywords\nFROM \n    FinalMovieInfo f\nWHERE \n    f.keywords LIKE '%action%' OR f.title LIKE '% thriller%'\nORDER BY \n    CASE \n        WHEN f.avg_starring_roles > 3 THEN 1 \n        ELSE 2 \n    END, \n    f.production_year DESC;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "23632.sql", "original_sql": "\nWITH MovieData AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        t.kind_id,\n        COALESCE(NULLIF(k.keyword, ''), 'No Keyword') AS keyword,\n        m.name AS company_name,\n        ct.kind AS company_type,\n        ROW_NUMBER() OVER (PARTITION BY t.id ORDER BY k.keyword DESC NULLS LAST) AS keyword_rank\n    FROM \n        aka_title t\n    LEFT JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    LEFT JOIN \n        keyword k ON mk.keyword_id = k.id\n    LEFT JOIN \n        movie_companies mc ON t.id = mc.movie_id\n    LEFT JOIN \n        company_name m ON mc.company_id = m.id\n    LEFT JOIN \n        company_type ct ON mc.company_type_id = ct.id\n    WHERE \n        t.production_year >= 2000\n        AND TRIM(t.title) != ''\n),\nCastingData AS (\n    SELECT \n        ci.movie_id,\n        COUNT(DISTINCT ci.person_id) AS total_cast,\n        COUNT(CASE WHEN ci.role_id IS NOT NULL THEN 1 END) AS validated_cast,\n        AVG(CASE WHEN ci.note IS NOT NULL AND ci.note <> '' THEN 1 ELSE 0 END) AS note_non_empty_ratio,\n        STRING_AGG(DISTINCT n.name, ', ') AS cast_names\n    FROM \n        cast_info ci\n    LEFT JOIN \n        aka_name n ON ci.person_id = n.person_id\n    GROUP BY \n        ci.movie_id\n),\nFullMovieStats AS (\n    SELECT \n        md.*,\n        cd.total_cast,\n        cd.validated_cast,\n        ROUND(CAST(cd.note_non_empty_ratio AS numeric), 2) AS note_ratio,\n        cd.cast_names\n    FROM \n        MovieData md\n    LEFT JOIN \n        CastingData cd ON md.movie_id = cd.movie_id\n    WHERE \n        md.keyword_rank = 1 \n        OR md.production_year IS NOT NULL\n)\nSELECT \n    fms.movie_id,\n    fms.title,\n    fms.production_year,\n    fms.keyword,\n    fms.company_name,\n    fms.company_type,\n    fms.total_cast,\n    fms.validated_cast,\n    CASE \n        WHEN fms.note_ratio IS NULL THEN 'No Data' \n        ELSE CONCAT(fms.note_ratio, '%') \n    END AS note_ratio_percentage,\n    CASE \n        WHEN fms.cast_names IS NULL THEN 'No Cast Data' \n        ELSE fms.cast_names \n    END AS detailed_cast_names\nFROM \n    FullMovieStats fms\nWHERE \n    (fms.total_cast > 5 AND fms.validated_cast / NULLIF(fms.total_cast, 0) > 0.5)\n    OR (fms.production_year < 2020 AND fms.company_name IS NOT NULL)\nORDER BY \n    fms.production_year DESC, \n    fms.title ASC;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "2378.sql", "original_sql": "WITH RankedMovies AS (\n    SELECT \n        t.id AS movie_id, \n        t.title, \n        t.production_year, \n        ROW_NUMBER() OVER (PARTITION BY t.production_year ORDER BY t.id) AS rank\n    FROM \n        aka_title t\n    WHERE \n        t.production_year >= 2000\n), \nCastInfo AS (\n    SELECT \n        c.movie_id, \n        COUNT(c.person_id) AS total_cast,\n        STRING_AGG(a.name, ', ') AS cast_names\n    FROM \n        cast_info c\n    JOIN \n        aka_name a ON c.person_id = a.person_id\n    GROUP BY c.movie_id\n), \nCompanyDetails AS (\n    SELECT \n        mc.movie_id,\n        STRING_AGG(DISTINCT cn.name, ', ') AS companies,\n        COUNT(DISTINCT mc.company_id) AS total_companies\n    FROM \n        movie_companies mc\n    JOIN \n        company_name cn ON mc.company_id = cn.id\n    GROUP BY mc.movie_id\n)\nSELECT \n    rm.title,\n    rm.production_year,\n    ci.total_cast,\n    ci.cast_names,\n    cd.total_companies,\n    cd.companies\nFROM \n    RankedMovies rm\nLEFT JOIN \n    CastInfo ci ON rm.movie_id = ci.movie_id\nLEFT JOIN \n    CompanyDetails cd ON rm.movie_id = cd.movie_id\nWHERE \n    (ci.total_cast IS NULL OR ci.total_cast > 5) \n    AND (rm.production_year BETWEEN 2000 AND 2023)\n    AND (cd.total_companies IS NULL OR cd.total_companies > 2)\nORDER BY \n    rm.production_year DESC, \n    rm.title;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "25087.sql", "original_sql": "WITH MovieDetails AS (\n    SELECT \n        t.title AS movie_title,\n        t.production_year,\n        c.name AS company_name,\n        k.keyword AS movie_keyword,\n        p.name AS person_name,\n        r.role AS person_role\n    FROM \n        title t\n    JOIN \n        movie_companies mc ON t.id = mc.movie_id\n    JOIN \n        company_name c ON mc.company_id = c.id\n    JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    JOIN \n        complete_cast cc ON t.id = cc.movie_id\n    JOIN \n        cast_info ci ON cc.subject_id = ci.person_id\n    JOIN \n        aka_name p ON ci.person_id = p.person_id\n    JOIN \n        role_type r ON ci.role_id = r.id\n)\n\nSELECT \n    movie_title,\n    production_year,\n    STRING_AGG(DISTINCT company_name, ', ') AS companies,\n    STRING_AGG(DISTINCT movie_keyword, ', ') AS keywords,\n    STRING_AGG(DISTINCT person_name || ' (' || person_role || ')', ', ') AS cast\nFROM \n    MovieDetails\nGROUP BY \n    movie_title, production_year\nORDER BY \n    production_year DESC, movie_title ASC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT \n    t.title AS movie_title,\n    t.production_year,\n    c.name AS company_name,\n    k.keyword AS movie_keyword,\n    p.name AS person_name,\n    r.role AS person_role\nFROM title t\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_name c ON mc.company_id = c.id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nJOIN complete_cast cc ON t.id = cc.movie_id\nJOIN cast_info ci ON cc.subject_id = ci.person_id\nJOIN aka_name p ON ci.person_id = p.person_id\nJOIN role_type r ON ci.role_id = r.id", "sql2": "SELECT \n    movie_title,\n    production_year,\n    STRING_AGG(DISTINCT company_name, ', ') AS companies,\n    STRING_AGG(DISTINCT movie_keyword, ', ') AS keywords,\n    STRING_AGG(DISTINCT person_name || ' (' || person_role || ')', ', ') AS cast\nFROM s1\nGROUP BY movie_title, production_year\nORDER BY production_year DESC, movie_title ASC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "25179.sql", "original_sql": "WITH MovieDetails AS (\n    SELECT \n        m.id AS movie_id,\n        m.title AS movie_title,\n        m.production_year,\n        k.keyword AS keyword,\n        ARRAY_AGG(DISTINCT c.name) AS cast_names\n    FROM \n        aka_title m\n    JOIN \n        movie_keyword mk ON m.id = mk.movie_id\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    JOIN \n        complete_cast cc ON m.id = cc.movie_id\n    JOIN \n        aka_name c ON cc.subject_id = c.person_id\n    GROUP BY \n        m.id, k.keyword, m.title, m.production_year\n),\n\nCompanyDetails AS (\n    SELECT \n        mc.movie_id,\n        cn.name AS company_name,\n        ct.kind AS company_type,\n        COUNT(mc.id) AS total_companies\n    FROM \n        movie_companies mc\n    JOIN \n        company_name cn ON mc.company_id = cn.id\n    JOIN \n        company_type ct ON mc.company_type_id = ct.id\n    GROUP BY \n        mc.movie_id, cn.name, ct.kind\n),\n\nCombinedDetails AS (\n    SELECT \n        md.movie_id,\n        md.movie_title,\n        md.production_year,\n        md.keyword,\n        md.cast_names,\n        COALESCE(cd.company_name, 'Unknown') AS company_name,\n        COALESCE(cd.company_type, 'Unknown') AS company_type,\n        COALESCE(cd.total_companies, 0) AS total_companies\n    FROM \n        MovieDetails md\n    LEFT JOIN \n        CompanyDetails cd ON md.movie_id = cd.movie_id\n)\n\nSELECT \n    movie_id,\n    movie_title,\n    production_year,\n    keyword,\n    cast_names,\n    company_name,\n    company_type,\n    total_companies\nFROM \n    CombinedDetails\nWHERE \n    production_year BETWEEN 2000 AND 2023\nORDER BY \n    production_year DESC, movie_title\nLIMIT 100;\n\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT m.id AS movie_id, m.title AS movie_title, m.production_year, k.keyword AS keyword, ARRAY_AGG(DISTINCT c.name) AS cast_names FROM aka_title m JOIN movie_keyword mk ON m.id = mk.movie_id JOIN keyword k ON mk.keyword_id = k.id JOIN complete_cast cc ON m.id = cc.movie_id JOIN aka_name c ON cc.subject_id = c.person_id GROUP BY m.id, k.keyword, m.title, m.production_year", "sql2": "WITH CompanyDetails AS (SELECT mc.movie_id, cn.name AS company_name, ct.kind AS company_type, COUNT(mc.id) AS total_companies FROM movie_companies mc JOIN company_name cn ON mc.company_id = cn.id JOIN company_type ct ON mc.company_type_id = ct.id GROUP BY mc.movie_id, cn.name, ct.kind) SELECT s1.movie_id, s1.movie_title, s1.production_year, s1.keyword, s1.cast_names, COALESCE(cd.company_name, 'Unknown') AS company_name, COALESCE(cd.company_type, 'Unknown') AS company_type, COALESCE(cd.total_companies, 0) AS total_companies FROM s1 LEFT JOIN CompanyDetails cd ON s1.movie_id = cd.movie_id WHERE s1.production_year BETWEEN 2000 AND 2023 ORDER BY s1.production_year DESC, s1.movie_title LIMIT 100", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "25294.sql", "original_sql": "\nWITH RankedMovies AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        COUNT(DISTINCT c.person_id) AS cast_count,\n        STRING_AGG(DISTINCT a.name, ', ') AS actor_names\n    FROM \n        aka_title t\n    JOIN \n        cast_info c ON t.id = c.movie_id\n    JOIN \n        aka_name a ON c.person_id = a.person_id\n    WHERE \n        t.kind_id IN (SELECT id FROM kind_type WHERE kind = 'movie')\n    GROUP BY \n        t.id, t.title, t.production_year\n),\n\nInfluentialMovies AS (\n    SELECT \n        rm.movie_id,\n        rm.title,\n        COUNT(DISTINCT mc.company_id) AS company_count,\n        STRING_AGG(DISTINCT mc.note, ', ') AS company_notes\n    FROM \n        RankedMovies rm\n    JOIN \n        movie_companies mc ON rm.movie_id = mc.movie_id\n    GROUP BY \n        rm.movie_id, rm.title\n),\n\nFinalResults AS (\n    SELECT \n        im.movie_id,\n        im.title,\n        im.company_count,\n        im.company_notes,\n        rm.cast_count,\n        rm.actor_names\n    FROM \n        InfluentialMovies im\n    JOIN \n        RankedMovies rm ON im.movie_id = rm.movie_id\n    WHERE \n        rm.cast_count > 10\n    ORDER BY \n        im.company_count DESC, rm.cast_count DESC\n)\n\nSELECT \n    fr.title,\n    at.production_year,\n    fr.company_count,\n    fr.actor_names,\n    fr.company_notes\nFROM \n    FinalResults fr\nJOIN \n    aka_title at ON fr.movie_id = at.id\nWHERE \n    at.production_year >= 2000\nLIMIT 100;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "25483.sql", "original_sql": "WITH movie_details AS (\n    SELECT\n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        k.keyword,\n        c.name AS company_name,\n        pt.kind AS company_type\n    FROM\n        aka_title t\n    LEFT JOIN movie_keyword mk ON t.id = mk.movie_id\n    LEFT JOIN keyword k ON mk.keyword_id = k.id\n    LEFT JOIN movie_companies mc ON t.id = mc.movie_id\n    LEFT JOIN company_name c ON mc.company_id = c.id\n    LEFT JOIN company_type pt ON mc.company_type_id = pt.id\n    WHERE\n        t.production_year >= 2000\n        AND k.keyword IS NOT NULL\n),\nactor_details AS (\n    SELECT\n        ca.movie_id,\n        a.name AS actor_name,\n        r.role AS actor_role\n    FROM\n        cast_info ca\n    JOIN aka_name a ON ca.person_id = a.person_id\n    JOIN role_type r ON ca.role_id = r.id\n),\nfinal_benchmark AS (\n    SELECT\n        md.movie_id,\n        md.title,\n        md.production_year,\n        ARRAY_AGG(DISTINCT md.keyword) AS keywords,\n        ARRAY_AGG(DISTINCT ad.actor_name) AS actors,\n        ARRAY_AGG(DISTINCT ad.actor_role) AS roles,\n        COUNT(DISTINCT md.company_name) AS company_count\n    FROM\n        movie_details md\n    LEFT JOIN actor_details ad ON md.movie_id = ad.movie_id\n    GROUP BY\n        md.movie_id, md.title, md.production_year\n)\nSELECT\n    fb.movie_id,\n    fb.title,\n    fb.production_year,\n    fb.keywords,\n    fb.actors,\n    fb.roles,\n    fb.company_count\nFROM\n    final_benchmark fb\nORDER BY\n    fb.production_year DESC, fb.title ASC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 145, in benchmark_distributed_only\n    results_match = _tables_exact_equal(dist_tbl, baseline_tbl, float_tol=0.0, ignore_column_order=True)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 74, in _tables_exact_equal\n    df1 = _arrow_to_pandas_normalized(t1)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 14, in _arrow_to_pandas_normalized\n    df = tbl.to_pandas(types_mapper=None)\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"pyarrow/array.pxi\", line 872, in pyarrow.lib._PandasConvertible.to_pandas\n  File \"pyarrow/table.pxi\", line 4904, in pyarrow.lib.Table._to_pandas\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/pyarrow/pandas_compat.py\", line 779, in table_to_dataframe\n    result = pa.lib.table_to_blocks(options, table, categories,\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"pyarrow/table.pxi\", line 3771, in pyarrow.lib.table_to_blocks\n  File \"pyarrow/error.pxi\", line 91, in pyarrow.lib.check_status\npyarrow.lib.ArrowNotImplementedError: Not implemented type for Arrow list to pandas: string_view\n", "engine_mem_mb": 500000}
{"query_id": "25486.sql", "original_sql": "\nWITH MovieData AS (\n    SELECT \n        t.title,\n        t.production_year,\n        t.kind_id,\n        a.name AS actor_name,\n        a.person_id,\n        COALESCE(SUM(CASE WHEN cc.role_id IS NOT NULL THEN 1 ELSE 0 END), 0) AS num_roles,\n        STRING_AGG(DISTINCT k.keyword, ', ') AS keywords,\n        COUNT(DISTINCT mc.company_id) AS num_production_companies\n    FROM \n        aka_title t\n    JOIN \n        cast_info cc ON t.id = cc.movie_id\n    JOIN \n        aka_name a ON cc.person_id = a.person_id\n    LEFT JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    LEFT JOIN \n        keyword k ON mk.keyword_id = k.id\n    LEFT JOIN \n        movie_companies mc ON t.id = mc.movie_id\n    WHERE \n        t.production_year >= 2000\n    GROUP BY \n        t.id, t.title, t.production_year, t.kind_id, a.name, a.person_id\n),\nProductionStats AS (\n    SELECT \n        md.production_year,\n        md.kind_id,\n        COUNT(DISTINCT md.title) AS total_movies,\n        COUNT(DISTINCT md.actor_name) AS unique_actors,\n        SUM(md.num_roles) AS total_roles,\n        SUM(md.num_production_companies) AS total_production_companies,\n        STRING_AGG(DISTINCT md.keywords, ', ') AS all_keywords\n    FROM \n        MovieData md\n    GROUP BY \n        md.production_year, md.kind_id\n)\nSELECT \n    ps.production_year,\n    kt.kind AS movie_kind,\n    ps.total_movies,\n    ps.unique_actors,\n    ps.total_roles,\n    ps.total_production_companies,\n    ps.all_keywords\nFROM \n    ProductionStats ps\nJOIN \n    kind_type kt ON ps.kind_id = kt.id\nORDER BY \n    ps.production_year DESC, \n    ps.total_movies DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    t.title,\n    t.production_year,\n    t.kind_id,\n    a.name AS actor_name,\n    a.person_id,\n    COALESCE(SUM(CASE WHEN cc.role_id IS NOT NULL THEN 1 ELSE 0 END), 0) AS num_roles,\n    STRING_AGG(DISTINCT k.keyword, ', ') AS keywords,\n    COUNT(DISTINCT mc.company_id) AS num_production_companies\nFROM \n    aka_title t\nJOIN \n    cast_info cc ON t.id = cc.movie_id\nJOIN \n    aka_name a ON cc.person_id = a.person_id\nLEFT JOIN \n    movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN \n    keyword k ON mk.keyword_id = k.id\nLEFT JOIN \n    movie_companies mc ON t.id = mc.movie_id\nWHERE \n    t.production_year >= 2000\nGROUP BY \n    t.id, t.title, t.production_year, t.kind_id, a.name, a.person_id;", "sql2": "SELECT \n    ps.production_year,\n    kt.kind AS movie_kind,\n    ps.total_movies,\n    ps.unique_actors,\n    ps.total_roles,\n    ps.total_production_companies,\n    ps.all_keywords\nFROM (\n    SELECT \n        s1.production_year,\n        s1.kind_id,\n        COUNT(DISTINCT s1.title) AS total_movies,\n        COUNT(DISTINCT s1.actor_name) AS unique_actors,\n        SUM(s1.num_roles) AS total_roles,\n        SUM(s1.num_production_companies) AS total_production_companies,\n        STRING_AGG(DISTINCT s1.keywords, ', ') AS all_keywords\n    FROM s1\n    GROUP BY s1.production_year, s1.kind_id\n) ps\nJOIN kind_type kt ON ps.kind_id = kt.id\nORDER BY ps.production_year DESC, ps.total_movies DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "25527.sql", "original_sql": "\nSELECT \n    ak.name AS actor_name,\n    COUNT(DISTINCT c.movie_id) AS total_movies,\n    STRING_AGG(DISTINCT t.title, ', ') AS movies_list,\n    COALESCE(AVG(CAST(m_info.info AS numeric)), 0) AS average_rating,\n    ARRAY_AGG(DISTINCT k.keyword) AS movie_keywords\nFROM \n    aka_name ak\nJOIN \n    cast_info c ON ak.person_id = c.person_id\nJOIN \n    title t ON c.movie_id = t.id\nLEFT JOIN \n    movie_info m_info ON t.id = m_info.movie_id AND m_info.info_type_id = (SELECT id FROM info_type WHERE info = 'rating')\nLEFT JOIN \n    movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    ak.name IS NOT NULL\n    AND t.production_year >= 2000\nGROUP BY \n    ak.name\nHAVING \n    COUNT(DISTINCT c.movie_id) > 5\nORDER BY \n    total_movies DESC\nLIMIT 10;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "25580.sql", "original_sql": "WITH RankedTitles AS (\n    SELECT \n        t.id AS title_id,\n        t.title,\n        t.production_year,\n        COUNT(ci.id) AS actor_count\n    FROM \n        title t\n    JOIN \n        movie_companies mc ON t.id = mc.movie_id\n    JOIN \n        cast_info ci ON t.id = ci.movie_id\n    GROUP BY \n        t.id, t.title, t.production_year\n),\nFilteredTitles AS (\n    SELECT \n        rt.title_id,\n        rt.title,\n        rt.production_year\n    FROM \n        RankedTitles rt\n    WHERE \n        rt.actor_count > 5\n),\nAkaNames AS (\n    SELECT \n        a.person_id,\n        a.name,\n        a.id\n    FROM \n        aka_name a\n    WHERE \n        a.name ILIKE '%Smith%'\n),\nSelectedMovies AS (\n    SELECT \n        ft.title_id,\n        ft.title,\n        ft.production_year\n    FROM \n        FilteredTitles ft\n    JOIN \n        movie_info mi ON ft.title_id = mi.movie_id\n    WHERE \n        mi.info ILIKE '%award%'\n)\nSELECT \n    sm.title,\n    sm.production_year,\n    an.name AS actor_name,\n    COUNT(DISTINCT mi.info_type_id) AS info_type_count\nFROM \n    SelectedMovies sm\nJOIN \n    cast_info ci ON sm.title_id = ci.movie_id\nJOIN \n    AkaNames an ON ci.person_id = an.person_id\nJOIN \n    movie_info mi ON sm.title_id = mi.movie_id\nGROUP BY \n    sm.title, sm.production_year, an.name\nORDER BY \n    sm.production_year DESC, actor_name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH RankedTitles AS (\n    SELECT t.id AS title_id,\n           t.title,\n           t.production_year,\n           COUNT(ci.id) AS actor_count\n    FROM title t\n    JOIN movie_companies mc ON t.id = mc.movie_id\n    JOIN cast_info ci ON t.id = ci.movie_id\n    GROUP BY t.id, t.title, t.production_year\n),\nFilteredTitles AS (\n    SELECT rt.title_id, rt.title, rt.production_year\n    FROM RankedTitles rt\n    WHERE rt.actor_count > 5\n)\nSELECT DISTINCT ft.title_id, ft.title, ft.production_year\nFROM FilteredTitles ft\nJOIN movie_info mi ON ft.title_id = mi.movie_id\nWHERE mi.info ILIKE '%award%';", "sql2": "WITH AkaNames AS (\n    SELECT person_id, name\n    FROM aka_name\n    WHERE name ILIKE '%Smith%'\n)\nSELECT \n    s1.title,\n    s1.production_year,\n    an.name AS actor_name,\n    COUNT(DISTINCT mi.info_type_id) AS info_type_count\nFROM s1\nJOIN cast_info ci ON s1.title_id = ci.movie_id\nJOIN AkaNames an ON ci.person_id = an.person_id\nJOIN movie_info mi ON s1.title_id = mi.movie_id\nGROUP BY s1.title, s1.production_year, an.name\nORDER BY s1.production_year DESC, actor_name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "25609.sql", "original_sql": "WITH RankedMovies AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        COUNT(c.id) AS cast_count,\n        STRING_AGG(DISTINCT a.name, ', ') AS actor_names\n    FROM \n        title t\n    LEFT JOIN \n        cast_info c ON t.id = c.movie_id\n    LEFT JOIN \n        aka_name a ON c.person_id = a.person_id\n    WHERE \n        t.production_year BETWEEN 1990 AND 2023\n    GROUP BY \n        t.id, t.title, t.production_year\n),\nKeywordStats AS (\n    SELECT \n        m.movie_id,\n        COUNT(k.id) AS keyword_count,\n        STRING_AGG(k.keyword, ', ') AS keywords\n    FROM \n        movie_keyword m\n    JOIN \n        keyword k ON m.keyword_id = k.id\n    GROUP BY \n        m.movie_id\n),\nFinalBenchmark AS (\n    SELECT \n        rm.movie_id,\n        rm.title,\n        rm.production_year,\n        rm.cast_count,\n        ks.keyword_count,\n        ks.keywords,\n        rm.actor_names\n    FROM \n        RankedMovies rm\n    LEFT JOIN \n        KeywordStats ks ON rm.movie_id = ks.movie_id\n)\nSELECT \n    *,\n    CASE \n        WHEN cast_count < 5 THEN 'Low'\n        WHEN cast_count BETWEEN 5 AND 10 THEN 'Medium'\n        ELSE 'High'\n    END AS cast_size_category\nFROM \n    FinalBenchmark\nORDER BY \n    production_year DESC, cast_count DESC;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "25645.sql", "original_sql": "WITH RankedMovies AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        k.keyword,\n        ROW_NUMBER() OVER (PARTITION BY t.id ORDER BY k.keyword) AS keyword_rank\n    FROM \n        aka_title t\n    JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    WHERE \n        t.production_year BETWEEN 2000 AND 2023\n),\nCastDetails AS (\n    SELECT \n        ci.movie_id,\n        a.name AS actor_name,\n        r.role AS role_name\n    FROM \n        cast_info ci\n    JOIN \n        aka_name a ON ci.person_id = a.person_id\n    JOIN \n        role_type r ON ci.role_id = r.id\n),\nMovieCompanies AS (\n    SELECT \n        mc.movie_id,\n        c.name AS company_name,\n        ct.kind AS company_type\n    FROM \n        movie_companies mc\n    JOIN \n        company_name c ON mc.company_id = c.id\n    JOIN \n        company_type ct ON mc.company_type_id = ct.id\n),\nCombinedData AS (\n    SELECT \n        rm.movie_id,\n        rm.title,\n        rm.production_year,\n        cd.actor_name,\n        cd.role_name,\n        comp.company_name,\n        comp.company_type,\n        rm.keyword\n    FROM \n        RankedMovies rm\n    LEFT JOIN \n        CastDetails cd ON rm.movie_id = cd.movie_id\n    LEFT JOIN \n        MovieCompanies comp ON rm.movie_id = comp.movie_id\n)\nSELECT \n    movie_id,\n    title,\n    production_year,\n    STRING_AGG(DISTINCT actor_name || ' (' || role_name || ')', ', ') AS actors,\n    STRING_AGG(DISTINCT company_name || ' (' || company_type || ')', ', ') AS production_companies,\n    STRING_AGG(DISTINCT keyword, ', ') AS keywords\nFROM \n    CombinedData\nGROUP BY \n    movie_id, title, production_year\nORDER BY \n    production_year DESC, title;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "25690.sql", "original_sql": "WITH movie_data AS (\n    SELECT \n        t.title AS movie_title,\n        t.production_year,\n        a.name AS actor_name,\n        r.role AS role,\n        m.name AS production_company,\n        k.keyword AS movie_keyword\n    FROM \n        aka_title t\n    JOIN \n        cast_info ci ON t.id = ci.movie_id\n    JOIN \n        aka_name a ON ci.person_id = a.person_id\n    JOIN \n        role_type r ON ci.role_id = r.id\n    JOIN \n        movie_companies mc ON t.id = mc.movie_id\n    JOIN \n        company_name m ON mc.company_id = m.id\n    LEFT JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    LEFT JOIN \n        keyword k ON mk.keyword_id = k.id\n    WHERE \n        t.production_year >= 2000 \n        AND a.name IS NOT NULL\n)\nSELECT \n    movie_title,\n    production_year,\n    STRING_AGG(DISTINCT actor_name, ', ') AS actors,\n    STRING_AGG(DISTINCT role, ', ') AS roles,\n    STRING_AGG(DISTINCT production_company, ', ') AS production_companies,\n    STRING_AGG(DISTINCT movie_keyword, ', ') AS keywords\nFROM \n    movie_data\nGROUP BY \n    movie_title, production_year\nORDER BY \n    production_year DESC, movie_title;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT \n    t.title AS movie_title,\n    t.production_year,\n    a.name AS actor_name,\n    r.role AS role,\n    m.name AS production_company,\n    k.keyword AS movie_keyword\nFROM aka_title t\nJOIN cast_info ci ON t.id = ci.movie_id\nJOIN aka_name a ON ci.person_id = a.person_id\nJOIN role_type r ON ci.role_id = r.id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_name m ON mc.company_id = m.id\nLEFT JOIN movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN keyword k ON mk.keyword_id = k.id\nWHERE t.production_year >= 2000\n  AND a.name IS NOT NULL;", "sql2": "SELECT \n    movie_title,\n    production_year,\n    STRING_AGG(DISTINCT actor_name, ', ') AS actors,\n    STRING_AGG(DISTINCT role, ', ') AS roles,\n    STRING_AGG(DISTINCT production_company, ', ') AS production_companies,\n    STRING_AGG(DISTINCT movie_keyword, ', ') AS keywords\nFROM s1\nGROUP BY movie_title, production_year\nORDER BY production_year DESC, movie_title;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "25807.sql", "original_sql": "WITH RankedMovies AS (\n    SELECT \n        m.id AS movie_id,\n        m.title,\n        m.production_year,\n        k.keyword AS keyword,\n        COALESCE(COUNT(DISTINCT c.person_id), 0) AS num_cast_members,\n        COALESCE(STRING_AGG(DISTINCT a.name, ', '), 'No Cast') AS cast_names\n    FROM \n        aka_title m\n    LEFT JOIN \n        movie_keyword mk ON m.id = mk.movie_id\n    LEFT JOIN \n        keyword k ON mk.keyword_id = k.id\n    LEFT JOIN \n        cast_info c ON m.id = c.movie_id\n    LEFT JOIN \n        aka_name a ON c.person_id = a.person_id\n    GROUP BY \n        m.id, m.title, m.production_year, k.keyword\n), \nKeywordCounts AS (\n    SELECT \n        keyword,\n        COUNT(movie_id) AS movie_count\n    FROM \n        RankedMovies\n    GROUP BY \n        keyword\n    HAVING \n        COUNT(movie_id) > 1\n),\nTopKeywords AS (\n    SELECT \n        keyword\n    FROM \n        KeywordCounts\n    ORDER BY \n        movie_count DESC\n    LIMIT 10\n)\nSELECT \n    rm.movie_id,\n    rm.title,\n    rm.production_year,\n    rm.keyword,\n    rm.num_cast_members,\n    rm.cast_names\nFROM \n    RankedMovies rm\nJOIN \n    TopKeywords tk ON rm.keyword = tk.keyword\nORDER BY \n    rm.production_year DESC, \n    rm.num_cast_members DESC;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "26114.sql", "original_sql": "WITH MovieDetails AS (\n    SELECT \n        t.title AS movie_title,\n        t.production_year,\n        t.id AS movie_id,\n        COUNT(DISTINCT c.person_id) AS cast_count,\n        STRING_AGG(DISTINCT a.name, ', ') AS cast_names,\n        STRING_AGG(DISTINCT k.keyword, ', ') AS keywords\n    FROM \n        aka_title t\n    LEFT JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    LEFT JOIN \n        keyword k ON mk.keyword_id = k.id\n    LEFT JOIN \n        cast_info c ON t.id = c.movie_id\n    LEFT JOIN \n        aka_name a ON c.person_id = a.person_id\n    WHERE \n        t.production_year BETWEEN 2000 AND 2020\n    GROUP BY \n        t.title, t.production_year, t.id\n),\nCompanyStatistics AS (\n    SELECT \n        m.movie_id,\n        COUNT(DISTINCT mc.company_id) AS company_count,\n        STRING_AGG(DISTINCT co.name, ', ') AS company_names\n    FROM \n        movie_companies mc\n    JOIN \n        company_name co ON mc.company_id = co.id\n    JOIN \n        MovieDetails m ON mc.movie_id = m.movie_id\n    GROUP BY \n        m.movie_id\n)\nSELECT \n    md.movie_title,\n    md.production_year,\n    md.cast_count,\n    md.cast_names,\n    cs.company_count,\n    cs.company_names\nFROM \n    MovieDetails md\nLEFT JOIN \n    CompanyStatistics cs ON md.movie_id = cs.movie_id\nORDER BY \n    md.production_year DESC, \n    md.cast_count DESC;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "26171.sql", "original_sql": "\nWITH movie_details AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        STRING_AGG(DISTINCT ak.name, ', ') AS aka_names,\n        STRING_AGG(DISTINCT k.keyword, ', ') AS keywords,\n        COUNT(cc.id) AS cast_count\n    FROM \n        aka_title t\n    LEFT JOIN \n        aka_name ak ON t.id = ak.id\n    LEFT JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    LEFT JOIN \n        keyword k ON mk.keyword_id = k.id\n    LEFT JOIN \n        complete_cast cc ON t.id = cc.movie_id\n    GROUP BY \n        t.id, t.title, t.production_year\n),\ncompany_details AS (\n    SELECT \n        mc.movie_id,\n        STRING_AGG(DISTINCT cn.name, ', ') AS company_names,\n        STRING_AGG(DISTINCT ct.kind, ', ') AS company_types\n    FROM \n        movie_companies mc\n    JOIN \n        company_name cn ON mc.company_id = cn.id\n    JOIN \n        company_type ct ON mc.company_type_id = ct.id\n    GROUP BY \n        mc.movie_id\n)\nSELECT \n    md.movie_id,\n    md.title,\n    md.production_year,\n    md.aka_names,\n    md.keywords,\n    md.cast_count,\n    cd.company_names,\n    cd.company_types\nFROM \n    movie_details md\nLEFT JOIN \n    company_details cd ON md.movie_id = cd.movie_id\nWHERE \n    md.production_year >= 2000\nORDER BY \n    md.production_year DESC, \n    md.cast_count DESC;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "26198.sql", "original_sql": "\nSELECT \n    t.title AS movie_title,\n    a.name AS actor_name,\n    r.role AS actor_role,\n    c.note AS casting_note,\n    t.production_year,\n    STRING_AGG(DISTINCT k.keyword, ',') AS keywords,\n    COUNT(DISTINCT mc.company_id) AS production_companies\nFROM\n    title t\nJOIN \n    movie_info mi ON t.id = mi.movie_id AND mi.info_type_id = (SELECT id FROM info_type WHERE info = 'summary')\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info c ON cc.subject_id = c.id\nJOIN \n    aka_name a ON c.person_id = a.person_id\nJOIN \n    role_type r ON c.role_id = r.id\nLEFT JOIN \n    movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN \n    keyword k ON mk.keyword_id = k.id\nLEFT JOIN \n    movie_companies mc ON t.id = mc.movie_id\nWHERE \n    t.production_year BETWEEN 2000 AND 2023\n    AND a.name LIKE '%Smith%'\nGROUP BY \n    t.title, a.name, r.role, c.note, t.production_year\nORDER BY \n    t.production_year DESC, t.title ASC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    t.id AS movie_id,\n    t.title AS movie_title,\n    a.name AS actor_name,\n    r.role AS actor_role,\n    c.note AS casting_note,\n    t.production_year\nFROM title t\nJOIN movie_info mi ON t.id = mi.movie_id AND mi.info_type_id = (SELECT id FROM info_type WHERE info = 'summary')\nJOIN complete_cast cc ON t.id = cc.movie_id\nJOIN cast_info c ON cc.subject_id = c.id\nJOIN aka_name a ON c.person_id = a.person_id\nJOIN role_type r ON c.role_id = r.id\nWHERE t.production_year BETWEEN 2000 AND 2023\n  AND a.name LIKE '%Smith%';", "sql2": "SELECT\n    s1.movie_title,\n    s1.actor_name,\n    s1.actor_role,\n    s1.casting_note,\n    s1.production_year,\n    STRING_AGG(DISTINCT k.keyword, ',') AS keywords,\n    COUNT(DISTINCT mc.company_id) AS production_companies\nFROM s1\nLEFT JOIN movie_keyword mk ON s1.movie_id = mk.movie_id\nLEFT JOIN keyword k ON mk.keyword_id = k.id\nLEFT JOIN movie_companies mc ON s1.movie_id = mc.movie_id\nGROUP BY s1.movie_title, s1.actor_name, s1.actor_role, s1.casting_note, s1.production_year\nORDER BY s1.production_year DESC, s1.movie_title ASC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "26212.sql", "original_sql": "WITH RankedMovies AS (\n    SELECT \n        a.id AS movie_id,\n        a.title AS movie_title,\n        a.production_year,\n        a.kind_id,\n        COUNT(ci.person_id) AS num_cast_members,\n        STRING_AGG(DISTINCT ak.name, ', ') AS all_aka_names\n    FROM \n        aka_title a\n    LEFT JOIN \n        cast_info ci ON ci.movie_id = a.movie_id\n    LEFT JOIN \n        aka_name ak ON ak.person_id = ci.person_id\n    GROUP BY \n        a.id, a.title, a.production_year, a.kind_id\n),\nMovieDetails AS (\n    SELECT \n        rm.movie_id,\n        rm.movie_title,\n        rm.production_year,\n        rt.role AS leading_role,\n        COUNT(mc.company_id) AS production_companies,\n        STRING_AGG(DISTINCT k.keyword, ', ') AS movie_keywords\n    FROM \n        RankedMovies rm\n    LEFT JOIN \n        complete_cast cc ON cc.movie_id = rm.movie_id\n    LEFT JOIN \n        role_type rt ON rt.id = cc.status_id\n    LEFT JOIN \n        movie_companies mc ON mc.movie_id = rm.movie_id\n    LEFT JOIN \n        movie_keyword mk ON mk.movie_id = rm.movie_id\n    LEFT JOIN \n        keyword k ON k.id = mk.keyword_id\n    GROUP BY \n        rm.movie_id, rm.movie_title, rm.production_year, rt.role\n),\nFinalOutput AS (\n    SELECT \n        md.movie_id,\n        md.movie_title,\n        md.production_year,\n        md.leading_role,\n        md.production_companies,\n        md.movie_keywords,\n        rm.num_cast_members,\n        rm.all_aka_names\n    FROM \n        MovieDetails md\n    JOIN \n        RankedMovies rm ON md.movie_id = rm.movie_id\n)\nSELECT \n    movie_id,\n    movie_title,\n    production_year,\n    leading_role,\n    production_companies,\n    num_cast_members,\n    movie_keywords,\n    all_aka_names\nFROM \n    FinalOutput\nORDER BY \n    production_year DESC, \n    num_cast_members DESC;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "2625.sql", "original_sql": "\nWITH RankedMovies AS (\n    SELECT \n        m.id AS movie_id,\n        m.title,\n        m.production_year,\n        ROW_NUMBER() OVER (PARTITION BY m.production_year ORDER BY m.id) AS rn\n    FROM \n        aka_title m\n    WHERE \n        m.kind_id = (SELECT id FROM kind_type WHERE kind = 'movie')\n),\nActorCounts AS (\n    SELECT \n        c.movie_id,\n        COUNT(DISTINCT c.person_id) AS actor_count\n    FROM \n        cast_info c\n    GROUP BY \n        c.movie_id\n),\nMovieWithActors AS (\n    SELECT \n        rm.movie_id,\n        rm.title,\n        rm.production_year,\n        ac.actor_count\n    FROM \n        RankedMovies rm\n    LEFT JOIN ActorCounts ac ON rm.movie_id = ac.movie_id\n)\nSELECT \n    mw.title,\n    mw.production_year,\n    COALESCE(mw.actor_count, 0) AS actor_count,\n    REPLACE(mw.title, ' ', '-') AS title_slug,\n    (SELECT \n        STRING_AGG(DISTINCT CONCAT(a.name, ' (', ci.role_id, ')'), ', ')\n     FROM \n        cast_info ci\n     JOIN \n        aka_name a ON ci.person_id = a.person_id\n     WHERE \n        ci.movie_id = mw.movie_id) AS actors\nFROM \n    MovieWithActors mw\nWHERE \n    COALESCE(mw.actor_count, 0) >= 5\nORDER BY \n    mw.production_year DESC, mw.title;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "26262.sql", "original_sql": "\nWITH RankedMovies AS (\n    SELECT \n        a.id AS movie_id,\n        a.title AS movie_title,\n        a.production_year,\n        COUNT(DISTINCT ci.person_id) AS cast_count,\n        STRING_AGG(DISTINCT an.name, ', ') AS cast_names\n    FROM \n        aka_title a\n    JOIN \n        cast_info ci ON a.id = ci.movie_id\n    JOIN \n        aka_name an ON ci.person_id = an.person_id\n    WHERE \n        a.production_year >= 2000\n    GROUP BY \n        a.id, a.title, a.production_year\n),\nMoviesWithKeywords AS (\n    SELECT \n        rm.movie_id,\n        rm.movie_title,\n        rm.production_year,\n        rm.cast_count,\n        rm.cast_names,\n        STRING_AGG(DISTINCT k.keyword, ', ') AS keywords\n    FROM \n        RankedMovies rm\n    LEFT JOIN \n        movie_keyword mk ON rm.movie_id = mk.movie_id\n    LEFT JOIN \n        keyword k ON mk.keyword_id = k.id\n    GROUP BY \n        rm.movie_id, rm.movie_title, rm.production_year, rm.cast_count, rm.cast_names\n),\nMoviesWithCompany AS (\n    SELECT \n        mwk.movie_id,\n        mwk.movie_title,\n        mwk.production_year,\n        mwk.cast_count,\n        mwk.cast_names,\n        mwk.keywords,\n        STRING_AGG(DISTINCT cn.name, ', ') AS companies\n    FROM \n        MoviesWithKeywords mwk\n    LEFT JOIN \n        movie_companies mc ON mwk.movie_id = mc.movie_id\n    LEFT JOIN \n        company_name cn ON mc.company_id = cn.id\n    GROUP BY \n        mwk.movie_id, mwk.movie_title, mwk.production_year, mwk.cast_count, mwk.cast_names, mwk.keywords\n)\nSELECT \n    mwc.movie_id,\n    mwc.movie_title,\n    mwc.production_year,\n    mwc.cast_count,\n    mwc.cast_names,\n    mwc.keywords,\n    mwc.companies\nFROM \n    MoviesWithCompany mwc\nORDER BY \n    mwc.production_year DESC,\n    mwc.cast_count DESC;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "26467.sql", "original_sql": "WITH MovieWithKeywords AS (\n    SELECT \n        m.id AS movie_id,\n        m.title,\n        k.keyword\n    FROM \n        title m\n    LEFT JOIN \n        movie_keyword mk ON m.id = mk.movie_id\n    LEFT JOIN \n        keyword k ON mk.keyword_id = k.id\n),\nMovieCast AS (\n    SELECT \n        m.id AS movie_id,\n        m.title,\n        a.name AS actor_name,\n        r.role AS role_name\n    FROM \n        title m\n    JOIN \n        complete_cast cc ON m.id = cc.movie_id\n    JOIN \n        cast_info c ON cc.subject_id = c.person_id\n    JOIN \n        aka_name a ON c.person_id = a.person_id\n    JOIN \n        role_type r ON c.role_id = r.id\n),\nCompanyInfo AS (\n    SELECT \n        mc.movie_id,\n        cn.name AS company_name,\n        ct.kind AS company_type\n    FROM \n        movie_companies mc\n    JOIN \n        company_name cn ON mc.company_id = cn.id\n    JOIN \n        company_type ct ON mc.company_type_id = ct.id\n)\nSELECT \n    mwk.movie_id,\n    mwk.title AS movie_title,\n    mwk.keyword AS movie_keyword,\n    mc.actor_name AS lead_actor,\n    mc.role_name AS actor_role,\n    ci.company_name,\n    ci.company_type\nFROM \n    MovieWithKeywords mwk\nJOIN \n    MovieCast mc ON mwk.movie_id = mc.movie_id\nJOIN \n    CompanyInfo ci ON mwk.movie_id = ci.movie_id\nWHERE \n    mwk.keyword LIKE '%action%' \n    AND mc.role_name = 'lead'\nORDER BY \n    mwk.movie_id;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    m.id AS movie_id,\n    m.title,\n    k.keyword,\n    cn.name AS company_name,\n    ct.kind AS company_type\nFROM title m\nLEFT JOIN movie_keyword mk ON m.id = mk.movie_id\nLEFT JOIN keyword k ON mk.keyword_id = k.id\nJOIN movie_companies mc ON m.id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN company_type ct ON mc.company_type_id = ct.id\nWHERE k.keyword LIKE '%action%';", "sql2": "SELECT \n    s1.movie_id,\n    s1.title AS movie_title,\n    s1.keyword AS movie_keyword,\n    mc.actor_name,\n    mc.role_name,\n    s1.company_name,\n    s1.company_type\nFROM s1\nJOIN (\n    SELECT \n        m.id AS movie_id,\n        a.name AS actor_name,\n        r.role AS role_name\n    FROM title m\n    JOIN complete_cast cc ON m.id = cc.movie_id\n    JOIN cast_info c ON cc.subject_id = c.person_id\n    JOIN aka_name a ON c.person_id = a.person_id\n    JOIN role_type r ON c.role_id = r.id\n    WHERE r.role = 'lead'\n) mc\nON s1.movie_id = mc.movie_id\nORDER BY s1.movie_id;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "26776.sql", "original_sql": "\nWITH movie_data AS (\n    SELECT \n        t.id AS movie_id,\n        t.title AS movie_title,\n        t.production_year,\n        ak.name AS actor_name,\n        ak.imdb_index AS actor_imdb_index,\n        STRING_AGG(DISTINCT kw.keyword, ', ') AS keywords\n    FROM \n        aka_title t\n    JOIN \n        cast_info c ON t.id = c.movie_id\n    JOIN \n        aka_name ak ON c.person_id = ak.person_id\n    LEFT JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    LEFT JOIN \n        keyword kw ON mk.keyword_id = kw.id\n    WHERE \n        t.production_year >= 2000\n        AND ak.name IS NOT NULL\n    GROUP BY \n        t.id, t.title, t.production_year, ak.name, ak.imdb_index\n),\ncompany_info AS (\n    SELECT \n        mc.movie_id,\n        STRING_AGG(DISTINCT cn.name, ', ') AS company_names,\n        STRING_AGG(DISTINCT ct.kind, ', ') AS company_types\n    FROM \n        movie_companies mc\n    JOIN \n        company_name cn ON mc.company_id = cn.id\n    JOIN \n        company_type ct ON mc.company_type_id = ct.id\n    GROUP BY \n        mc.movie_id\n)\nSELECT \n    md.movie_id,\n    md.movie_title,\n    md.production_year,\n    md.actor_name,\n    md.actor_imdb_index,\n    ci.company_names,\n    ci.company_types,\n    md.keywords\nFROM \n    movie_data md\nJOIN \n    company_info ci ON md.movie_id = ci.movie_id\nORDER BY \n    md.production_year DESC, \n    md.movie_title ASC\nLIMIT 100;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "26824.sql", "original_sql": "WITH movie_aggregates AS (\n    SELECT \n        mt.id AS movie_id,\n        mt.title, \n        mt.production_year,\n        COUNT(DISTINCT mc.company_id) AS total_companies,\n        STRING_AGG(DISTINCT cn.name, ', ') AS company_names,\n        COUNT(DISTINCT mk.keyword_id) AS total_keywords,\n        STRING_AGG(DISTINCT kw.keyword, ', ') AS keywords\n    FROM \n        aka_title mt\n    LEFT JOIN \n        movie_companies mc ON mt.id = mc.movie_id\n    LEFT JOIN \n        company_name cn ON mc.company_id = cn.id\n    LEFT JOIN \n        movie_keyword mk ON mt.id = mk.movie_id\n    LEFT JOIN \n        keyword kw ON mk.keyword_id = kw.id\n    WHERE \n        mt.production_year BETWEEN 2000 AND 2023\n    GROUP BY \n        mt.id, mt.title, mt.production_year\n),\nactor_aggregates AS (\n    SELECT \n        ak.person_id,\n        ak.name,\n        COUNT(DISTINCT ci.movie_id) AS total_movies,\n        STRING_AGG(DISTINCT mt.title, ', ') AS movies\n    FROM \n        aka_name ak\n    JOIN \n        cast_info ci ON ak.person_id = ci.person_id\n    JOIN \n        aka_title mt ON ci.movie_id = mt.id\n    GROUP BY \n        ak.person_id, ak.name\n)\nSELECT \n    ma.movie_id,\n    ma.title,\n    ma.production_year,\n    ma.total_companies,\n    ma.company_names,\n    ma.total_keywords,\n    ma.keywords,\n    aa.person_id,\n    aa.name AS actor_name,\n    aa.total_movies,\n    aa.movies\nFROM \n    movie_aggregates ma\nJOIN \n    cast_info ci ON ma.movie_id = ci.movie_id\nJOIN \n    actor_aggregates aa ON ci.person_id = aa.person_id\nORDER BY \n    ma.production_year DESC, ma.title;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "26895.sql", "original_sql": "WITH RankedMovies AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        COUNT(DISTINCT c.person_id) AS cast_count,\n        STRING_AGG(DISTINCT a.name, ', ') AS cast_names\n    FROM \n        aka_title t\n    JOIN \n        cast_info c ON t.id = c.movie_id\n    JOIN \n        aka_name a ON c.person_id = a.person_id\n    WHERE \n        t.production_year >= 2000\n    GROUP BY \n        t.id, t.title, t.production_year\n),\n\nKeywordedMovies AS (\n    SELECT \n        rm.movie_id,\n        rm.title,\n        rm.production_year,\n        rm.cast_count,\n        rm.cast_names,\n        COALESCE(STRING_AGG(DISTINCT k.keyword, ', '), 'No Keywords') AS keywords\n    FROM \n        RankedMovies rm\n    LEFT JOIN \n        movie_keyword mk ON rm.movie_id = mk.movie_id\n    LEFT JOIN \n        keyword k ON mk.keyword_id = k.id\n    GROUP BY \n        rm.movie_id, rm.title, rm.production_year, rm.cast_count, rm.cast_names\n),\n\nFinalActorsMovies AS (\n    SELECT \n        km.movie_id,\n        km.title,\n        km.production_year,\n        km.cast_count,\n        km.cast_names,\n        km.keywords,\n        COALESCE(ACTOR_ROLES.role_names, 'No Roles') AS actor_roles\n    FROM \n        KeywordedMovies km\n    LEFT JOIN (\n        SELECT \n            c.movie_id,\n            STRING_AGG(DISTINCT rt.role, ', ') AS role_names\n        FROM \n            cast_info c\n        JOIN \n            role_type rt ON c.role_id = rt.id\n        GROUP BY \n            c.movie_id\n    ) ACTOR_ROLES ON km.movie_id = ACTOR_ROLES.movie_id\n)\n\nSELECT \n    movie_id,\n    title,\n    production_year,\n    cast_count,\n    cast_names,\n    keywords,\n    actor_roles\nFROM \n    FinalActorsMovies\nORDER BY \n    production_year DESC, cast_count DESC\nLIMIT 50;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "27046.sql", "original_sql": "WITH RankedActors AS (\n    SELECT \n        a.name AS actor_name,\n        COUNT(DISTINCT c.movie_id) AS movie_count\n    FROM \n        aka_name a\n    JOIN \n        cast_info c ON a.person_id = c.person_id\n    JOIN \n        title t ON c.movie_id = t.id\n    WHERE \n        t.production_year BETWEEN 2000 AND 2009\n    GROUP BY \n        a.id, a.name\n    ORDER BY \n        movie_count DESC\n    LIMIT 10\n),\nMovieCompanies AS (\n    SELECT \n        mc.movie_id,\n        co.name AS company_name,\n        ct.kind AS company_type\n    FROM \n        movie_companies mc\n    JOIN \n        company_name co ON mc.company_id = co.id\n    JOIN \n        company_type ct ON mc.company_type_id = ct.id\n),\nActorRoles AS (\n    SELECT \n        a.name AS actor_name,\n        r.role AS actor_role,\n        c.movie_id\n    FROM \n        aka_name a\n    JOIN \n        cast_info c ON a.person_id = c.person_id\n    JOIN \n        role_type r ON c.role_id = r.id\n)\n\nSELECT \n    ra.actor_name,\n    ra.movie_count,\n    mc.company_name,\n    mc.company_type,\n    ar.actor_role\nFROM \n    RankedActors ra\nJOIN \n    ActorRoles ar ON ra.actor_name = ar.actor_name\nJOIN \n    MovieCompanies mc ON ar.movie_id = mc.movie_id\nORDER BY \n    ra.movie_count DESC, mc.company_name;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH RankedActors AS (\n    SELECT \n        a.name AS actor_name,\n        COUNT(DISTINCT c.movie_id) AS movie_count\n    FROM aka_name a\n    JOIN cast_info c ON a.person_id = c.person_id\n    JOIN title t ON c.movie_id = t.id\n    WHERE t.production_year BETWEEN 2000 AND 2009\n    GROUP BY a.id, a.name\n    ORDER BY movie_count DESC\n    LIMIT 10\n)\nSELECT actor_name, movie_count FROM RankedActors;", "sql2": "SELECT \n    s1.actor_name,\n    s1.movie_count,\n    co.name AS company_name,\n    ct.kind AS company_type,\n    rt.role AS actor_role\nFROM s1\nJOIN aka_name a ON a.name = s1.actor_name\nJOIN cast_info c ON a.person_id = c.person_id\nJOIN role_type rt ON c.role_id = rt.id\nJOIN movie_companies mc ON c.movie_id = mc.movie_id\nJOIN company_name co ON mc.company_id = co.id\nJOIN company_type ct ON mc.company_type_id = ct.id\nORDER BY s1.movie_count DESC, co.name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "27055.sql", "original_sql": "\nWITH RankedTitles AS (\n    SELECT \n        a.name AS aka_name,\n        t.title AS movie_title,\n        t.production_year,\n        ROW_NUMBER() OVER (PARTITION BY t.production_year ORDER BY LENGTH(t.title) DESC) AS title_rank\n    FROM \n        aka_name a\n    JOIN \n        cast_info ci ON a.person_id = ci.person_id\n    JOIN \n        aka_title t ON ci.movie_id = t.movie_id\n    WHERE \n        a.name IS NOT NULL\n),\nTitleSummary AS (\n    SELECT \n        production_year,\n        COUNT(*) AS title_count,\n        AVG(LENGTH(movie_title)) AS avg_title_length,\n        MAX(title_rank) AS max_rank\n    FROM \n        RankedTitles\n    GROUP BY \n        production_year\n)\nSELECT \n    ts.production_year,\n    ts.title_count,\n    ts.avg_title_length,\n    ct.kind AS company_type,\n    COUNT(DISTINCT mc.company_id) AS company_count\nFROM \n    TitleSummary ts\nJOIN \n    movie_companies mc ON ts.title_count > 0\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nWHERE \n    ts.production_year BETWEEN 2000 AND 2020\nGROUP BY \n    ts.production_year, ts.title_count, ts.avg_title_length, ct.kind\nORDER BY \n    ts.production_year ASC, ts.avg_title_length DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH RankedTitles AS (\n    SELECT \n        a.name AS aka_name,\n        t.title AS movie_title,\n        t.production_year,\n        ROW_NUMBER() OVER (PARTITION BY t.production_year ORDER BY LENGTH(t.title) DESC) AS title_rank\n    FROM aka_name a\n    JOIN cast_info ci ON a.person_id = ci.person_id\n    JOIN aka_title t ON ci.movie_id = t.movie_id\n    WHERE a.name IS NOT NULL\n)\nSELECT \n    production_year,\n    COUNT(*) AS title_count,\n    AVG(LENGTH(movie_title)) AS avg_title_length,\n    MAX(title_rank) AS max_rank\nFROM RankedTitles\nGROUP BY production_year", "sql2": "SELECT \n    s1.production_year,\n    s1.title_count,\n    s1.avg_title_length,\n    ct.kind AS company_type,\n    COUNT(DISTINCT mc.company_id) AS company_count\nFROM s1\nJOIN movie_companies mc ON s1.title_count > 0\nJOIN company_type ct ON mc.company_type_id = ct.id\nWHERE s1.production_year BETWEEN 2000 AND 2020\nGROUP BY s1.production_year, s1.title_count, s1.avg_title_length, ct.kind\nORDER BY s1.production_year ASC, s1.avg_title_length DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "27090.sql", "original_sql": "WITH RankedMovies AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        COUNT(DISTINCT c.person_id) AS num_cast_members,\n        STRING_AGG(DISTINCT a.name, ', ') AS cast_names\n    FROM \n        title t\n    JOIN \n        movie_companies mc ON mc.movie_id = t.id\n    JOIN \n        cast_info c ON c.movie_id = mc.movie_id\n    JOIN \n        aka_name a ON a.person_id = c.person_id\n    GROUP BY \n        t.id, t.title, t.production_year\n), FilteredMovies AS (\n    SELECT \n        movie_id,\n        title,\n        production_year,\n        num_cast_members,\n        cast_names\n    FROM \n        RankedMovies\n    WHERE \n        production_year BETWEEN 2000 AND 2023\n),\nMovieKeywords AS (\n    SELECT\n        m.movie_id,\n        STRING_AGG(k.keyword, ', ') AS keywords\n    FROM \n        movie_keyword mk\n    JOIN \n        keyword k ON k.id = mk.keyword_id\n    JOIN \n        FilteredMovies m ON m.movie_id = mk.movie_id\n    GROUP BY \n        m.movie_id\n)\nSELECT \n    f.movie_id,\n    f.title,\n    f.production_year,\n    f.num_cast_members,\n    f.cast_names,\n    mk.keywords\nFROM \n    FilteredMovies f\nLEFT JOIN \n    MovieKeywords mk ON f.movie_id = mk.movie_id\nORDER BY \n    f.num_cast_members DESC, \n    f.production_year DESC;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "27124.sql", "original_sql": "\nWITH actor_movie_info AS (\n    SELECT \n        a.id AS actor_id,\n        a.name AS actor_name,\n        t.title AS movie_title,\n        t.production_year,\n        STRING_AGG(DISTINCT k.keyword, ', ') AS keywords,\n        p.info AS actor_info\n    FROM aka_name a\n    JOIN cast_info ci ON a.person_id = ci.person_id\n    JOIN aka_title t ON ci.movie_id = t.movie_id\n    LEFT JOIN movie_keyword mk ON t.id = mk.movie_id\n    LEFT JOIN keyword k ON mk.keyword_id = k.id\n    LEFT JOIN person_info p ON a.person_id = p.person_id\n    WHERE t.production_year BETWEEN 2000 AND 2020\n    AND a.name LIKE '%Smith%'\n    GROUP BY a.id, a.name, t.title, t.production_year, p.info\n),\ncompany_movie_details AS (\n    SELECT \n        co.name AS company_name,\n        t.title AS movie_title,\n        t.production_year,\n        ct.kind AS company_type\n    FROM movie_companies mc\n    JOIN company_name co ON mc.company_id = co.id\n    JOIN aka_title t ON mc.movie_id = t.movie_id\n    JOIN company_type ct ON mc.company_type_id = ct.id\n    WHERE ct.kind = 'Production'\n    AND t.production_year > 2010\n),\nfinal_benchmark AS (\n    SELECT \n        ami.actor_id,\n        ami.actor_name,\n        ami.movie_title,\n        ami.production_year,\n        ami.keywords,\n        ami.actor_info,\n        cmd.company_name,\n        cmd.company_type\n    FROM actor_movie_info ami\n    JOIN company_movie_details cmd ON ami.movie_title = cmd.movie_title AND ami.production_year = cmd.production_year\n)\nSELECT \n    actor_name,\n    movie_title,\n    production_year,\n    keywords,\n    actor_info,\n    company_name,\n    company_type\nFROM final_benchmark\nORDER BY production_year DESC, actor_name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    a.id AS actor_id,\n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    STRING_AGG(DISTINCT k.keyword, ', ') AS keywords,\n    p.info AS actor_info\nFROM aka_name a\nJOIN cast_info ci ON a.person_id = ci.person_id\nJOIN aka_title t ON ci.movie_id = t.movie_id\nLEFT JOIN movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN keyword k ON mk.keyword_id = k.id\nLEFT JOIN person_info p ON a.person_id = p.person_id\nWHERE t.production_year BETWEEN 2000 AND 2020\n  AND a.name LIKE '%Smith%'\nGROUP BY a.id, a.name, t.title, t.production_year, p.info;", "sql2": "SELECT \n    s1.actor_id,\n    s1.actor_name,\n    s1.movie_title,\n    s1.production_year,\n    s1.keywords,\n    s1.actor_info,\n    cmd.company_name,\n    cmd.company_type\nFROM s1\nJOIN (\n    SELECT \n        co.name AS company_name,\n        t.title AS movie_title,\n        t.production_year,\n        ct.kind AS company_type\n    FROM movie_companies mc\n    JOIN company_name co ON mc.company_id = co.id\n    JOIN aka_title t ON mc.movie_id = t.movie_id\n    JOIN company_type ct ON mc.company_type_id = ct.id\n    WHERE ct.kind = 'Production'\n      AND t.production_year > 2010\n) cmd\nON s1.movie_title = cmd.movie_title\n   AND s1.production_year = cmd.production_year\nORDER BY s1.production_year DESC, s1.actor_name;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "27143.sql", "original_sql": "\nWITH MovieDetails AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        ARRAY_AGG(DISTINCT k.keyword) AS keywords,\n        ARRAY_AGG(DISTINCT c.name) AS companies,\n        ARRAY_AGG(DISTINCT a.name) AS actors\n    FROM \n        aka_title t\n    JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    JOIN \n        cast_info ci ON t.id = ci.movie_id\n    JOIN \n        aka_name a ON ci.person_id = a.person_id\n    JOIN \n        movie_companies mc ON t.id = mc.movie_id\n    JOIN \n        company_name c ON mc.company_id = c.id\n    GROUP BY \n        t.id, t.title, t.production_year\n),\nMovieInfo AS (\n    SELECT \n        md.movie_id,\n        md.title,\n        md.production_year,\n        md.keywords,\n        md.companies,\n        md.actors,\n        CASE \n            WHEN md.production_year < 2000 THEN 'Classic'\n            WHEN md.production_year BETWEEN 2000 AND 2010 THEN 'Modern'\n            ELSE 'Recent'\n        END AS era\n    FROM \n        MovieDetails md\n)\nSELECT \n    mi.movie_id,\n    mi.title,\n    mi.production_year,\n    mi.keywords,\n    mi.companies,\n    mi.actors,\n    mi.era,\n    COUNT(DISTINCT mi.actors) AS actor_count\nFROM \n    MovieInfo mi\nWHERE \n    mi.production_year >= 2010\nGROUP BY \n    mi.movie_id, mi.title, mi.production_year, mi.keywords, mi.companies, mi.actors, mi.era\nORDER BY \n    mi.production_year DESC, actor_count DESC;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "27256.sql", "original_sql": "WITH RankedMovies AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        COUNT(c.id) AS total_cast,\n        STRING_AGG(DISTINCT ak.name, ', ') AS cast_names\n    FROM \n        aka_title t\n    JOIN \n        cast_info c ON c.movie_id = t.id\n    JOIN \n        aka_name ak ON ak.person_id = c.person_id\n    GROUP BY \n        t.id, t.title, t.production_year\n), \n\nKeywordStats AS (\n    SELECT \n        mk.movie_id,\n        COUNT(DISTINCT k.keyword) AS keyword_count,\n        STRING_AGG(DISTINCT k.keyword, ', ') AS keywords\n    FROM \n        movie_keyword mk\n    JOIN \n        keyword k ON k.id = mk.keyword_id\n    GROUP BY \n        mk.movie_id\n), \n\nMovieDetails AS (\n    SELECT \n        rm.movie_id,\n        rm.title,\n        rm.production_year,\n        rm.total_cast,\n        rm.cast_names,\n        COALESCE(ks.keyword_count, 0) AS keyword_count,\n        COALESCE(ks.keywords, '') AS keywords\n    FROM \n        RankedMovies rm\n    LEFT JOIN \n        KeywordStats ks ON ks.movie_id = rm.movie_id\n)\n\nSELECT \n    md.movie_id,\n    md.title,\n    md.production_year,\n    md.total_cast,\n    md.cast_names,\n    md.keyword_count,\n    md.keywords\nFROM \n    MovieDetails md\nWHERE \n    md.production_year BETWEEN 2000 AND 2020\nORDER BY \n    md.production_year DESC, \n    md.total_cast DESC\nLIMIT 10;", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "27325.sql", "original_sql": "\nWITH movie_data AS (\n    SELECT\n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        STRING_AGG(DISTINCT ak.name, ',') AS aliases,\n        STRING_AGG(DISTINCT k.keyword, ',') AS keywords,\n        COUNT(DISTINCT mc.company_id) AS company_count,\n        COUNT(DISTINCT c.person_id) AS cast_count\n    FROM\n        aka_title t\n    LEFT JOIN\n        aka_name ak ON ak.person_id = t.id\n    LEFT JOIN\n        movie_keyword mk ON mk.movie_id = t.id\n    LEFT JOIN\n        keyword k ON k.id = mk.keyword_id\n    LEFT JOIN\n        movie_companies mc ON mc.movie_id = t.id\n    LEFT JOIN\n        cast_info c ON c.movie_id = t.id\n    WHERE\n        t.production_year >= 2000\n    GROUP BY\n        t.id, t.title, t.production_year\n)\n\nSELECT \n    md.movie_id,\n    md.title,\n    md.production_year,\n    COALESCE(md.aliases, 'No aliases available') AS aliases,\n    COALESCE(md.keywords, 'No keywords available') AS keywords,\n    md.company_count,\n    md.cast_count,\n    CASE\n        WHEN md.cast_count > 10 THEN 'Large Cast'\n        WHEN md.cast_count BETWEEN 5 AND 10 THEN 'Medium Cast'\n        ELSE 'Small Cast'\n    END AS cast_size\nFROM \n    movie_data md\nWHERE \n    md.company_count > 0\nORDER BY \n    md.production_year DESC, md.cast_count DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS movie_id, t.title, t.production_year, STRING_AGG(DISTINCT ak.name, ',') AS aliases, STRING_AGG(DISTINCT k.keyword, ',') AS keywords, COUNT(DISTINCT mc.company_id) AS company_count, COUNT(DISTINCT c.person_id) AS cast_count FROM aka_title t LEFT JOIN aka_name ak ON ak.person_id = t.id LEFT JOIN movie_keyword mk ON mk.movie_id = t.id LEFT JOIN keyword k ON k.id = mk.keyword_id LEFT JOIN movie_companies mc ON mc.movie_id = t.id LEFT JOIN cast_info c ON c.movie_id = t.id WHERE t.production_year >= 2000 GROUP BY t.id, t.title, t.production_year", "sql2": "SELECT md.movie_id, md.title, md.production_year, COALESCE(md.aliases, 'No aliases available') AS aliases, COALESCE(md.keywords, 'No keywords available') AS keywords, md.company_count, md.cast_count, CASE WHEN md.cast_count > 10 THEN 'Large Cast' WHEN md.cast_count BETWEEN 5 AND 10 THEN 'Medium Cast' ELSE 'Small Cast' END AS cast_size FROM s1 md WHERE md.company_count > 0 ORDER BY md.production_year DESC, md.cast_count DESC", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "27333.sql", "original_sql": "\nWITH MovieDetails AS (\n    SELECT \n        t.title AS movie_title,\n        t.production_year,\n        STRING_AGG(a.name, ', ') AS actors,\n        STRING_AGG(c.kind, ', ') AS company_types,\n        STRING_AGG(k.keyword, ', ') AS keywords\n    FROM \n        aka_title t\n    JOIN \n        cast_info ci ON t.id = ci.movie_id\n    JOIN \n        aka_name a ON ci.person_id = a.person_id\n    JOIN \n        movie_companies mc ON t.id = mc.movie_id\n    JOIN \n        company_type c ON mc.company_type_id = c.id\n    JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    GROUP BY \n        t.id, t.title, t.production_year\n),\nFilteredMovies AS (\n    SELECT \n        movie_title,\n        production_year,\n        actors,\n        company_types,\n        keywords\n    FROM \n        MovieDetails\n    WHERE \n        production_year >= 2000 AND\n        LOWER(actors) LIKE '%john%' \n)\nSELECT \n    movie_title,\n    production_year,\n    actors,\n    company_types,\n    keywords\nFROM \n    FilteredMovies\nORDER BY \n    production_year DESC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "WITH candidate_movies AS (\n    SELECT DISTINCT t.id AS movie_id\n    FROM aka_title t\n    JOIN cast_info ci ON t.id = ci.movie_id\n    JOIN aka_name a ON ci.person_id = a.person_id\n    WHERE t.production_year >= 2000\n      AND LOWER(a.name) LIKE '%john%'\n)\nSELECT movie_id FROM candidate_movies;", "sql2": "WITH MovieDetails AS (\n    SELECT \n        t.title AS movie_title,\n        t.production_year,\n        STRING_AGG(DISTINCT a.name, ', ') AS actors,\n        STRING_AGG(DISTINCT c.kind, ', ') AS company_types,\n        STRING_AGG(DISTINCT k.keyword, ', ') AS keywords\n    FROM \n        aka_title t\n    JOIN \n        cast_info ci ON t.id = ci.movie_id\n    JOIN \n        aka_name a ON ci.person_id = a.person_id\n    JOIN \n        movie_companies mc ON t.id = mc.movie_id\n    JOIN \n        company_type c ON mc.company_type_id = c.id\n    JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    JOIN \n        s1 ON t.id = s1.movie_id\n    GROUP BY \n        t.id, t.title, t.production_year\n)\nSELECT \n    movie_title,\n    production_year,\n    actors,\n    company_types,\n    keywords\nFROM \n    MovieDetails\nORDER BY \n    production_year DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "27530.sql", "original_sql": "\nWITH MovieDetails AS (\n    SELECT\n        t.id AS movie_id,\n        t.title AS movie_title,\n        t.production_year,\n        STRING_AGG(DISTINCT co.name, ', ') AS companies,\n        STRING_AGG(DISTINCT k.keyword, ', ') AS keywords\n    FROM \n        aka_title t\n    LEFT JOIN \n        movie_companies mc ON t.id = mc.movie_id\n    LEFT JOIN \n        company_name co ON mc.company_id = co.id\n    LEFT JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    LEFT JOIN \n        keyword k ON mk.keyword_id = k.id\n    GROUP BY \n        t.id, t.title, t.production_year\n),\nCastDetails AS (\n    SELECT\n        ci.movie_id,\n        STRING_AGG(DISTINCT a.name, ', ') AS cast_names,\n        STRING_AGG(DISTINCT rt.role, ', ') AS roles\n    FROM \n        cast_info ci\n    LEFT JOIN \n        aka_name a ON ci.person_id = a.person_id\n    LEFT JOIN \n        role_type rt ON ci.role_id = rt.id\n    GROUP BY \n        ci.movie_id\n)\nSELECT\n    md.movie_id,\n    md.movie_title,\n    md.production_year,\n    md.companies,\n    md.keywords,\n    cd.cast_names,\n    cd.roles\nFROM \n    MovieDetails md\nLEFT JOIN \n    CastDetails cd ON md.movie_id = cd.movie_id\nWHERE \n    md.production_year >= 2000\nORDER BY \n    md.production_year DESC, md.movie_title ASC;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "27550.sql", "original_sql": "\nWITH MovieTitleInfo AS (\n    SELECT \n        t.id AS title_id,\n        t.title,\n        t.production_year,\n        STRING_AGG(DISTINCT k.keyword, ', ') AS keywords,\n        STRING_AGG(DISTINCT co.name, ', ') AS companies\n    FROM \n        aka_title t\n    LEFT JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    LEFT JOIN \n        keyword k ON k.id = mk.keyword_id\n    LEFT JOIN \n        movie_companies mc ON t.id = mc.movie_id\n    LEFT JOIN \n        company_name co ON mc.company_id = co.id\n    GROUP BY \n        t.id, t.title, t.production_year\n), \nPersonRoleInfo AS (\n    SELECT \n        c.movie_id,\n        a.name AS actor_name,\n        r.role AS role,\n        COUNT(c.person_id) AS role_count\n    FROM \n        cast_info c\n    JOIN \n        aka_name a ON c.person_id = a.person_id\n    JOIN \n        role_type r ON c.role_id = r.id\n    GROUP BY \n        c.movie_id, a.name, r.role\n)\nSELECT \n    m.title,\n    m.production_year,\n    m.keywords,\n    m.companies,\n    p.actor_name,\n    p.role,\n    p.role_count\nFROM \n    MovieTitleInfo m\nLEFT JOIN \n    PersonRoleInfo p ON m.title_id = p.movie_id\nWHERE \n    m.production_year BETWEEN 2000 AND 2023\nORDER BY \n    m.production_year DESC, \n    p.role_count DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS title_id, t.title, t.production_year, STRING_AGG(DISTINCT k.keyword, ', ') AS keywords, STRING_AGG(DISTINCT co.name, ', ') AS companies FROM aka_title t LEFT JOIN movie_keyword mk ON t.id = mk.movie_id LEFT JOIN keyword k ON k.id = mk.keyword_id LEFT JOIN movie_companies mc ON t.id = mc.movie_id LEFT JOIN company_name co ON mc.company_id = co.id WHERE t.production_year BETWEEN 2000 AND 2023 GROUP BY t.id, t.title, t.production_year", "sql2": "WITH PersonRoleInfo AS ( SELECT c.movie_id, a.name AS actor_name, r.role AS role, COUNT(*) AS role_count FROM cast_info c JOIN aka_name a ON c.person_id = a.person_id JOIN role_type r ON c.role_id = r.id GROUP BY c.movie_id, a.name, r.role ) SELECT s.title, s.production_year, s.keywords, s.companies, p.actor_name, p.role, p.role_count FROM s1 s LEFT JOIN PersonRoleInfo p ON s.title_id = p.movie_id ORDER BY s.production_year DESC, p.role_count DESC", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "27625.sql", "original_sql": "\nWITH RecentMovies AS (\n    SELECT \n        title.id AS movie_id,\n        title.title AS movie_title,\n        title.production_year,\n        KIND.kind AS movie_kind\n    FROM \n        title\n    JOIN \n        kind_type AS KIND ON title.kind_id = KIND.id\n    WHERE \n        title.production_year >= 2020\n), \nCastAndRoles AS (\n    SELECT \n        C.movie_id,\n        A.name AS actor_name,\n        R.role AS role_type\n    FROM \n        cast_info AS C\n    JOIN \n        aka_name AS A ON C.person_id = A.person_id\n    JOIN \n        role_type AS R ON C.role_id = R.id\n), \nKeywordMovies AS (\n    SELECT \n        MK.movie_id,\n        STRING_AGG(K.keyword, ', ') AS keywords\n    FROM \n        movie_keyword AS MK\n    JOIN \n        keyword AS K ON MK.keyword_id = K.id\n    GROUP BY \n        MK.movie_id\n), \nCompanyMovies AS (\n    SELECT \n        MC.movie_id,\n        STRING_AGG(CN.name, ', ') AS companies\n    FROM \n        movie_companies AS MC\n    JOIN \n        company_name AS CN ON MC.company_id = CN.id\n    GROUP BY \n        MC.movie_id\n)\nSELECT \n    RM.movie_title,\n    RM.production_year,\n    RM.movie_kind,\n    CAR.actor_name,\n    CAR.role_type,\n    KM.keywords,\n    CM.companies\nFROM \n    RecentMovies AS RM\nLEFT JOIN \n    CastAndRoles AS CAR ON RM.movie_id = CAR.movie_id\nLEFT JOIN \n    KeywordMovies AS KM ON RM.movie_id = KM.movie_id\nLEFT JOIN \n    CompanyMovies AS CM ON RM.movie_id = CM.movie_id\nORDER BY \n    RM.production_year DESC, \n    RM.movie_title;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "27626.sql", "original_sql": "\nWITH MovieDetails AS (\n    SELECT \n        t.title AS movie_title,\n        t.production_year,\n        a.name AS actor_name,\n        a.id AS actor_id,\n        STRING_AGG(DISTINCT k.keyword, ', ') AS keywords,\n        STRING_AGG(DISTINCT c.kind, ', ') AS company_types\n    FROM \n        aka_title AS t\n    JOIN \n        cast_info AS ci ON t.id = ci.movie_id\n    JOIN \n        aka_name AS a ON ci.person_id = a.person_id\n    LEFT JOIN \n        movie_keyword AS mk ON t.id = mk.movie_id\n    LEFT JOIN \n        keyword AS k ON mk.keyword_id = k.id\n    LEFT JOIN \n        movie_companies AS mc ON t.id = mc.movie_id\n    LEFT JOIN \n        company_type AS c ON mc.company_type_id = c.id \n    WHERE \n        t.production_year >= 2000 \n    GROUP BY \n        t.title, t.production_year, a.name, a.id\n),\nActorCount AS (\n    SELECT \n        actor_id,\n        COUNT(*) AS movie_count\n    FROM \n        MovieDetails\n    GROUP BY \n        actor_id\n),\nTopActors AS (\n    SELECT \n        md.actor_name,\n        ac.movie_count,\n        md.keywords,\n        md.company_types\n    FROM \n        MovieDetails md\n    JOIN \n        ActorCount ac ON md.actor_id = ac.actor_id\n    ORDER BY \n        ac.movie_count DESC\n    LIMIT 10 \n)\nSELECT \n    actor_name,\n    movie_count,\n    keywords,\n    company_types\nFROM \n    TopActors;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    t.title AS movie_title,\n    t.production_year,\n    a.name AS actor_name,\n    a.id AS actor_id,\n    STRING_AGG(DISTINCT k.keyword, ', ') AS keywords,\n    STRING_AGG(DISTINCT c.kind, ', ') AS company_types\nFROM \n    aka_title AS t\nJOIN \n    cast_info AS ci ON t.id = ci.movie_id\nJOIN \n    aka_name AS a ON ci.person_id = a.person_id\nLEFT JOIN \n    movie_keyword AS mk ON t.id = mk.movie_id\nLEFT JOIN \n    keyword AS k ON mk.keyword_id = k.id\nLEFT JOIN \n    movie_companies AS mc ON t.id = mc.movie_id\nLEFT JOIN \n    company_type AS c ON mc.company_type_id = c.id \nWHERE \n    t.production_year >= 2000 \nGROUP BY \n    t.title, t.production_year, a.name, a.id;", "sql2": "WITH ActorCount AS (\n    SELECT \n        actor_id,\n        COUNT(*) AS movie_count\n    FROM \n        s1\n    GROUP BY \n        actor_id\n),\nTopActors AS (\n    SELECT \n        md.actor_name,\n        ac.movie_count,\n        md.keywords,\n        md.company_types\n    FROM \n        s1 md\n    JOIN \n        ActorCount ac ON md.actor_id = ac.actor_id\n    ORDER BY \n        ac.movie_count DESC\n    LIMIT 10 \n)\nSELECT \n    actor_name,\n    movie_count,\n    keywords,\n    company_types\nFROM \n    TopActors;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "27679.sql", "original_sql": "\nWITH ranked_movies AS (\n    SELECT \n        title.id AS movie_id,\n        title.title,\n        title.production_year,\n        COUNT(DISTINCT cast_info.person_id) AS cast_count,\n        STRING_AGG(DISTINCT aka_name.name, ', ') AS cast_names\n    FROM \n        title\n    JOIN \n        movie_companies ON title.id = movie_companies.movie_id\n    JOIN \n        cast_info ON movie_companies.movie_id = cast_info.movie_id\n    JOIN \n        aka_name ON cast_info.person_id = aka_name.person_id\n    WHERE \n        title.production_year >= 2000\n    GROUP BY \n        title.id, title.title, title.production_year\n),\nfiltered_keywords AS (\n    SELECT \n        movie_keyword.movie_id,\n        STRING_AGG(keyword.keyword, ', ') AS keywords\n    FROM \n        movie_keyword\n    JOIN \n        keyword ON movie_keyword.keyword_id = keyword.id\n    GROUP BY \n        movie_keyword.movie_id\n),\nfinal_benchmark AS (\n    SELECT \n        rm.movie_id,\n        rm.title,\n        rm.production_year,\n        rm.cast_count,\n        rm.cast_names,\n        fk.keywords\n    FROM \n        ranked_movies rm\n    LEFT JOIN \n        filtered_keywords fk ON rm.movie_id = fk.movie_id\n)\nSELECT \n    movie_id,\n    title,\n    production_year,\n    cast_count,\n    cast_names,\n    keywords\nFROM \n    final_benchmark\nWHERE \n    cast_count > 5\nORDER BY \n    production_year DESC, cast_count DESC\nLIMIT 100;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "27722.sql", "original_sql": "WITH RankedMovies AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        COUNT(DISTINCT ci.person_id) AS cast_count\n    FROM \n        title t\n    JOIN \n        complete_cast cc ON t.id = cc.movie_id\n    JOIN \n        cast_info ci ON cc.subject_id = ci.id\n    GROUP BY \n        t.id, t.title, t.production_year\n),\n\nMovieKeywords AS (\n    SELECT \n        mk.movie_id,\n        STRING_AGG(k.keyword, ', ') AS keywords\n    FROM \n        movie_keyword mk\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    GROUP BY \n        mk.movie_id\n),\n\nTopMovies AS (\n    SELECT \n        rm.movie_id,\n        rm.title,\n        rm.production_year,\n        rm.cast_count,\n        COALESCE(mk.keywords, 'No Keywords') AS keywords\n    FROM \n        RankedMovies rm\n    LEFT JOIN \n        MovieKeywords mk ON rm.movie_id = mk.movie_id\n    ORDER BY \n        rm.cast_count DESC\n    LIMIT 10\n)\n\nSELECT \n    m.movie_id,\n    m.title,\n    m.production_year,\n    m.cast_count,\n    m.keywords,\n    COUNT(DISTINCT ci.person_id) AS unique_actors\nFROM \n    TopMovies m\nJOIN \n    complete_cast cc ON m.movie_id = cc.movie_id\nJOIN \n    cast_info ci ON cc.subject_id = ci.id\nGROUP BY \n    m.movie_id, m.title, m.production_year, m.cast_count, m.keywords\nHAVING \n    COUNT(DISTINCT ci.person_id) > 5;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "27734.sql", "original_sql": "\nWITH movie_data AS (\n    SELECT \n        a.id AS movie_id,\n        a.title,\n        a.production_year,\n        STRING_AGG(DISTINCT k.keyword, ', ') AS keywords,\n        STRING_AGG(DISTINCT ct.kind, ', ') AS company_types,\n        STRING_AGG(DISTINCT cn.name, ', ') AS companies,\n        STRING_AGG(DISTINCT p.name, ', ') AS cast_members\n    FROM \n        aka_title a\n    LEFT JOIN \n        movie_keyword mk ON a.id = mk.movie_id\n    LEFT JOIN \n        keyword k ON mk.keyword_id = k.id\n    LEFT JOIN \n        movie_companies mc ON a.id = mc.movie_id\n    LEFT JOIN \n        company_name cn ON mc.company_id = cn.id\n    LEFT JOIN \n        company_type ct ON mc.company_type_id = ct.id\n    LEFT JOIN \n        complete_cast c ON a.id = c.movie_id\n    LEFT JOIN \n        name p ON c.subject_id = p.id\n    WHERE \n        a.production_year >= 2000\n    GROUP BY \n        a.id, a.title, a.production_year\n),\ninfo_data AS (\n    SELECT \n        mi.movie_id,\n        STRING_AGG(DISTINCT it.info, ', ') AS info_details\n    FROM \n        movie_info mi\n    JOIN \n        info_type it ON mi.info_type_id = it.id\n    GROUP BY \n        mi.movie_id\n)\nSELECT \n    md.movie_id,\n    md.title,\n    md.production_year,\n    md.keywords,\n    md.company_types,\n    md.companies,\n    md.cast_members,\n    COALESCE(id.info_details, 'No additional info') AS info_details\nFROM \n    movie_data md\nLEFT JOIN \n    info_data id ON md.movie_id = id.movie_id\nORDER BY \n    md.production_year DESC, \n    md.title;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "27864.sql", "original_sql": "WITH ActorMovies AS (\n    SELECT \n        a.id AS actor_id,\n        a.name AS actor_name,\n        t.title AS movie_title,\n        t.production_year AS year,\n        COUNT(c.id) AS role_count\n    FROM \n        aka_name a\n    JOIN \n        cast_info c ON a.person_id = c.person_id\n    JOIN \n        aka_title t ON c.movie_id = t.movie_id\n    WHERE \n        a.name IS NOT NULL\n    GROUP BY \n        a.id, a.name, t.title, t.production_year\n),\nTopActors AS (\n    SELECT \n        actor_id,\n        actor_name,\n        SUM(role_count) AS total_roles\n    FROM \n        ActorMovies\n    GROUP BY \n        actor_id, actor_name\n    ORDER BY \n        total_roles DESC\n    LIMIT 10\n)\nSELECT \n    ta.actor_id,\n    ta.actor_name,\n    am.movie_title,\n    am.year,\n    am.role_count\nFROM \n    TopActors ta\nJOIN \n    ActorMovies am ON ta.actor_id = am.actor_id\nORDER BY \n    ta.total_roles DESC, am.year DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT a.id AS actor_id,\n       a.name AS actor_name,\n       t.title AS movie_title,\n       t.production_year AS year,\n       COUNT(c.id) AS role_count\nFROM   aka_name a\nJOIN   cast_info c ON a.person_id = c.person_id\nJOIN   aka_title t ON c.movie_id = t.movie_id\nWHERE  a.name IS NOT NULL\nGROUP BY a.id, a.name, t.title, t.production_year;", "sql2": "WITH TopActors AS (\n    SELECT actor_id,\n           actor_name,\n           SUM(role_count) AS total_roles\n    FROM   s1\n    GROUP BY actor_id, actor_name\n    ORDER BY total_roles DESC\n    LIMIT 10\n)\nSELECT ta.actor_id,\n       ta.actor_name,\n       s1.movie_title,\n       s1.year,\n       s1.role_count\nFROM   TopActors ta\nJOIN   s1 ON ta.actor_id = s1.actor_id\nORDER BY ta.total_roles DESC,\n         s1.year DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "27902.sql", "original_sql": "WITH NameAgg AS (\n  SELECT \n    ak.person_id,\n    STRING_AGG(DISTINCT ak.name, ', ') AS ak_names,\n    STRING_AGG(DISTINCT c.name, ', ') AS char_names\n  FROM\n    aka_name ak\n  LEFT JOIN\n    cast_info ca ON ak.person_id = ca.person_id\n  LEFT JOIN\n    char_name c ON ca.person_id = c.imdb_id\n  GROUP BY \n    ak.person_id\n),\nMovieAgg AS (\n  SELECT \n    m.id AS movie_id,\n    m.title AS movie_title,\n    STRING_AGG(DISTINCT co.name, ', ') AS production_companies,\n    STRING_AGG(DISTINCT k.keyword, ', ') AS keywords\n  FROM \n    aka_title m\n  LEFT JOIN \n    movie_companies mc ON m.id = mc.movie_id\n  LEFT JOIN \n    company_name co ON mc.company_id = co.id\n  LEFT JOIN \n    movie_keyword mk ON m.id = mk.movie_id\n  LEFT JOIN \n    keyword k ON mk.keyword_id = k.id\n  GROUP BY \n    m.id, m.title\n)\nSELECT \n  na.ak_names,\n  na.char_names,\n  ma.movie_id,\n  ma.movie_title,\n  ma.production_companies,\n  ma.keywords\nFROM \n  NameAgg na\nJOIN \n  cast_info ca ON na.person_id = ca.person_id\nJOIN \n  MovieAgg ma ON ca.movie_id = ma.movie_id\nWHERE \n  ma.movie_title ILIKE '%adventure%'\nORDER BY \n  ma.movie_title ASC;", "status": "timeout", "exitcode": -15, "signal": 15, "engine_mem_mb": 500000}
{"query_id": "27910.sql", "original_sql": "WITH RankedMovies AS (\n    SELECT \n        t.id AS title_id,\n        t.title,\n        t.production_year,\n        a.name AS actor_name,\n        ROW_NUMBER() OVER (PARTITION BY t.id ORDER BY ci.nr_order) AS role_rank\n    FROM \n        aka_title t\n    JOIN \n        cast_info ci ON t.id = ci.movie_id\n    JOIN \n        aka_name a ON ci.person_id = a.person_id\n    WHERE \n        t.production_year >= 2000\n        AND t.kind_id IN (SELECT id FROM kind_type WHERE kind IN ('movie', 'tv series'))\n),\nMoviesWithKeywords AS (\n    SELECT \n        rm.title_id,\n        rm.title,\n        rm.production_year,\n        STRING_AGG(k.keyword, ', ') AS keywords\n    FROM \n        RankedMovies rm\n    JOIN \n        movie_keyword mk ON rm.title_id = mk.movie_id\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    GROUP BY \n        rm.title_id, rm.title, rm.production_year\n),\nActorsByMovie AS (\n    SELECT \n        rm.title_id,\n        STRING_AGG(DISTINCT rm.actor_name, ', ') AS actor_names\n    FROM \n        RankedMovies rm\n    GROUP BY \n        rm.title_id\n)\n\nSELECT \n    m.title_id,\n    m.title,\n    m.production_year,\n    a.actor_names,\n    m.keywords\nFROM \n    MoviesWithKeywords m\nJOIN \n    ActorsByMovie a ON m.title_id = a.title_id\nORDER BY \n    m.production_year DESC, \n    m.title;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT \n    t.id AS title_id,\n    t.title,\n    t.production_year,\n    a.name AS actor_name,\n    ROW_NUMBER() OVER (PARTITION BY t.id ORDER BY ci.nr_order) AS role_rank\nFROM aka_title t\nJOIN cast_info ci ON t.id = ci.movie_id\nJOIN aka_name a ON ci.person_id = a.person_id\nWHERE t.production_year >= 2000\n  AND t.kind_id IN (SELECT id FROM kind_type WHERE kind IN ('movie', 'tv series'))", "sql2": "WITH MoviesWithKeywords AS (\n    SELECT \n        s1.title_id,\n        s1.title,\n        s1.production_year,\n        STRING_AGG(k.keyword, ', ') AS keywords\n    FROM s1\n    JOIN movie_keyword mk ON s1.title_id = mk.movie_id\n    JOIN keyword k ON mk.keyword_id = k.id\n    GROUP BY s1.title_id, s1.title, s1.production_year\n),\nActorsByMovie AS (\n    SELECT \n        s1.title_id,\n        STRING_AGG(DISTINCT s1.actor_name, ', ') AS actor_names\n    FROM s1\n    GROUP BY s1.title_id\n)\nSELECT \n    m.title_id,\n    m.title,\n    m.production_year,\n    a.actor_names,\n    m.keywords\nFROM MoviesWithKeywords m\nJOIN ActorsByMovie a ON m.title_id = a.title_id\nORDER BY m.production_year DESC, m.title;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "28160.sql", "original_sql": "\nWITH title_info AS (\n    SELECT \n        t.id AS title_id,\n        t.title,\n        t.production_year,\n        STRING_AGG(DISTINCT k.keyword, ', ') AS keywords,\n        STRING_AGG(DISTINCT cn.name, ', ') AS companies\n    FROM \n        title t\n    LEFT JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    LEFT JOIN \n        keyword k ON mk.keyword_id = k.id\n    LEFT JOIN \n        movie_companies mc ON t.id = mc.movie_id\n    LEFT JOIN \n        company_name cn ON mc.company_id = cn.id\n    WHERE \n        t.production_year BETWEEN 2000 AND 2023\n    GROUP BY \n        t.id, t.title, t.production_year\n),\nactor_info AS (\n    SELECT \n        c.movie_id,\n        COUNT(DISTINCT c.person_id) AS actor_count,\n        STRING_AGG(DISTINCT a.name, ', ') AS actors\n    FROM \n        cast_info c\n    JOIN \n        aka_name a ON c.person_id = a.person_id\n    GROUP BY \n        c.movie_id\n),\ndetailed_info AS (\n    SELECT \n        ti.title_id,\n        ti.title,\n        ti.production_year,\n        ti.keywords,\n        ai.actor_count,\n        ai.actors,\n        ti.companies\n    FROM \n        title_info ti\n    LEFT JOIN \n        actor_info ai ON ti.title_id = ai.movie_id\n)\nSELECT \n    di.title,\n    di.production_year,\n    di.keywords,\n    di.actor_count,\n    di.actors,\n    di.companies\nFROM \n    detailed_info di\nWHERE \n    di.actor_count > 5\nORDER BY \n    di.production_year DESC, \n    di.title;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "28198.sql", "original_sql": "WITH MovieDetails AS (\n    SELECT \n        t.id AS movie_id,\n        t.title AS movie_title,\n        t.production_year,\n        a.id AS aka_id,\n        a.name AS aka_name,\n        k.keyword AS movie_keyword,\n        c.name AS company_name,\n        rt.role AS person_role,\n        p.name AS person_name\n    FROM \n        aka_title t\n    JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    JOIN \n        movie_companies mc ON t.id = mc.movie_id\n    JOIN \n        company_name c ON mc.company_id = c.id\n    JOIN \n        complete_cast cc ON t.id = cc.movie_id\n    JOIN \n        cast_info ci ON cc.subject_id = ci.id\n    JOIN \n        role_type rt ON ci.role_id = rt.id\n    JOIN \n        aka_name a ON ci.person_id = a.person_id\n    JOIN \n        name p ON a.person_id = p.imdb_id\n    WHERE \n        t.production_year >= 2000\n        AND k.keyword IS NOT NULL\n        AND c.country_code = 'USA'\n),\nAggregatedData AS (\n    SELECT \n        movie_id,\n        movie_title,\n        production_year,\n        STRING_AGG(DISTINCT aka_name, ', ') AS aliases,\n        STRING_AGG(DISTINCT movie_keyword, ', ') AS keywords,\n        STRING_AGG(DISTINCT company_name, ', ') AS companies,\n        STRING_AGG(DISTINCT person_name || ' (' || person_role || ')', ', ') AS cast_info\n    FROM \n        MovieDetails\n    GROUP BY \n        movie_id, movie_title, production_year\n)\nSELECT \n    movie_id,\n    movie_title,\n    production_year,\n    aliases,\n    keywords,\n    companies,\n    cast_info\nFROM \n    AggregatedData\nORDER BY \n    production_year DESC, \n    movie_title;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT \n    t.id AS movie_id,\n    t.title AS movie_title,\n    t.production_year,\n    a.name AS aka_name,\n    k.keyword AS movie_keyword,\n    c.name AS company_name,\n    p.name AS person_name,\n    rt.role AS person_role\nFROM aka_title t\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_name c ON mc.company_id = c.id\nJOIN complete_cast cc ON t.id = cc.movie_id\nJOIN cast_info ci ON cc.subject_id = ci.id\nJOIN role_type rt ON ci.role_id = rt.id\nJOIN aka_name a ON ci.person_id = a.person_id\nJOIN \"name\" p ON a.person_id = p.id\nWHERE t.production_year >= 2000\n  AND k.keyword IS NOT NULL\n  AND c.country_code = 'USA';", "sql2": "SELECT \n    movie_id,\n    movie_title,\n    production_year,\n    STRING_AGG(DISTINCT aka_name, ', ') AS aliases,\n    STRING_AGG(DISTINCT movie_keyword, ', ') AS keywords,\n    STRING_AGG(DISTINCT company_name, ', ') AS companies,\n    STRING_AGG(DISTINCT person_name || ' (' || person_role || ')', ', ') AS cast_info\nFROM s1\nGROUP BY movie_id, movie_title, production_year\nORDER BY production_year DESC, movie_title;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "28338.sql", "original_sql": "WITH movie_actors AS (\n    SELECT \n        a.name AS actor_name,\n        t.title AS movie_title,\n        t.production_year,\n        STRING_AGG(DISTINCT r.role, ', ') AS roles\n    FROM \n        aka_name a\n    JOIN \n        cast_info ci ON a.person_id = ci.person_id\n    JOIN \n        aka_title t ON ci.movie_id = t.movie_id\n    JOIN \n        role_type r ON ci.role_id = r.id\n    WHERE \n        a.name IS NOT NULL\n    GROUP BY \n        a.name, t.title, t.production_year\n), actor_movie_counts AS (\n    SELECT \n        actor_name,\n        COUNT(movie_title) AS movie_count\n    FROM \n        movie_actors\n    GROUP BY \n        actor_name\n), top_actors AS (\n    SELECT \n        actor_name,\n        movie_count\n    FROM \n        actor_movie_counts\n    ORDER BY \n        movie_count DESC\n    LIMIT 10\n)\nSELECT \n    ta.actor_name,\n    ta.movie_count,\n    ma.movie_title,\n    ma.production_year,\n    ma.roles\nFROM \n    top_actors ta\nJOIN \n    movie_actors ma ON ta.actor_name = ma.actor_name\nORDER BY \n    ta.movie_count DESC, ma.production_year DESC;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "28363.sql", "original_sql": "WITH movie_details AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        STRING_AGG(DISTINCT a.name, ', ') AS actors,\n        STRING_AGG(DISTINCT k.keyword, ', ') AS keywords,\n        STRING_AGG(DISTINCT c.kind, ', ') AS company_types\n    FROM \n        title t\n    JOIN \n        movie_info mi ON t.id = mi.movie_id\n    JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    JOIN \n        movie_companies mc ON t.id = mc.movie_id\n    JOIN \n        company_type c ON mc.company_type_id = c.id\n    JOIN \n        complete_cast cc ON t.id = cc.movie_id\n    JOIN \n        cast_info ci ON cc.subject_id = ci.person_id\n    JOIN \n        aka_name a ON ci.person_id = a.person_id\n    WHERE \n        mi.info_type_id IN (SELECT id FROM info_type WHERE info = 'Synopsis')\n        AND t.production_year >= 2000\n    GROUP BY \n        t.id, t.title, t.production_year\n),\navg_movie_years AS (\n    SELECT \n        AVG(production_year) AS avg_year\n    FROM \n        movie_details\n),\nactor_count AS (\n    SELECT \n        COUNT(DISTINCT a.person_id) AS total_actors\n    FROM \n        aka_name a\n)\n\nSELECT \n    md.movie_id,\n    md.title,\n    md.production_year,\n    md.actors,\n    md.keywords,\n    md.company_types,\n    ay.avg_year,\n    ac.total_actors\nFROM \n    movie_details md,\n    avg_movie_years ay,\n    actor_count ac\nORDER BY \n    md.production_year DESC;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "28371.sql", "original_sql": "\nWITH RankedTitles AS (\n    SELECT \n        t.id AS title_id,\n        t.title,\n        t.production_year,\n        COUNT(k.id) AS keyword_count\n    FROM \n        aka_title t\n    LEFT JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    LEFT JOIN \n        keyword k ON mk.keyword_id = k.id\n    WHERE \n        t.production_year >= 2000\n    GROUP BY \n        t.id, t.title, t.production_year\n), \nTitleDetails AS (\n    SELECT \n        rt.title_id,\n        rt.title,\n        rt.production_year,\n        rt.keyword_count,\n        ak.name AS actor_name,\n        COUNT(c.id) AS cast_count\n    FROM \n        RankedTitles rt\n    LEFT JOIN \n        complete_cast cc ON rt.title_id = cc.movie_id\n    LEFT JOIN \n        cast_info c ON cc.subject_id = c.person_id\n    LEFT JOIN \n        aka_name ak ON c.person_id = ak.person_id\n    GROUP BY \n        rt.title_id, rt.title, rt.production_year, rt.keyword_count, ak.name\n    ORDER BY \n        rt.keyword_count DESC\n),\nFinalResults AS (\n    SELECT \n        td.title,\n        td.production_year,\n        td.keyword_count,\n        STRING_AGG(DISTINCT td.actor_name, ', ') AS actors,\n        td.cast_count\n    FROM \n        TitleDetails td\n    GROUP BY \n        td.title, td.production_year, td.keyword_count, td.cast_count\n)\nSELECT \n    title,\n    production_year,\n    keyword_count,\n    actors,\n    cast_count\nFROM \n    FinalResults\nWHERE \n    keyword_count > 0\nORDER BY \n    production_year DESC, \n    keyword_count DESC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "WITH RankedTitles AS (\n    SELECT \n        t.id AS title_id,\n        t.title,\n        t.production_year,\n        COUNT(k.id) AS keyword_count\n    FROM aka_title t\n    LEFT JOIN movie_keyword mk ON t.id = mk.movie_id\n    LEFT JOIN keyword k ON mk.keyword_id = k.id\n    WHERE t.production_year >= 2000\n    GROUP BY t.id, t.title, t.production_year\n)\nSELECT title_id, title, production_year, keyword_count\nFROM RankedTitles\nWHERE keyword_count > 0;", "sql2": "WITH TitleDetails AS (\n    SELECT \n        s1.title_id,\n        s1.title,\n        s1.production_year,\n        s1.keyword_count,\n        ak.name AS actor_name,\n        COUNT(c.id) AS cast_count\n    FROM s1\n    LEFT JOIN complete_cast cc ON s1.title_id = cc.movie_id\n    LEFT JOIN cast_info c ON cc.subject_id = c.person_id\n    LEFT JOIN aka_name ak ON c.person_id = ak.person_id\n    GROUP BY s1.title_id, s1.title, s1.production_year, s1.keyword_count, ak.name\n),\nFinalResults AS (\n    SELECT \n        td.title,\n        td.production_year,\n        td.keyword_count,\n        STRING_AGG(DISTINCT td.actor_name, ', ') AS actors,\n        td.cast_count\n    FROM TitleDetails td\n    GROUP BY td.title, td.production_year, td.keyword_count, td.cast_count\n)\nSELECT \n    title,\n    production_year,\n    keyword_count,\n    actors,\n    cast_count\nFROM FinalResults\nORDER BY production_year DESC, keyword_count DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "28402.sql", "original_sql": "\nWITH ActorMovies AS (\n    SELECT \n        ak.name AS actor_name,\n        ak.person_id AS actor_id,\n        ti.title AS movie_title,\n        ti.production_year AS movie_year,\n        COUNT(DISTINCT c.id) AS co_stars_count\n    FROM \n        aka_name ak\n    JOIN \n        cast_info c ON ak.person_id = c.person_id\n    JOIN \n        title ti ON c.movie_id = ti.id\n    GROUP BY \n        ak.name, ak.person_id, ti.title, ti.production_year\n),\nActorCoStarStats AS (\n    SELECT \n        actor_name,\n        movie_title,\n        movie_year,\n        AVG(co_stars_count) AS avg_co_stars,\n        COUNT(*) AS movie_count\n    FROM \n        ActorMovies\n    GROUP BY \n        actor_name, movie_title, movie_year\n),\nTopActors AS (\n    SELECT \n        actor_name,\n        AVG(avg_co_stars) AS avg_co_stars_over_all_movies\n    FROM \n        ActorCoStarStats\n    GROUP BY \n        actor_name\n    ORDER BY \n        avg_co_stars_over_all_movies DESC\n    LIMIT 10\n)\n\nSELECT \n    ta.actor_name,\n    ta.avg_co_stars_over_all_movies,\n    COUNT(DISTINCT tm.movie_title) AS total_movies,\n    STRING_AGG(DISTINCT tm.movie_title, ', ') AS movie_titles\nFROM \n    TopActors ta\nJOIN \n    ActorCoStarStats tm ON ta.actor_name = tm.actor_name\nGROUP BY \n    ta.actor_name, ta.avg_co_stars_over_all_movies\nORDER BY \n    total_movies DESC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 178, in _run_single_node\n    out_tbl = self._run_on_duckdb(node.sql)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 104, in _run_on_duckdb\n    return self.con.execute(sql).arrow()\n           ^^^^^^^^^^^^^^^^^^^^^\nduckdb.duckdb.Error: ArrowNotImplementedError: Function 'greater_equal' has no kernel matching input types (string_view, string)\n\nAt:\n  pyarrow/error.pxi(91): pyarrow.lib.check_status\n\n", "engine_mem_mb": 500000}
{"query_id": "28412.sql", "original_sql": "\nSELECT \n    a.name AS actor_name,\n    m.title AS movie_title,\n    m.production_year,\n    r.role AS role_name,\n    STRING_AGG(DISTINCT kw.keyword, ', ') AS keywords,\n    COUNT(DISTINCT c.id) AS total_coactors\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    title m ON c.movie_id = m.id\nJOIN \n    role_type r ON c.role_id = r.id\nLEFT JOIN \n    movie_keyword mk ON m.id = mk.movie_id\nLEFT JOIN \n    keyword kw ON mk.keyword_id = kw.id\nWHERE \n    a.name IS NOT NULL\n    AND m.production_year BETWEEN 2000 AND 2023\n    AND r.role LIKE '%Lead%'\nGROUP BY \n    a.name, m.title, m.production_year, r.role\nORDER BY \n    total_coactors DESC, m.production_year DESC\nLIMIT 10;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    m.id AS movie_id,\n    STRING_AGG(DISTINCT kw.keyword, ', ') AS keywords,\n    COUNT(DISTINCT ci.id) AS total_coactors\nFROM title m\nLEFT JOIN movie_keyword mk ON m.id = mk.movie_id\nLEFT JOIN keyword kw ON mk.keyword_id = kw.id\nLEFT JOIN cast_info ci ON ci.movie_id = m.id\nWHERE m.production_year BETWEEN 2000 AND 2023\nGROUP BY m.id;", "sql2": "SELECT \n    a.name AS actor_name,\n    m.title AS movie_title,\n    m.production_year,\n    r.role AS role_name,\n    s1.keywords,\n    s1.total_coactors\nFROM aka_name a\nJOIN cast_info c ON a.person_id = c.person_id\nJOIN title m ON c.movie_id = m.id\nJOIN role_type r ON c.role_id = r.id\nJOIN s1 ON s1.movie_id = m.id\nWHERE a.name IS NOT NULL\n  AND m.production_year BETWEEN 2000 AND 2023\n  AND r.role LIKE '%Lead%'\nORDER BY s1.total_coactors DESC, m.production_year DESC\nLIMIT 10;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "28599.sql", "original_sql": "\nWITH RankedMovies AS (\n    SELECT \n        t.title,\n        t.production_year,\n        COUNT(ci.id) AS cast_count,\n        STRING_AGG(DISTINCT a.name, ', ') AS actor_names\n    FROM \n        title t\n    JOIN \n        aka_title at ON t.id = at.movie_id\n    JOIN \n        cast_info ci ON ci.movie_id = at.movie_id\n    JOIN \n        aka_name a ON ci.person_id = a.person_id\n    WHERE \n        t.production_year BETWEEN 2000 AND 2023\n    GROUP BY \n        t.title, t.production_year\n    ORDER BY \n        cast_count DESC\n    LIMIT 10\n),\nMovieKeywords AS (\n    SELECT \n        m.movie_id,\n        STRING_AGG(k.keyword, ', ') AS keywords\n    FROM \n        movie_keyword m\n    JOIN \n        keyword k ON m.keyword_id = k.id\n    GROUP BY \n        m.movie_id\n),\nMovieInfo AS (\n    SELECT \n        mi.movie_id,\n        STRING_AGG(mi.info, '; ') AS info_details\n    FROM \n        movie_info mi\n    GROUP BY \n        mi.movie_id\n)\n\nSELECT \n    rm.title,\n    rm.production_year,\n    rm.cast_count,\n    rm.actor_names,\n    mk.keywords,\n    mi.info_details\nFROM \n    RankedMovies rm\nLEFT JOIN \n    aka_title at ON rm.title = at.title\nLEFT JOIN \n    MovieKeywords mk ON at.movie_id = mk.movie_id\nLEFT JOIN \n    MovieInfo mi ON at.movie_id = mi.movie_id\nORDER BY \n    rm.cast_count DESC;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "28612.sql", "original_sql": "WITH movie_details AS (\n    SELECT \n        t.id AS movie_id,\n        t.title AS movie_title,\n        t.production_year,\n        k.keyword AS movie_keyword,\n        c.name AS company_name,\n        ct.kind AS company_type,\n        a.name AS actor_name,\n        r.role AS actor_role\n    FROM \n        aka_title t\n    JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    JOIN \n        movie_companies mc ON t.id = mc.movie_id\n    JOIN \n        company_name c ON mc.company_id = c.id\n    JOIN \n        company_type ct ON mc.company_type_id = ct.id\n    JOIN \n        complete_cast cc ON t.id = cc.movie_id\n    JOIN \n        cast_info ci ON cc.subject_id = ci.person_id AND cc.movie_id = ci.movie_id\n    JOIN \n        aka_name a ON ci.person_id = a.person_id\n    JOIN \n        role_type r ON ci.role_id = r.id\n    WHERE \n        t.production_year BETWEEN 2000 AND 2023\n        AND k.keyword LIKE '%action%'\n        AND c.country_code = 'USA'\n)\nSELECT \n    md.movie_title,\n    md.production_year,\n    STRING_AGG(DISTINCT md.actor_name, ', ') AS actors,\n    STRING_AGG(DISTINCT md.movie_keyword, ', ') AS keywords,\n    STRING_AGG(DISTINCT md.company_name || ' (' || md.company_type || ')', ', ') AS companies\nFROM \n    movie_details md\nGROUP BY \n    md.movie_id, md.movie_title, md.production_year\nORDER BY \n    md.production_year DESC, md.movie_title;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "28728.sql", "original_sql": "WITH MovieDetails AS (\n    SELECT \n        m.id AS movie_id,\n        m.title AS movie_title,\n        m.production_year,\n        k.keyword AS movie_keyword,\n        tc.kind AS title_kind\n    FROM \n        title m\n    LEFT JOIN \n        kind_type tc ON m.kind_id = tc.id\n    LEFT JOIN \n        movie_keyword mk ON m.id = mk.movie_id\n    LEFT JOIN \n        keyword k ON mk.keyword_id = k.id\n    WHERE \n        m.production_year BETWEEN 2000 AND 2020\n),\n\nCastDetails AS (\n    SELECT \n        ci.movie_id,\n        a.name AS actor_name,\n        r.role AS role_name,\n        cp.kind AS cast_type\n    FROM \n        cast_info ci\n    JOIN \n        aka_name a ON ci.person_id = a.person_id\n    JOIN \n        role_type r ON ci.role_id = r.id\n    JOIN \n        comp_cast_type cp ON ci.person_role_id = cp.id\n    WHERE \n        r.role LIKE '%Actor%' \n),\n\nCompanyDetails AS (\n    SELECT \n        mc.movie_id,\n        cn.name AS company_name,\n        ct.kind AS company_type\n    FROM \n        movie_companies mc\n    JOIN \n        company_name cn ON mc.company_id = cn.id\n    JOIN \n        company_type ct ON mc.company_type_id = ct.id\n    WHERE \n        ct.kind LIKE '%Production%'\n)\n\nSELECT \n    md.movie_title,\n    md.production_year,\n    md.movie_keyword,\n    cd.actor_name,\n    cd.role_name,\n    cd.cast_type,\n    co.company_name,\n    co.company_type\nFROM \n    MovieDetails md\nJOIN \n    CastDetails cd ON md.movie_id = cd.movie_id\nJOIN \n    CompanyDetails co ON md.movie_id = co.movie_id\nWHERE \n    (md.movie_keyword IS NOT NULL OR cd.actor_name IS NOT NULL OR co.company_name IS NOT NULL)\nORDER BY \n    md.production_year DESC, \n    md.movie_title ASC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    m.id AS movie_id,\n    m.title AS movie_title,\n    m.production_year,\n    k.keyword AS movie_keyword,\n    kt.kind AS title_kind\nFROM title m\nLEFT JOIN kind_type kt ON m.kind_id = kt.id\nLEFT JOIN movie_keyword mk ON m.id = mk.movie_id\nLEFT JOIN keyword k ON mk.keyword_id = k.id\nWHERE m.production_year BETWEEN 2000 AND 2020;", "sql2": "SELECT\n    s1.movie_title,\n    s1.production_year,\n    s1.movie_keyword,\n    cd.actor_name,\n    cd.role_name,\n    cd.cast_type,\n    co.company_name,\n    co.company_type\nFROM s1\nJOIN (\n    SELECT\n        ci.movie_id,\n        a.name AS actor_name,\n        r.role AS role_name,\n        cp.kind AS cast_type\n    FROM cast_info ci\n    JOIN aka_name a ON ci.person_id = a.person_id\n    JOIN role_type r ON ci.role_id = r.id\n    JOIN comp_cast_type cp ON ci.person_role_id = cp.id\n    WHERE r.role LIKE '%Actor%'\n) cd ON s1.movie_id = cd.movie_id\nJOIN (\n    SELECT\n        mc.movie_id,\n        cn.name AS company_name,\n        ct.kind AS company_type\n    FROM movie_companies mc\n    JOIN company_name cn ON mc.company_id = cn.id\n    JOIN company_type ct ON mc.company_type_id = ct.id\n    WHERE ct.kind LIKE '%Production%'\n) co ON s1.movie_id = co.movie_id\nWHERE (s1.movie_keyword IS NOT NULL OR cd.actor_name IS NOT NULL OR co.company_name IS NOT NULL)\nORDER BY s1.production_year DESC, s1.movie_title ASC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "28775.sql", "original_sql": "WITH movie_aggregate AS (\n    SELECT \n        mt.id AS movie_id,\n        mt.title,\n        mt.production_year,\n        COUNT(DISTINCT ci.person_id) AS num_cast_members,\n        STRING_AGG(DISTINCT ak.name, ', ') AS cast_names\n    FROM \n        aka_title mt\n    JOIN \n        complete_cast cc ON mt.id = cc.movie_id\n    JOIN \n        cast_info ci ON cc.subject_id = ci.id\n    JOIN \n        aka_name ak ON ci.person_id = ak.person_id\n    WHERE \n        mt.production_year BETWEEN 2000 AND 2023\n    GROUP BY \n        mt.id, mt.title, mt.production_year\n),\n\nkeyword_aggregate AS (\n    SELECT \n        mk.movie_id,\n        STRING_AGG(k.keyword, ', ') AS keywords\n    FROM \n        movie_keyword mk\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    GROUP BY \n        mk.movie_id\n)\n\nSELECT \n    ma.title,\n    ma.production_year,\n    ma.num_cast_members,\n    ma.cast_names,\n    ka.keywords\nFROM \n    movie_aggregate ma\nLEFT JOIN \n    keyword_aggregate ka ON ma.movie_id = ka.movie_id\nORDER BY \n    ma.production_year DESC, \n    ma.title ASC;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "29052.sql", "original_sql": "WITH movie_details AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        string_agg(DISTINCT ak.name, ', ') AS aka_names,\n        COUNT(DISTINCT c.person_id) AS cast_count,\n        STRING_AGG(DISTINCT k.keyword, ', ') AS keywords\n    FROM \n        aka_title t\n    JOIN \n        movie_keyword mk ON t.movie_id = mk.movie_id\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    JOIN \n        complete_cast cc ON t.movie_id = cc.movie_id\n    JOIN \n        cast_info c ON cc.subject_id = c.person_id\n    JOIN \n        aka_name ak ON c.person_id = ak.person_id\n    WHERE \n        t.production_year >= 2000 \n    GROUP BY \n        t.id, t.title, t.production_year\n)\n\nSELECT \n    md.movie_id,\n    md.title,\n    md.production_year,\n    md.aka_names,\n    md.cast_count,\n    COUNT(DISTINCT co.id) AS company_count,  \n    STRING_AGG(DISTINCT co.name, ', ') AS companies\nFROM \n    movie_details md\nLEFT JOIN \n    movie_companies mc ON md.movie_id = mc.movie_id\nLEFT JOIN \n    company_name co ON mc.company_id = co.id\nGROUP BY \n    md.movie_id, md.title, md.production_year, md.aka_names, md.cast_count\nORDER BY \n    md.production_year DESC, \n    md.cast_count DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    t.id AS movie_id,\n    t.title,\n    t.production_year,\n    string_agg(DISTINCT ak.name, ', ') AS aka_names,\n    COUNT(DISTINCT c.person_id) AS cast_count,\n    STRING_AGG(DISTINCT k.keyword, ', ') AS keywords\nFROM \n    aka_title t\nJOIN \n    movie_keyword mk ON t.movie_id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    complete_cast cc ON t.movie_id = cc.movie_id\nJOIN \n    cast_info c ON cc.subject_id = c.person_id\nJOIN \n    aka_name ak ON c.person_id = ak.person_id\nWHERE \n    t.production_year >= 2000 \nGROUP BY \n    t.id, t.title, t.production_year", "sql2": "SELECT \n    md.movie_id,\n    md.title,\n    md.production_year,\n    md.aka_names,\n    md.cast_count,\n    COUNT(DISTINCT co.id) AS company_count,\n    STRING_AGG(DISTINCT co.name, ', ') AS companies\nFROM \n    s1 md\nLEFT JOIN \n    movie_companies mc ON md.movie_id = mc.movie_id\nLEFT JOIN \n    company_name co ON mc.company_id = co.id\nGROUP BY \n    md.movie_id, md.title, md.production_year, md.aka_names, md.cast_count\nORDER BY \n    md.production_year DESC, \n    md.cast_count DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "29053.sql", "original_sql": "WITH RankedTitles AS (\n    SELECT \n        title.id AS title_id,\n        title.title AS title,\n        title.production_year,\n        title.kind_id,\n        ROW_NUMBER() OVER (PARTITION BY title.production_year ORDER BY title.title ASC) AS title_rank\n    FROM \n        title\n    WHERE \n        title.production_year IS NOT NULL\n),\nCastDetails AS (\n    SELECT \n        cast_info.movie_id,\n        COUNT(DISTINCT cast_info.person_id) AS actor_count,\n        STRING_AGG(DISTINCT aka_name.name, ', ') AS actor_names\n    FROM \n        cast_info\n    JOIN \n        aka_name\n    ON \n        cast_info.person_id = aka_name.person_id\n    GROUP BY \n        cast_info.movie_id\n),\nMovieKeywords AS (\n    SELECT \n        movie_keyword.movie_id,\n        STRING_AGG(keyword.keyword, ', ') AS keywords\n    FROM \n        movie_keyword\n    JOIN \n        keyword\n    ON \n        movie_keyword.keyword_id = keyword.id\n    GROUP BY \n        movie_keyword.movie_id\n),\nMoviesWithDetails AS (\n    SELECT \n        RankedTitles.title_id,\n        RankedTitles.title,\n        RankedTitles.production_year,\n        CAST(COALESCE(CastDetails.actor_count, 0) AS INTEGER) AS actor_count,\n        COALESCE(CastDetails.actor_names, 'None') AS actor_names,\n        COALESCE(MovieKeywords.keywords, 'None') AS keywords\n    FROM \n        RankedTitles\n    LEFT JOIN \n        CastDetails\n    ON \n        RankedTitles.title_id = CastDetails.movie_id\n    LEFT JOIN \n        MovieKeywords\n    ON \n        RankedTitles.title_id = MovieKeywords.movie_id\n)\nSELECT \n    title_id,\n    title,\n    production_year,\n    actor_count,\n    actor_names,\n    keywords\nFROM \n    MoviesWithDetails\nWHERE \n    production_year BETWEEN 2000 AND 2023\nORDER BY \n    production_year DESC, \n    title ASC;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "29091.sql", "original_sql": "WITH MovieDetails AS (\n    SELECT \n        a.id AS aka_id,\n        a.name AS aka_name,\n        a.person_id,\n        t.title,\n        t.production_year,\n        t.kind_id,\n        c.nr_order,\n        r.role AS person_role,\n        p.info AS personal_info,\n        k.keyword AS movie_keyword\n    FROM \n        aka_name a\n    JOIN \n        cast_info c ON a.person_id = c.person_id\n    JOIN \n        aka_title t ON c.movie_id = t.movie_id\n    JOIN \n        role_type r ON c.role_id = r.id\n    LEFT JOIN \n        person_info p ON a.person_id = p.person_id\n    LEFT JOIN \n        movie_keyword mk ON mk.movie_id = t.movie_id\n    LEFT JOIN \n        keyword k ON mk.keyword_id = k.id\n    WHERE \n        t.production_year >= 2000\n        AND t.kind_id IN (SELECT id FROM kind_type WHERE kind LIKE 'feature%')\n),\nAggregateInfo AS (\n    SELECT \n        person_id,\n        COUNT(DISTINCT aka_id) AS aka_count,\n        STRING_AGG(DISTINCT movie_keyword, ', ') AS keywords,\n        MAX(production_year) AS last_movie_year\n    FROM \n        MovieDetails\n    GROUP BY \n        person_id\n)\nSELECT \n    a.name AS actor_name,\n    ai.aka_count,\n    ai.keywords,\n    ai.last_movie_year\nFROM \n    aka_name a\nJOIN \n    AggregateInfo ai ON a.person_id = ai.person_id\nWHERE \n    ai.aka_count > 1\nORDER BY \n    ai.last_movie_year DESC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'person_id' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column a.person_id\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"person_id\" }, valid_fields: [Column { relation: Some(Bare { table: \"a\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"person_id\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"name\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"imdb_index\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"name_pcode_cf\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"name_pcode_nf\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"surname_pcode\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"md5sum\" }, Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "29093.sql", "original_sql": "\nSELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    STRING_AGG(DISTINCT k.keyword, ',') AS keywords,\n    STRING_AGG(DISTINCT c.kind, ',') AS company_types,\n    STRING_AGG(DISTINCT r.role, ',') AS roles\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nLEFT JOIN \n    movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN \n    keyword k ON mk.keyword_id = k.id\nLEFT JOIN \n    movie_companies mc ON t.id = mc.movie_id\nLEFT JOIN \n    company_type c ON mc.company_type_id = c.id\nLEFT JOIN \n    role_type r ON ci.role_id = r.id\nWHERE \n    a.name LIKE '%Smith%'     \n    AND t.production_year >= 2000  \nGROUP BY \n    a.name, t.title, t.production_year\nORDER BY \n    t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT a.name AS actor_name,\n       ci.movie_id,\n       t.title AS movie_title,\n       t.production_year,\n       r.role AS role\nFROM   aka_name a\nJOIN   cast_info ci ON a.person_id = ci.person_id\nJOIN   title t ON ci.movie_id = t.id\nJOIN   role_type r ON ci.role_id = r.id\nWHERE  a.name LIKE '%Smith%'\n  AND  t.production_year >= 2000", "sql2": "SELECT s1.actor_name,\n       s1.movie_title,\n       s1.production_year,\n       STRING_AGG(DISTINCT k.keyword, ',') AS keywords,\n       STRING_AGG(DISTINCT c.kind, ',') AS company_types,\n       STRING_AGG(DISTINCT s1.role, ',') AS roles\nFROM   s1\nLEFT JOIN movie_keyword mk ON s1.movie_id = mk.movie_id\nLEFT JOIN keyword k ON mk.keyword_id = k.id\nLEFT JOIN movie_companies mc ON s1.movie_id = mc.movie_id\nLEFT JOIN company_type c ON mc.company_type_id = c.id\nGROUP BY s1.actor_name, s1.movie_title, s1.production_year\nORDER BY s1.production_year DESC, s1.actor_name;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "29120.sql", "original_sql": "WITH MovieStats AS (\n    SELECT \n        t.title AS movie_title,\n        t.production_year,\n        COUNT(DISTINCT c.person_id) AS actor_count,\n        STRING_AGG(DISTINCT a.name, ', ') AS cast_names,\n        STRING_AGG(DISTINCT k.keyword, ', ') AS keywords\n    FROM \n        aka_title t\n    JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    JOIN \n        complete_cast cc ON t.id = cc.movie_id\n    JOIN \n        cast_info c ON cc.subject_id = c.person_id\n    JOIN \n        aka_name a ON c.person_id = a.person_id\n    WHERE \n        t.production_year BETWEEN 1980 AND 2020\n    GROUP BY \n        t.title, t.production_year\n),\nCompanyStats AS (\n    SELECT\n        t.title AS movie_title,\n        STRING_AGG(DISTINCT cn.name, ', ') AS companies,\n        STRING_AGG(DISTINCT ct.kind, ', ') AS company_types\n    FROM \n        aka_title t\n    JOIN \n        movie_companies mc ON t.id = mc.movie_id\n    JOIN \n        company_name cn ON mc.company_id = cn.id\n    JOIN \n        company_type ct ON mc.company_type_id = ct.id\n    GROUP BY \n        t.title\n)\nSELECT \n    ms.movie_title,\n    ms.production_year,\n    ms.actor_count,\n    ms.cast_names,\n    ms.keywords,\n    cs.companies,\n    cs.company_types\nFROM \n    MovieStats ms\nLEFT JOIN \n    CompanyStats cs ON ms.movie_title = cs.movie_title\nORDER BY \n    ms.production_year DESC, \n    ms.actor_count DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    t.title AS movie_title,\n    t.production_year,\n    COUNT(DISTINCT c.person_id) AS actor_count,\n    STRING_AGG(DISTINCT a.name, ', ') AS cast_names,\n    STRING_AGG(DISTINCT k.keyword, ', ') AS keywords\nFROM \n    aka_title t\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info c ON cc.subject_id = c.person_id\nJOIN \n    aka_name a ON c.person_id = a.person_id\nWHERE \n    t.production_year BETWEEN 1980 AND 2020\nGROUP BY \n    t.title, t.production_year;", "sql2": "WITH cs AS (\n    SELECT\n        t.title AS movie_title,\n        STRING_AGG(DISTINCT cn.name, ', ') AS companies,\n        STRING_AGG(DISTINCT ct.kind, ', ') AS company_types\n    FROM \n        aka_title t\n    JOIN \n        movie_companies mc ON t.id = mc.movie_id\n    JOIN \n        company_name cn ON mc.company_id = cn.id\n    JOIN \n        company_type ct ON mc.company_type_id = ct.id\n    GROUP BY \n        t.title\n)\nSELECT \n    s1.movie_title,\n    s1.production_year,\n    s1.actor_count,\n    s1.cast_names,\n    s1.keywords,\n    cs.companies,\n    cs.company_types\nFROM \n    s1\nLEFT JOIN \n    cs ON s1.movie_title = cs.movie_title\nORDER BY \n    s1.production_year DESC,\n    s1.actor_count DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "29252.sql", "original_sql": "WITH MovieDetails AS (\n    SELECT \n        mt.title AS movie_title,\n        mt.production_year,\n        ak.name AS actor_name,\n        ct.kind AS company_type,\n        mi.info AS movie_info,\n        k.keyword AS movie_keyword\n    FROM \n        aka_title mt\n    JOIN \n        cast_info ci ON mt.id = ci.movie_id\n    JOIN \n        aka_name ak ON ci.person_id = ak.person_id\n    JOIN \n        movie_companies mc ON mt.id = mc.movie_id\n    JOIN \n        company_type ct ON mc.company_type_id = ct.id\n    JOIN \n        movie_info mi ON mt.id = mi.movie_id\n    JOIN \n        movie_keyword mk ON mt.id = mk.movie_id\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    WHERE \n        mt.production_year >= 2000\n        AND ak.name IS NOT NULL\n        AND mi.info_type_id = (SELECT id FROM info_type WHERE info = 'Synopsis')\n        AND k.keyword IS NOT NULL\n),\nAggregateResults AS (\n    SELECT \n        movie_title,\n        production_year,\n        STRING_AGG(DISTINCT actor_name, ', ') AS actors,\n        STRING_AGG(DISTINCT company_type, ', ') AS companies,\n        STRING_AGG(DISTINCT movie_info, '; ') AS informations,\n        STRING_AGG(DISTINCT movie_keyword, ', ') AS keywords\n    FROM \n        MovieDetails\n    GROUP BY \n        movie_title, production_year\n)\nSELECT \n    movie_title,\n    production_year,\n    actors,\n    companies,\n    informations,\n    keywords\nFROM \n    AggregateResults\nORDER BY \n    production_year DESC, movie_title;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT \n    mt.title AS movie_title,\n    mt.production_year,\n    ak.name AS actor_name,\n    ct.kind AS company_type,\n    mi.info AS movie_info,\n    k.keyword AS movie_keyword\nFROM aka_title mt\nJOIN cast_info ci ON mt.id = ci.movie_id\nJOIN aka_name ak ON ci.person_id = ak.person_id\nJOIN movie_companies mc ON mt.id = mc.movie_id\nJOIN company_type ct ON mc.company_type_id = ct.id\nJOIN movie_info mi ON mt.id = mi.movie_id\nJOIN movie_keyword mk ON mt.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE mt.production_year >= 2000\n  AND ak.name IS NOT NULL\n  AND mi.info_type_id = (SELECT id FROM info_type WHERE info = 'Synopsis')\n  AND k.keyword IS NOT NULL;", "sql2": "SELECT \n    movie_title,\n    production_year,\n    STRING_AGG(DISTINCT actor_name, ', ') AS actors,\n    STRING_AGG(DISTINCT company_type, ', ') AS companies,\n    STRING_AGG(DISTINCT movie_info, '; ') AS informations,\n    STRING_AGG(DISTINCT movie_keyword, ', ') AS keywords\nFROM s1\nGROUP BY movie_title, production_year\nORDER BY production_year DESC, movie_title;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "29278.sql", "original_sql": "\nWITH RankedMovies AS (\n    SELECT \n        t.id AS movie_id,\n        t.title AS movie_title,\n        t.production_year,\n        k.keyword AS movie_keyword,\n        ROW_NUMBER() OVER (PARTITION BY t.production_year ORDER BY t.production_year DESC) AS rn\n    FROM \n        aka_title t\n    JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    WHERE \n        t.kind_id IN (SELECT id FROM kind_type WHERE kind = 'movie')\n),\nAwardWinningMovies AS (\n    SELECT \n        DISTINCT m.movie_id,\n        m.movie_title,\n        m.production_year\n    FROM \n        RankedMovies m\n    JOIN \n        movie_info mi ON m.movie_id = mi.movie_id\n    JOIN \n        info_type it ON mi.info_type_id = it.id\n    WHERE \n        it.info ILIKE '%award%'\n),\nCastDetails AS (\n    SELECT \n        c.movie_id,\n        a.name AS actor_name,\n        r.role AS role_name\n    FROM \n        cast_info c\n    JOIN \n        aka_name a ON c.person_id = a.person_id\n    JOIN \n        role_type r ON c.role_id = r.id\n),\nFinalOutput AS (\n    SELECT \n        m.movie_title,\n        m.production_year,\n        a.actor_name,\n        a.role_name,\n        COUNT(DISTINCT a.movie_id) AS actor_movie_count,\n        STRING_AGG(DISTINCT kw.keyword, ', ') AS keywords\n    FROM \n        AwardWinningMovies m\n    LEFT JOIN \n        CastDetails a ON m.movie_id = a.movie_id\n    LEFT JOIN \n        movie_keyword mk ON m.movie_id = mk.movie_id\n    LEFT JOIN \n        keyword kw ON mk.keyword_id = kw.id\n    GROUP BY \n        m.movie_title, m.production_year, a.actor_name, a.role_name\n    ORDER BY \n        m.production_year DESC, actor_movie_count DESC, m.movie_title\n)\nSELECT \n    *\nFROM \n    FinalOutput\nWHERE \n    actor_movie_count > 1\nLIMIT 50;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH RankedMovies AS (\n    SELECT \n        t.id AS movie_id,\n        t.title AS movie_title,\n        t.production_year,\n        k.keyword AS movie_keyword\n    FROM \n        aka_title t\n    JOIN kind_type kt ON t.kind_id = kt.id\n    JOIN movie_keyword mk ON t.id = mk.movie_id\n    JOIN keyword k ON mk.keyword_id = k.id\n    WHERE \n        kt.kind = 'movie'\n),\nAwardWinningMovies AS (\n    SELECT \n        DISTINCT m.movie_id,\n        m.movie_title,\n        m.production_year\n    FROM \n        RankedMovies m\n    JOIN \n        movie_info mi ON m.movie_id = mi.movie_id\n    JOIN \n        info_type it ON mi.info_type_id = it.id\n    WHERE \n        it.info ILIKE '%award%'\n),\nCastDetails AS (\n    SELECT \n        c.movie_id,\n        a.name AS actor_name,\n        r.role AS role_name\n    FROM \n        cast_info c\n    JOIN \n        aka_name a ON c.person_id = a.person_id\n    JOIN \n        role_type r ON c.role_id = r.id\n)\nSELECT \n    m.movie_title,\n    m.production_year,\n    a.actor_name,\n    a.role_name,\n    COUNT(DISTINCT a.movie_id) AS actor_movie_count,\n    STRING_AGG(DISTINCT kw.keyword, ', ') AS keywords\nFROM \n    AwardWinningMovies m\nLEFT JOIN \n    CastDetails a ON m.movie_id = a.movie_id\nLEFT JOIN \n    movie_keyword mk ON m.movie_id = mk.movie_id\nLEFT JOIN \n    keyword kw ON mk.keyword_id = kw.id\nGROUP BY \n    m.movie_title, m.production_year, a.actor_name, a.role_name\nORDER BY \n    m.production_year DESC, actor_movie_count DESC, m.movie_title;", "sql2": "SELECT *\nFROM s1\nWHERE actor_movie_count > 1\nORDER BY production_year DESC, actor_movie_count DESC, movie_title\nLIMIT 50;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "29318.sql", "original_sql": "\nWITH MovieDetails AS (\n    SELECT \n        mt.id AS movie_id,\n        mt.title,\n        mt.production_year,\n        STRING_AGG(DISTINCT ak.name, ', ') AS aka_names,\n        STRING_AGG(DISTINCT k.keyword, ', ') AS keywords,\n        STRING_AGG(DISTINCT c.name, ', ') AS companies,\n        STRING_AGG(DISTINCT CONCAT(rc.role, ' as ', p.name), ', ') AS cast_details\n    FROM \n        aka_title mt\n    LEFT JOIN \n        movie_keyword mk ON mt.id = mk.movie_id\n    LEFT JOIN \n        keyword k ON mk.keyword_id = k.id\n    LEFT JOIN \n        complete_cast cc ON mt.id = cc.movie_id\n    LEFT JOIN \n        cast_info ci ON cc.subject_id = ci.id\n    LEFT JOIN \n        aka_name ak ON ci.person_id = ak.person_id\n    LEFT JOIN \n        movie_companies mc ON mt.id = mc.movie_id\n    LEFT JOIN \n        company_name c ON mc.company_id = c.id\n    LEFT JOIN \n        role_type rc ON ci.role_id = rc.id\n    LEFT JOIN \n        name p ON ak.person_id = p.imdb_id\n    WHERE \n        mt.production_year IS NOT NULL\n    GROUP BY \n        mt.id, mt.title, mt.production_year\n)\n\nSELECT \n    md.movie_id,\n    md.title,\n    md.production_year,\n    md.aka_names,\n    md.keywords,\n    md.companies,\n    md.cast_details\nFROM \n    MovieDetails md\nWHERE \n    md.production_year > 2000\nORDER BY \n    md.production_year DESC;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "29542.sql", "original_sql": "\nWITH matched_movies AS (\n    SELECT \n        t.title AS movie_title,\n        t.production_year,\n        STRING_AGG(DISTINCT a.name, ', ') AS actor_names,\n        k.keyword AS movie_keyword,\n        ct.kind AS company_type,\n        COUNT(DISTINCT ci.person_id) AS actor_count\n    FROM \n        aka_title t\n    JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    JOIN \n        complete_cast cc ON t.id = cc.movie_id\n    JOIN \n        cast_info ci ON cc.subject_id = ci.id\n    JOIN \n        aka_name a ON ci.person_id = a.person_id\n    JOIN \n        movie_companies mc ON t.id = mc.movie_id\n    JOIN \n        company_type ct ON mc.company_type_id = ct.id\n    WHERE \n        t.production_year >= 2000\n    GROUP BY \n        t.id, t.title, t.production_year, k.keyword, ct.kind\n)\n\nSELECT \n    movie_title,\n    production_year,\n    actor_names,\n    movie_keyword,\n    company_type,\n    actor_count\nFROM \n    matched_movies\nWHERE \n    actor_count > 2\nORDER BY \n    production_year DESC, movie_title;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    t.title AS movie_title,\n    t.production_year,\n    STRING_AGG(DISTINCT a.name, ', ') AS actor_names,\n    k.keyword AS movie_keyword,\n    ct.kind AS company_type,\n    COUNT(DISTINCT ci.person_id) AS actor_count\nFROM \n    aka_title t\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info ci ON cc.subject_id = ci.id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nWHERE \n    t.production_year >= 2000\nGROUP BY \n    t.id, t.title, t.production_year, k.keyword, ct.kind;", "sql2": "SELECT \n    movie_title,\n    production_year,\n    actor_names,\n    movie_keyword,\n    company_type,\n    actor_count\nFROM \n    s1\nWHERE \n    actor_count > 2\nORDER BY \n    production_year DESC,\n    movie_title;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "29796.sql", "original_sql": "WITH MovieDetails AS (\n    SELECT \n        title.title AS movie_title,\n        title.production_year,\n        string_agg(DISTINCT aka_name.name, ', ') AS actor_names,\n        COUNT(DISTINCT movie_keyword.keyword_id) AS keyword_count,\n        COUNT(DISTINCT company_name.name) AS company_count\n    FROM \n        title \n    JOIN \n        movie_companies ON title.id = movie_companies.movie_id\n    JOIN \n        company_name ON movie_companies.company_id = company_name.id\n    JOIN \n        complete_cast ON title.id = complete_cast.movie_id\n    JOIN \n        cast_info ON complete_cast.subject_id = cast_info.person_id\n    JOIN \n        aka_name ON cast_info.person_id = aka_name.person_id\n    LEFT JOIN \n        movie_keyword ON title.id = movie_keyword.movie_id\n    WHERE \n        title.production_year >= 2000\n    GROUP BY \n        title.title, title.production_year\n),\nKeywordStats AS (\n    SELECT \n        mk.movie_id,\n        COUNT(mk.keyword_id) AS total_keywords\n    FROM \n        movie_keyword mk\n    GROUP BY \n        mk.movie_id\n),\nCompanyStats AS (\n    SELECT \n        mc.movie_id,\n        COUNT(DISTINCT cn.id) AS total_companies\n    FROM \n        movie_companies mc\n    JOIN \n        company_name cn ON mc.company_id = cn.id\n    GROUP BY \n        mc.movie_id\n)\nSELECT \n    md.movie_title,\n    md.production_year,\n    md.actor_names,\n    COALESCE(ks.total_keywords, 0) AS total_keywords,\n    COALESCE(cs.total_companies, 0) AS total_companies\nFROM \n    MovieDetails md\nLEFT JOIN \n    KeywordStats ks ON md.movie_title = (SELECT title FROM title WHERE id = ks.movie_id)\nLEFT JOIN \n    CompanyStats cs ON md.movie_title = (SELECT title FROM title WHERE id = cs.movie_id)\nORDER BY \n    md.production_year DESC, \n    md.movie_title;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "29806.sql", "original_sql": "WITH MovieDetails AS (\n    SELECT \n        m.id AS movie_id,\n        m.title AS movie_title,\n        m.production_year,\n        k.keyword AS movie_keyword,\n        co.name AS company_name,\n        p.name AS person_name,\n        r.role AS person_role\n    FROM \n        title m\n    JOIN \n        movie_keyword mk ON m.id = mk.movie_id\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    JOIN \n        movie_companies mc ON m.id = mc.movie_id\n    JOIN \n        company_name co ON mc.company_id = co.id\n    JOIN \n        complete_cast cc ON m.id = cc.movie_id\n    JOIN \n        cast_info ci ON cc.subject_id = ci.person_id\n    JOIN \n        name p ON ci.person_id = p.id\n    JOIN \n        role_type r ON ci.role_id = r.id\n    WHERE \n        m.production_year >= 2010\n        AND k.keyword LIKE '%Action%'\n),\nAggregatedData AS (\n    SELECT \n        movie_id,\n        movie_title,\n        production_year,\n        STRING_AGG(DISTINCT movie_keyword, ', ') AS keywords,\n        STRING_AGG(DISTINCT company_name, ', ') AS companies,\n        STRING_AGG(DISTINCT person_name || ' (' || person_role || ')', ', ') AS cast_details\n    FROM \n        MovieDetails\n    GROUP BY \n        movie_id, movie_title, production_year\n)\nSELECT \n    movie_id,\n    movie_title,\n    production_year,\n    keywords,\n    companies,\n    cast_details\nFROM \n    AggregatedData\nORDER BY \n    production_year DESC, movie_title;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT \n    m.id AS movie_id,\n    m.title AS movie_title,\n    m.production_year,\n    k.keyword AS movie_keyword,\n    co.name AS company_name,\n    p.name AS person_name,\n    r.role AS person_role\nFROM title m\nJOIN movie_keyword mk ON m.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nJOIN movie_companies mc ON m.id = mc.movie_id\nJOIN company_name co ON mc.company_id = co.id\nJOIN complete_cast cc ON m.id = cc.movie_id\nJOIN cast_info ci ON cc.subject_id = ci.person_id\nJOIN name p ON ci.person_id = p.id\nJOIN role_type r ON ci.role_id = r.id\nWHERE m.production_year >= 2010\n  AND k.keyword LIKE '%Action%';", "sql2": "SELECT \n    movie_id,\n    movie_title,\n    production_year,\n    STRING_AGG(DISTINCT movie_keyword, ', ') AS keywords,\n    STRING_AGG(DISTINCT company_name, ', ') AS companies,\n    STRING_AGG(DISTINCT person_name || ' (' || person_role || ')', ', ') AS cast_details\nFROM s1\nGROUP BY movie_id, movie_title, production_year\nORDER BY production_year DESC, movie_title;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "29810.sql", "original_sql": "WITH RankedMovies AS (\n    SELECT \n        a.id AS movie_id,\n        a.title AS movie_title,\n        a.production_year,\n        COUNT(c.person_id) AS cast_count,\n        STRING_AGG(DISTINCT ak.name, ', ') AS actor_names\n    FROM \n        aka_title a\n    JOIN \n        cast_info c ON a.id = c.movie_id\n    JOIN \n        aka_name ak ON c.person_id = ak.person_id\n    GROUP BY \n        a.id, a.title, a.production_year\n    HAVING \n        COUNT(c.person_id) > 5\n),\n\nMovieKeywords AS (\n    SELECT \n        mk.movie_id,\n        STRING_AGG(DISTINCT k.keyword, ', ') AS keywords\n    FROM \n        movie_keyword mk\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    GROUP BY \n        mk.movie_id\n),\n\nMovieCompanyInfo AS (\n    SELECT \n        mc.movie_id,\n        STRING_AGG(DISTINCT cn.name, ', ') AS companies\n    FROM \n        movie_companies mc\n    JOIN \n        company_name cn ON mc.company_id = cn.id\n    GROUP BY \n        mc.movie_id\n)\n\nSELECT \n    r.movie_id,\n    r.movie_title,\n    r.production_year,\n    r.cast_count,\n    r.actor_names,\n    COALESCE(mk.keywords, 'No keywords') AS keywords,\n    COALESCE(mci.companies, 'No companies listed') AS companies\nFROM \n    RankedMovies r\nLEFT JOIN \n    MovieKeywords mk ON r.movie_id = mk.movie_id\nLEFT JOIN \n    MovieCompanyInfo mci ON r.movie_id = mci.movie_id\nORDER BY \n    r.production_year DESC, r.cast_count DESC;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "29917.sql", "original_sql": "\nWITH movie_keywords AS (\n    SELECT \n        mk.movie_id,\n        k.keyword\n    FROM \n        movie_keyword mk\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n),\ntop_movies AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        COUNT(DISTINCT c.person_id) AS cast_count\n    FROM \n        title t\n    JOIN \n        complete_cast cc ON t.id = cc.movie_id\n    JOIN \n        cast_info c ON cc.subject_id = c.id\n    GROUP BY \n        t.id, t.title, t.production_year\n    ORDER BY \n        cast_count DESC\n    LIMIT 10\n),\nmovie_details AS (\n    SELECT \n        tm.movie_id,\n        tm.title,\n        tm.production_year,\n        STRING_AGG(DISTINCT mk.keyword, ', ') AS keywords,\n        STRING_AGG(DISTINCT co.name, ', ') AS companies\n    FROM \n        top_movies tm\n    LEFT JOIN \n        movie_companies mc ON tm.movie_id = mc.movie_id\n    LEFT JOIN \n        company_name co ON mc.company_id = co.id\n    LEFT JOIN \n        movie_keywords mk ON tm.movie_id = mk.movie_id\n    GROUP BY \n        tm.movie_id, tm.title, tm.production_year\n)\nSELECT \n    md.title,\n    md.production_year,\n    md.keywords,\n    md.companies\nFROM \n    movie_details md\nWHERE \n    md.production_year >= 2000\nORDER BY \n    md.production_year DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH top_movies AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        COUNT(DISTINCT c.person_id) AS cast_count\n    FROM title t\n    JOIN complete_cast cc ON t.id = cc.movie_id\n    JOIN cast_info c ON cc.subject_id = c.id\n    GROUP BY t.id, t.title, t.production_year\n    ORDER BY cast_count DESC\n    LIMIT 10\n)\nSELECT movie_id, title, production_year FROM top_movies;", "sql2": "WITH movie_keywords AS (\n    SELECT \n        mk.movie_id,\n        k.keyword\n    FROM movie_keyword mk\n    JOIN keyword k ON mk.keyword_id = k.id\n)\nSELECT \n    s1.title,\n    s1.production_year,\n    STRING_AGG(DISTINCT mk.keyword, ', ') AS keywords,\n    STRING_AGG(DISTINCT co.name, ', ') AS companies\nFROM s1\nLEFT JOIN movie_companies mc ON s1.movie_id = mc.movie_id\nLEFT JOIN company_name co ON mc.company_id = co.id\nLEFT JOIN movie_keywords mk ON s1.movie_id = mk.movie_id\nWHERE s1.production_year >= 2000\nGROUP BY s1.title, s1.production_year\nORDER BY s1.production_year DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "33747.sql", "original_sql": "\nWITH RECURSIVE RankedMovies AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        ROW_NUMBER() OVER (PARTITION BY t.production_year ORDER BY t.production_year DESC) AS rank\n    FROM \n        aka_title t\n    WHERE \n        t.production_year IS NOT NULL\n),\nMovieStats AS (\n    SELECT \n        rm.movie_id,\n        COUNT(c.id) AS cast_count,\n        AVG(COALESCE(CAST(pi.info AS FLOAT), 0)) AS avg_salary,\n        STRING_AGG(DISTINCT g.keyword, ', ') AS genres\n    FROM \n        RankedMovies rm\n    JOIN \n        complete_cast cc ON rm.movie_id = cc.movie_id\n    JOIN \n        cast_info c ON cc.subject_id = c.person_id\n    LEFT JOIN \n        movie_keyword mk ON rm.movie_id = mk.movie_id\n    LEFT JOIN \n        keyword g ON mk.keyword_id = g.id\n    LEFT JOIN \n        person_info pi ON c.person_id = pi.person_id AND pi.info_type_id = (SELECT id FROM info_type WHERE info = 'salary')\n    GROUP BY \n        rm.movie_id\n),\nMoviesWithCompany AS (\n    SELECT \n        t.title, \n        t.production_year, \n        mcc.company_id, \n        c.name AS company_name\n    FROM \n        aka_title t\n    JOIN \n        movie_companies mcc ON t.id = mcc.movie_id\n    JOIN \n        company_name c ON mcc.company_id = c.id\n    WHERE \n        c.country_code = 'USA'\n),\nFilteredMovies AS (\n    SELECT \n        m.title,\n        m.production_year,\n        COALESCE(s.cast_count, 0) AS cast_count,\n        COALESCE(s.avg_salary, 0) AS avg_salary,\n        (SELECT COUNT(*) FROM MoviesWithCompany mwc WHERE mwc.title = m.title) AS company_count\n    FROM \n        RankedMovies m\n    LEFT JOIN \n        MovieStats s ON m.movie_id = s.movie_id\n)\nSELECT \n    *,\n    CASE \n        WHEN avg_salary > 100000 THEN 'High Budget'\n        WHEN avg_salary >= 50000 THEN 'Medium Budget'\n        ELSE 'Low Budget'\n    END AS budget_category\nFROM \n    FilteredMovies\nWHERE \n    cast_count > 0\nORDER BY \n    production_year DESC, cast_count DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH RECURSIVE RankedMovies AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        ROW_NUMBER() OVER (PARTITION BY t.production_year ORDER BY t.production_year DESC) AS rank\n    FROM aka_title t\n    WHERE t.production_year IS NOT NULL\n),\nMovieStats AS (\n    SELECT \n        rm.movie_id,\n        COUNT(c.id) AS cast_count,\n        AVG(COALESCE(CAST(pi.info AS FLOAT), 0)) AS avg_salary,\n        STRING_AGG(DISTINCT g.keyword, ', ') AS genres\n    FROM RankedMovies rm\n    JOIN complete_cast cc ON rm.movie_id = cc.movie_id\n    JOIN cast_info c ON cc.subject_id = c.person_id\n    LEFT JOIN movie_keyword mk ON rm.movie_id = mk.movie_id\n    LEFT JOIN keyword g ON mk.keyword_id = g.id\n    LEFT JOIN person_info pi ON c.person_id = pi.person_id AND pi.info_type_id = (SELECT id FROM info_type WHERE info = 'salary')\n    GROUP BY rm.movie_id\n),\nMoviesWithCompany AS (\n    SELECT \n        t.title, \n        t.production_year, \n        mcc.company_id, \n        c.name AS company_name\n    FROM aka_title t\n    JOIN movie_companies mcc ON t.id = mcc.movie_id\n    JOIN company_name c ON mcc.company_id = c.id\n    WHERE c.country_code = 'USA'\n),\nFilteredMovies AS (\n    SELECT \n        m.title,\n        m.production_year,\n        COALESCE(s.cast_count, 0) AS cast_count,\n        COALESCE(s.avg_salary, 0) AS avg_salary,\n        (SELECT COUNT(*) FROM MoviesWithCompany mwc WHERE mwc.title = m.title) AS company_count\n    FROM RankedMovies m\n    LEFT JOIN MovieStats s ON m.movie_id = s.movie_id\n)\nSELECT title, production_year, cast_count, avg_salary, company_count FROM FilteredMovies;", "sql2": "SELECT \n    *,\n    CASE \n        WHEN avg_salary > 100000 THEN 'High Budget'\n        WHEN avg_salary >= 50000 THEN 'Medium Budget'\n        ELSE 'Low Budget'\n    END AS budget_category\nFROM s1\nWHERE cast_count > 0\nORDER BY production_year DESC, cast_count DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "3996.sql", "original_sql": "WITH movie_info_agg AS (\n    SELECT \n        mi.movie_id,\n        COUNT(mi.info) AS info_count,\n        MAX(mi.info) AS latest_info,\n        MIN(mi.info) AS earliest_info\n    FROM \n        movie_info mi\n    GROUP BY \n        mi.movie_id\n),\nactor_roles AS (\n    SELECT \n        ci.movie_id,\n        COUNT(DISTINCT ci.person_id) AS actor_count,\n        STRING_AGG(DISTINCT r.role, ', ') AS roles\n    FROM \n        cast_info ci\n    JOIN \n        role_type r ON ci.person_role_id = r.id\n    GROUP BY \n        ci.movie_id\n)\nSELECT \n    t.id AS title_id,\n    t.title,\n    t.production_year,\n    COALESCE(mia.info_count, 0) AS info_count,\n    COALESCE(mia.latest_info, 'N/A') AS latest_info,\n    COALESCE(mia.earliest_info, 'N/A') AS earliest_info,\n    COALESCE(ar.actor_count, 0) AS actor_count,\n    COALESCE(ar.roles, 'No roles') AS roles\nFROM \n    title t\nLEFT JOIN \n    movie_info_agg mia ON t.id = mia.movie_id\nLEFT JOIN \n    actor_roles ar ON t.id = ar.movie_id\nWHERE \n    (t.production_year >= 2000 OR t.title ILIKE '%award%')\n    AND (t.kind_id IS NOT NULL)\nORDER BY \n    t.production_year DESC,\n    actor_count DESC\nLIMIT 50;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT mi.movie_id,\n       COUNT(mi.info) AS info_count,\n       MAX(mi.info) AS latest_info,\n       MIN(mi.info) AS earliest_info\nFROM movie_info mi\nGROUP BY mi.movie_id;", "sql2": "WITH actor_roles AS (\n    SELECT \n        ci.movie_id,\n        COUNT(DISTINCT ci.person_id) AS actor_count,\n        STRING_AGG(DISTINCT r.role, ', ') AS roles\n    FROM cast_info ci\n    JOIN role_type r ON ci.person_role_id = r.id\n    GROUP BY ci.movie_id\n)\nSELECT \n    t.id AS title_id,\n    t.title,\n    t.production_year,\n    COALESCE(s1.info_count, 0) AS info_count,\n    COALESCE(s1.latest_info, 'N/A') AS latest_info,\n    COALESCE(s1.earliest_info, 'N/A') AS earliest_info,\n    COALESCE(ar.actor_count, 0) AS actor_count,\n    COALESCE(ar.roles, 'No roles') AS roles\nFROM title t\nLEFT JOIN s1 ON t.id = s1.movie_id\nLEFT JOIN actor_roles ar ON t.id = ar.movie_id\nWHERE (t.production_year >= 2000 OR t.title ILIKE '%award%')\n  AND (t.kind_id IS NOT NULL)\nORDER BY t.production_year DESC, actor_count DESC\nLIMIT 50;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "4247.sql", "original_sql": "\nWITH movie_details AS (\n    SELECT \n        t.id AS title_id,\n        t.title,\n        t.production_year,\n        t.kind_id,\n        COALESCE(COUNT(ci.person_id), 0) AS cast_count,\n        STRING_AGG(DISTINCT ak.name, ', ') AS actor_names\n    FROM \n        title t\n    LEFT JOIN \n        cast_info ci ON t.id = ci.movie_id\n    LEFT JOIN \n        aka_name ak ON ci.person_id = ak.person_id\n    WHERE \n        t.production_year BETWEEN 2000 AND 2023\n    GROUP BY \n        t.id, t.title, t.production_year, t.kind_id\n),\ncompany_records AS (\n    SELECT \n        mc.movie_id,\n        STRING_AGG(DISTINCT cn.name, ', ') AS company_names,\n        STRING_AGG(DISTINCT ct.kind, ', ') AS company_types\n    FROM \n        movie_companies mc\n    JOIN \n        company_name cn ON mc.company_id = cn.id\n    JOIN \n        company_type ct ON mc.company_type_id = ct.id\n    GROUP BY \n        mc.movie_id\n),\nkeyword_records AS (\n    SELECT \n        mk.movie_id,\n        STRING_AGG(DISTINCT k.keyword, ', ') AS keywords\n    FROM \n        movie_keyword mk\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    GROUP BY \n        mk.movie_id\n)\nSELECT \n    md.title,\n    md.production_year,\n    md.cast_count,\n    cr.company_names,\n    cr.company_types,\n    kr.keywords\nFROM \n    movie_details md\nLEFT JOIN \n    company_records cr ON md.title_id = cr.movie_id\nLEFT JOIN \n    keyword_records kr ON md.title_id = kr.movie_id\nWHERE \n    md.cast_count > 3 \nORDER BY \n    md.production_year DESC, \n    md.cast_count DESC\nLIMIT 10;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "4291.sql", "original_sql": "\nWITH RankedMovies AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        ROW_NUMBER() OVER (PARTITION BY t.production_year ORDER BY t.id) AS rank\n    FROM \n        aka_title t\n    WHERE \n        t.production_year IS NOT NULL\n),\nMovieDetails AS (\n    SELECT \n        m.movie_id,\n        m.title,\n        COALESCE(c.count, 0) AS cast_count,\n        COALESCE(k.keywords, '') AS movie_keywords,\n        m.production_year\n    FROM \n        RankedMovies m\n    LEFT JOIN (\n        SELECT \n            movie_id,\n            COUNT(*) AS count\n        FROM \n            cast_info\n        GROUP BY \n            movie_id\n    ) c ON m.movie_id = c.movie_id\n    LEFT JOIN (\n        SELECT \n            mk.movie_id,\n            STRING_AGG(k.keyword, ', ') AS keywords\n        FROM \n            movie_keyword mk\n        JOIN \n            keyword k ON mk.keyword_id = k.id\n        GROUP BY \n            mk.movie_id\n    ) k ON m.movie_id = k.movie_id\n)\nSELECT \n    md.movie_id,\n    md.title,\n    md.production_year,\n    md.cast_count,\n    md.movie_keywords,\n    (SELECT AVG(cast_count) \n     FROM MovieDetails \n     WHERE production_year = md.production_year) AS avg_cast_count,\n    (SELECT COUNT(DISTINCT p.id) \n     FROM person_info p \n     JOIN cast_info ci ON ci.person_id = p.person_id \n     WHERE ci.movie_id = md.movie_id) AS unique_actors\nFROM \n    MovieDetails md\nWHERE \n    md.cast_count > (SELECT AVG(cast_count) \n                     FROM MovieDetails)\nORDER BY \n    md.production_year DESC, \n    md.cast_count DESC\nLIMIT 100;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "4425.sql", "original_sql": "\nWITH movie_details AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        t.kind_id,\n        COALESCE(COUNT(DISTINCT ca.person_id), 0) AS total_cast,\n        STRING_AGG(DISTINCT a.name, ', ') AS cast_names\n    FROM \n        aka_title t\n    LEFT JOIN \n        complete_cast cc ON t.id = cc.movie_id\n    LEFT JOIN \n        cast_info ca ON cc.subject_id = ca.id\n    LEFT JOIN \n        aka_name a ON ca.person_id = a.person_id\n    WHERE \n        t.production_year > 2000\n    GROUP BY \n        t.id, t.title, t.production_year, t.kind_id\n), movie_info_details AS (\n    SELECT \n        mi.movie_id,\n        COUNT(mk.keyword_id) AS keyword_count,\n        MAX(CASE WHEN it.info = 'Budget' THEN mi.info END) AS budget_info\n    FROM \n        movie_info mi\n    JOIN \n        info_type it ON mi.info_type_id = it.id\n    LEFT JOIN \n        movie_keyword mk ON mi.movie_id = mk.movie_id\n    GROUP BY \n        mi.movie_id\n)\nSELECT \n    md.title,\n    md.production_year,\n    md.total_cast,\n    md.cast_names,\n    COALESCE(mid.keyword_count, 0) AS keyword_count,\n    mid.budget_info\nFROM \n    movie_details md\nLEFT JOIN \n    movie_info_details mid ON md.movie_id = mid.movie_id\nORDER BY \n    md.production_year DESC,\n    md.total_cast DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH movie_details AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        t.kind_id,\n        COALESCE(COUNT(DISTINCT ca.person_id), 0) AS total_cast,\n        STRING_AGG(DISTINCT a.name, ', ') AS cast_names\n    FROM \n        aka_title t\n    LEFT JOIN \n        complete_cast cc ON t.id = cc.movie_id\n    LEFT JOIN \n        cast_info ca ON cc.subject_id = ca.id\n    LEFT JOIN \n        aka_name a ON ca.person_id = a.person_id\n    WHERE \n        t.production_year > 2000\n    GROUP BY \n        t.id, t.title, t.production_year, t.kind_id\n)\nSELECT \n    movie_id,\n    title,\n    production_year,\n    total_cast,\n    cast_names\nFROM movie_details;", "sql2": "WITH movie_info_details AS (\n    SELECT \n        mi.movie_id,\n        COUNT(mk.keyword_id) AS keyword_count,\n        MAX(CASE WHEN it.info = 'Budget' THEN mi.info END) AS budget_info\n    FROM \n        movie_info mi\n    JOIN \n        info_type it ON mi.info_type_id = it.id\n    LEFT JOIN \n        movie_keyword mk ON mi.movie_id = mk.movie_id\n    GROUP BY \n        mi.movie_id\n)\nSELECT \n    s1.title,\n    s1.production_year,\n    s1.total_cast,\n    s1.cast_names,\n    COALESCE(mid.keyword_count, 0) AS keyword_count,\n    mid.budget_info\nFROM \n    s1\nLEFT JOIN \n    movie_info_details mid ON s1.movie_id = mid.movie_id\nORDER BY \n    s1.production_year DESC,\n    s1.total_cast DESC\nLIMIT 100;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "4708.sql", "original_sql": "WITH RankedMovies AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        ROW_NUMBER() OVER (PARTITION BY t.production_year ORDER BY t.title) AS rn\n    FROM \n        aka_title t\n    WHERE \n        t.production_year IS NOT NULL\n),\nMovieCast AS (\n    SELECT \n        c.movie_id,\n        STRING_AGG(a.name, ', ') AS actor_names,\n        COUNT(DISTINCT c.person_id) AS actor_count\n    FROM \n        cast_info c\n    JOIN \n        aka_name a ON c.person_id = a.person_id\n    GROUP BY \n        c.movie_id\n),\nCompanyInfo AS (\n    SELECT \n        mc.movie_id,\n        STRING_AGG(DISTINCT cn.name, ', ') AS company_names,\n        COUNT(DISTINCT mc.company_id) AS company_count\n    FROM \n        movie_companies mc\n    JOIN \n        company_name cn ON mc.company_id = cn.id\n    GROUP BY \n        mc.movie_id\n)\nSELECT \n    rm.movie_id,\n    rm.title,\n    rm.production_year,\n    COALESCE(mc.actor_names, 'No Cast') AS cast,\n    COALESCE(ci.company_names, 'No Companies') AS companies,\n    mc.actor_count,\n    ci.company_count\nFROM \n    RankedMovies rm\nLEFT JOIN \n    MovieCast mc ON rm.movie_id = mc.movie_id\nLEFT JOIN \n    CompanyInfo ci ON rm.movie_id = ci.movie_id\nWHERE \n    (mc.actor_count > 5 OR ci.company_count > 0)\nORDER BY \n    rm.production_year DESC, rm.title;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "4725.sql", "original_sql": "\nWITH ranked_titles AS (\n    SELECT \n        t.id AS title_id,\n        t.title,\n        t.production_year,\n        ROW_NUMBER() OVER (PARTITION BY t.production_year ORDER BY t.title) AS title_rank\n    FROM \n        aka_title t\n    WHERE \n        t.production_year IS NOT NULL\n),\nactor_movie_counts AS (\n    SELECT \n        c.person_id,\n        COUNT(DISTINCT c.movie_id) AS movie_count\n    FROM \n        cast_info c\n    GROUP BY \n        c.person_id\n),\ntop_actors AS (\n    SELECT \n        a.person_id,\n        ak.name\n    FROM \n        actor_movie_counts a\n    JOIN \n        aka_name ak ON a.person_id = ak.person_id\n    WHERE \n        a.movie_count = (SELECT MAX(movie_count) FROM actor_movie_counts)\n)\nSELECT \n    rt.title,\n    rt.production_year,\n    ta.name AS top_actor,\n    COUNT(DISTINCT c.movie_id) AS total_movies_with_actor\nFROM \n    ranked_titles rt\nLEFT JOIN \n    cast_info c ON rt.title_id = c.movie_id\nLEFT JOIN \n    top_actors ta ON c.person_id = ta.person_id\nGROUP BY \n    rt.title, rt.production_year, ta.name\nHAVING \n    COUNT(DISTINCT c.movie_id) > 0\nORDER BY \n    rt.production_year DESC,\n    rt.title ASC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH actor_counts AS (\n    SELECT person_id, COUNT(DISTINCT movie_id) AS movie_count\n    FROM cast_info\n    GROUP BY person_id\n), max_count AS (\n    SELECT MAX(movie_count) AS max_mc FROM actor_counts\n)\nSELECT ac.person_id, ak.name\nFROM actor_counts ac\nJOIN aka_name ak ON ac.person_id = ak.person_id\nJOIN max_count mc ON ac.movie_count = mc.max_mc;", "sql2": "WITH ranked_titles AS (\n    SELECT \n        t.id AS title_id,\n        t.title,\n        t.production_year,\n        ROW_NUMBER() OVER (PARTITION BY t.production_year ORDER BY t.title) AS title_rank\n    FROM aka_title t\n    WHERE t.production_year IS NOT NULL\n)\nSELECT \n    rt.title,\n    rt.production_year,\n    ta.name AS top_actor,\n    COUNT(DISTINCT c.movie_id) AS total_movies_with_actor\nFROM ranked_titles rt\nLEFT JOIN cast_info c ON rt.title_id = c.movie_id\nLEFT JOIN s1 ta ON c.person_id = ta.person_id\nGROUP BY rt.title, rt.production_year, ta.name\nHAVING COUNT(DISTINCT c.movie_id) > 0\nORDER BY rt.production_year DESC, rt.title ASC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "5.sql", "original_sql": "WITH MovieDetails AS (\n    SELECT \n        t.id AS movie_id, \n        t.title, \n        t.production_year,\n        COUNT(DISTINCT ci.person_id) AS actor_count,\n        STRING_AGG(DISTINCT a.name, ', ') AS actor_names\n    FROM \n        aka_title t\n    LEFT JOIN \n        complete_cast cc ON t.id = cc.movie_id\n    LEFT JOIN \n        cast_info ci ON cc.subject_id = ci.id\n    LEFT JOIN \n        aka_name a ON ci.person_id = a.person_id\n    WHERE \n        t.production_year >= 2000\n    GROUP BY \n        t.id, t.title, t.production_year\n),\n\nKeywordStats AS (\n    SELECT \n        mk.movie_id,\n        COUNT(mk.keyword_id) AS keyword_count\n    FROM \n        movie_keyword mk\n    GROUP BY \n        mk.movie_id\n),\n\nFinalStats AS (\n    SELECT \n        md.movie_id,\n        md.title,\n        md.production_year,\n        md.actor_count,\n        ks.keyword_count,\n        CASE \n            WHEN md.actor_count IS NULL THEN 0 \n            ELSE md.actor_count \n        END AS actor_count_safe,\n        CASE \n            WHEN ks.keyword_count IS NULL THEN 0 \n            ELSE ks.keyword_count \n        END AS keyword_count_safe\n    FROM \n        MovieDetails md\n    LEFT JOIN \n        KeywordStats ks ON md.movie_id = ks.movie_id\n)\n\nSELECT \n    fs.movie_id, \n    fs.title, \n    fs.production_year,\n    fs.actor_count_safe,\n    fs.keyword_count_safe,\n    COALESCE(fs.actor_count_safe - fs.keyword_count_safe, 0) AS actor_keyword_diff\nFROM \n    FinalStats fs\nORDER BY \n    fs.production_year DESC, \n    fs.actor_count_safe DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH MovieDetails AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        COUNT(DISTINCT ci.person_id) AS actor_count\n    FROM aka_title t\n    LEFT JOIN complete_cast cc ON t.id = cc.movie_id\n    LEFT JOIN cast_info ci ON cc.subject_id = ci.id\n    LEFT JOIN aka_name a ON ci.person_id = a.person_id\n    WHERE t.production_year >= 2000\n    GROUP BY t.id, t.title, t.production_year\n)\nSELECT * FROM MovieDetails;", "sql2": "WITH KeywordStats AS (\n    SELECT \n        mk.movie_id,\n        COUNT(mk.keyword_id) AS keyword_count\n    FROM movie_keyword mk\n    GROUP BY mk.movie_id\n), FinalStats AS (\n    SELECT \n        s1.movie_id,\n        s1.title,\n        s1.production_year,\n        s1.actor_count,\n        ks.keyword_count,\n        COALESCE(s1.actor_count, 0) AS actor_count_safe,\n        COALESCE(ks.keyword_count, 0) AS keyword_count_safe\n    FROM s1\n    LEFT JOIN KeywordStats ks ON s1.movie_id = ks.movie_id\n)\nSELECT \n    fs.movie_id,\n    fs.title,\n    fs.production_year,\n    fs.actor_count_safe,\n    fs.keyword_count_safe,\n    COALESCE(fs.actor_count_safe - fs.keyword_count_safe, 0) AS actor_keyword_diff\nFROM FinalStats fs\nORDER BY fs.production_year DESC, fs.actor_count_safe DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "5007.sql", "original_sql": "WITH MovieDetails AS (\n    SELECT a.name AS actor_name, t.title AS movie_title, t.production_year, k.keyword AS movie_keyword\n    FROM aka_name a\n    JOIN cast_info ci ON a.person_id = ci.person_id\n    JOIN aka_title t ON ci.movie_id = t.id\n    LEFT JOIN movie_keyword mk ON t.id = mk.movie_id\n    LEFT JOIN keyword k ON mk.keyword_id = k.id\n), CompanyDetails AS (\n    SELECT c.name AS company_name, ct.kind AS company_type, mc.movie_id\n    FROM company_name c\n    JOIN movie_companies mc ON c.id = mc.company_id\n    JOIN company_type ct ON mc.company_type_id = ct.id\n), CompleteCast AS (\n    SELECT cc.movie_id, COUNT(DISTINCT cc.subject_id) AS total_cast\n    FROM complete_cast cc\n    GROUP BY cc.movie_id\n)\nSELECT md.actor_name, md.movie_title, md.production_year, md.movie_keyword, cd.company_name, cd.company_type, cc.total_cast\nFROM MovieDetails md\nJOIN CompanyDetails cd ON md.production_year = cd.movie_id\nJOIN CompleteCast cc ON md.production_year = cc.movie_id\nWHERE md.movie_keyword IS NOT NULL\nORDER BY md.production_year DESC, cc.total_cast DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT a.name AS actor_name,\n       t.title AS movie_title,\n       t.production_year,\n       k.keyword AS movie_keyword\nFROM aka_name a\nJOIN cast_info ci ON a.person_id = ci.person_id\nJOIN aka_title t ON ci.movie_id = t.id\nLEFT JOIN movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN keyword k ON mk.keyword_id = k.id\nWHERE k.keyword IS NOT NULL", "sql2": "SELECT s1.actor_name,\n       s1.movie_title,\n       s1.production_year,\n       s1.movie_keyword,\n       cd.company_name,\n       cd.company_type,\n       cc.total_cast\nFROM s1\nJOIN (\n    SELECT c.name AS company_name,\n           ct.kind AS company_type,\n           mc.movie_id\n    FROM company_name c\n    JOIN movie_companies mc ON c.id = mc.company_id\n    JOIN company_type ct ON mc.company_type_id = ct.id\n) cd ON s1.production_year = cd.movie_id\nJOIN (\n    SELECT cc.movie_id, COUNT(DISTINCT cc.subject_id) AS total_cast\n    FROM complete_cast cc\n    GROUP BY cc.movie_id\n) cc ON s1.production_year = cc.movie_id\nORDER BY s1.production_year DESC, cc.total_cast DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "5013.sql", "original_sql": "\nSELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    STRING_AGG(DISTINCT k.keyword, ', ') AS keywords,\n    c.kind AS cast_type,\n    ci.note AS cast_note\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    aka_title t ON ci.movie_id = t.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    comp_cast_type c ON ci.role_id = c.id\nWHERE \n    t.production_year >= 2000 AND \n    a.name IS NOT NULL\nGROUP BY \n    a.name, t.title, t.production_year, c.kind, ci.note\nORDER BY \n    t.production_year DESC, \n    actor_name ASC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS movie_id,\n       t.title,\n       t.production_year,\n       STRING_AGG(DISTINCT k.keyword, ', ') AS keywords\nFROM   aka_title t\nJOIN   movie_keyword mk ON t.id = mk.movie_id\nJOIN   keyword k ON mk.keyword_id = k.id\nWHERE  t.production_year >= 2000\nGROUP BY t.id, t.title, t.production_year;", "sql2": "SELECT a.name AS actor_name,\n       s1.title AS movie_title,\n       s1.production_year,\n       s1.keywords,\n       c.kind AS cast_type,\n       ci.note AS cast_note\nFROM   aka_name a\nJOIN   cast_info ci ON a.person_id = ci.person_id\nJOIN   comp_cast_type c ON ci.role_id = c.id\nJOIN   s1 ON ci.movie_id = s1.movie_id\nWHERE  a.name IS NOT NULL\nGROUP BY a.name, s1.title, s1.production_year, c.kind, ci.note, s1.keywords\nORDER BY s1.production_year DESC, actor_name ASC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "5039.sql", "original_sql": "\nSELECT \n    a.name AS actor_name, \n    t.title AS movie_title, \n    t.production_year, \n    STRING_AGG(DISTINCT kw.keyword, ', ') AS keywords, \n    c.kind AS cast_type, \n    cn.name AS company_name\nFROM \n    cast_info ci\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    aka_title t ON ci.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    comp_cast_type c ON ci.person_role_id = c.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword kw ON mk.keyword_id = kw.id\nWHERE \n    t.production_year > 2000\n    AND c.kind IN ('Actor', 'Producer')\nGROUP BY \n    a.name, t.title, t.production_year, c.kind, cn.name\nORDER BY \n    t.production_year DESC, a.name;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 115, in _run_on_datafusion\n    return df.to_arrow_table()\n           ^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/dataframe.py\", line 1164, in to_arrow_table\n    return self.df.to_arrow_table()\n           ^^^^^^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Shared(ResourcesExhausted(\"Additional allocation failed with top memory consumers (across reservations) as:\\n  RepartitionExec[7]#5897(can spill: false) consumed 10.9 GB, peak 10.9 GB,\\n  RepartitionExec[14]#5904(can spill: false) consumed 10.0 GB, peak 10.0 GB,\\n  RepartitionExec[9]#5899(can spill: false) consumed 9.8 GB, peak 9.8 GB,\\n  RepartitionExec[19]#5909(can spill: false) consumed 9.0 GB, peak 9.0 GB,\\n  RepartitionExec[18]#5908(can spill: false) consumed 8.6 GB, peak 8.7 GB.\\nError: Failed to allocate additional 83.8 MB for RepartitionExec[40] with 3.1 GB already allocated for this reservation - 14.0 MB remain available for the total pool\"))\n", "engine_mem_mb": 500000}
{"query_id": "5048.sql", "original_sql": "WITH MovieDetails AS (\n    SELECT \n        t.title AS movie_title,\n        t.production_year,\n        c.name AS company_name,\n        k.keyword AS movie_keyword,\n        a.name AS actor_name,\n        ct.kind AS company_type,\n        p.info AS person_info\n    FROM \n        title t\n    JOIN \n        movie_companies mc ON t.id = mc.movie_id\n    JOIN \n        company_name c ON mc.company_id = c.id\n    JOIN \n        company_type ct ON mc.company_type_id = ct.id\n    JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    JOIN \n        complete_cast cc ON t.id = cc.movie_id\n    JOIN \n        cast_info ci ON cc.subject_id = ci.id\n    JOIN \n        aka_name a ON ci.person_id = a.person_id\n    JOIN \n        person_info p ON a.person_id = p.person_id\n    WHERE \n        t.production_year >= 2000\n        AND c.country_code = 'USA'\n),\nAggregatedDetails AS (\n    SELECT \n        movie_title,\n        production_year,\n        COUNT(DISTINCT actor_name) AS actor_count,\n        STRING_AGG(DISTINCT movie_keyword, ', ') AS keywords,\n        STRING_AGG(DISTINCT company_name, ', ') AS production_companies\n    FROM \n        MovieDetails\n    GROUP BY \n        movie_title, production_year\n)\nSELECT \n    movie_title,\n    production_year,\n    actor_count,\n    keywords,\n    production_companies\nFROM \n    AggregatedDetails\nORDER BY \n    production_year DESC, actor_count DESC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "WITH MovieDetails AS (\n    SELECT \n        t.title AS movie_title,\n        t.production_year,\n        a.name AS actor_name,\n        k.keyword AS movie_keyword,\n        c.name AS company_name\n    FROM \n        title t\n    JOIN \n        movie_companies mc ON t.id = mc.movie_id\n    JOIN \n        company_name c ON mc.company_id = c.id\n    JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    JOIN \n        complete_cast cc ON t.id = cc.movie_id\n    JOIN \n        cast_info ci ON cc.subject_id = ci.id\n    JOIN \n        aka_name a ON ci.person_id = a.person_id\n    WHERE \n        t.production_year >= 2000\n        AND c.country_code = 'USA'\n)\nSELECT * FROM MovieDetails;", "sql2": "SELECT \n    movie_title,\n    production_year,\n    COUNT(DISTINCT actor_name) AS actor_count,\n    STRING_AGG(DISTINCT movie_keyword, ', ') AS keywords,\n    STRING_AGG(DISTINCT company_name, ', ') AS production_companies\nFROM s1\nGROUP BY movie_title, production_year\nORDER BY production_year DESC, actor_count DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "5214.sql", "original_sql": "\nSELECT\n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    ARRAY_AGG(DISTINCT k.keyword) AS keywords,\n    ct.kind AS company_type,\n    pi.info AS person_info\nFROM\n    cast_info ci\nJOIN\n    aka_name a ON ci.person_id = a.person_id\nJOIN\n    aka_title t ON ci.movie_id = t.movie_id\nJOIN\n    movie_companies mc ON t.id = mc.movie_id\nJOIN\n    company_name cn ON mc.company_id = cn.id\nJOIN\n    company_type ct ON mc.company_type_id = ct.id\nJOIN\n    movie_keyword mk ON t.id = mk.movie_id\nJOIN\n    keyword k ON mk.keyword_id = k.id\nLEFT JOIN\n    person_info pi ON a.person_id = pi.person_id\nWHERE\n    t.production_year >= 2000 AND\n    ct.kind = 'Distributor'\nGROUP BY\n    a.name, t.title, t.production_year, ct.kind, pi.info\nORDER BY\n    t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    mk.movie_id,\n    ARRAY_AGG(DISTINCT k.keyword) AS keywords\nFROM\n    movie_keyword mk\nJOIN\n    keyword k ON mk.keyword_id = k.id\nGROUP BY\n    mk.movie_id;", "sql2": "SELECT\n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    s1.keywords,\n    ct.kind AS company_type,\n    pi.info AS person_info\nFROM\n    cast_info ci\nJOIN\n    aka_name a ON ci.person_id = a.person_id\nJOIN\n    aka_title t ON ci.movie_id = t.movie_id\nJOIN\n    movie_companies mc ON t.id = mc.movie_id\nJOIN\n    company_name cn ON mc.company_id = cn.id\nJOIN\n    company_type ct ON mc.company_type_id = ct.id\nLEFT JOIN\n    person_info pi ON a.person_id = pi.person_id\nLEFT JOIN\n    s1 ON t.id = s1.movie_id\nWHERE\n    t.production_year >= 2000\n    AND ct.kind = 'Distributor'\nGROUP BY\n    a.name,\n    t.title,\n    t.production_year,\n    ct.kind,\n    pi.info,\n    s1.keywords\nORDER BY\n    t.production_year DESC,\n    a.name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "5276.sql", "original_sql": "\nSELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    c.kind AS cast_type,\n    STRING_AGG(DISTINCT k.keyword, ', ') AS keywords\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    comp_cast_type c ON ci.person_role_id = c.id\nLEFT JOIN \n    movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    t.production_year >= 2000\nGROUP BY \n    a.name, t.title, t.production_year, c.kind\nORDER BY \n    t.production_year DESC, a.name;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "5288.sql", "original_sql": "\nSELECT \n    a.person_id,\n    a.name AS actor_name,\n    t.title AS movie_title,\n    ct.kind AS company_type,\n    COUNT(DISTINCT rr.role_id) AS total_roles,\n    AVG(mi.info_length) AS avg_info_length\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nLEFT JOIN \n    (SELECT \n         movie_id,\n         AVG(LENGTH(info)) AS info_length\n     FROM \n         movie_info \n     GROUP BY \n         movie_id) mi ON t.id = mi.movie_id\nJOIN \n    (SELECT \n         ci2.role_id, \n         ci2.movie_id \n     FROM \n         cast_info ci2 \n     GROUP BY \n         ci2.role_id, ci2.movie_id) rr ON ci.role_id = rr.role_id AND ci.movie_id = rr.movie_id\nWHERE \n    t.production_year >= 2000\nGROUP BY \n    a.person_id, a.name, t.title, ct.kind, mi.info_length\nORDER BY \n    total_roles DESC, avg_info_length DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT movie_id,\n       AVG(LENGTH(info)) AS info_length\nFROM   movie_info\nGROUP BY movie_id;", "sql2": "SELECT \n    a.person_id,\n    a.name AS actor_name,\n    t.title AS movie_title,\n    ct.kind AS company_type,\n    COUNT(DISTINCT rr.role_id) AS total_roles,\n    AVG(s1.info_length) AS avg_info_length\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nLEFT JOIN \n    s1 ON t.id = s1.movie_id\nJOIN \n    (SELECT ci2.role_id, ci2.movie_id \n     FROM cast_info ci2 \n     GROUP BY ci2.role_id, ci2.movie_id) rr \n      ON ci.role_id = rr.role_id AND ci.movie_id = rr.movie_id\nWHERE \n    t.production_year >= 2000\nGROUP BY \n    a.person_id, a.name, t.title, ct.kind, s1.info_length\nORDER BY \n    total_roles DESC, avg_info_length DESC\nLIMIT 100;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "5365.sql", "original_sql": "\nSELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    c.kind AS company_type,\n    k.keyword AS movie_keyword,\n    p.info AS actor_info\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    person_info p ON a.person_id = p.person_id\nWHERE \n    t.production_year >= 2000\nAND \n    p.info_type_id IN (SELECT id FROM info_type WHERE info = 'Biography')\nORDER BY \n    t.production_year DESC, a.name;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "5372.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.role_id AS actor_role,\n    m.info AS movie_info,\n    k.keyword AS movie_keyword,\n    comp.name AS company_name,\n    ct.kind AS company_type\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    aka_title t ON c.movie_id = t.movie_id\nJOIN \n    movie_info m ON t.id = m.movie_id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name comp ON mc.company_id = comp.id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nWHERE \n    t.production_year > 2000\n    AND ct.kind = 'Distributor'\nORDER BY \n    t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.role_id AS actor_role,\n    t.id AS movie_id,\n    mk.keyword_id,\n    mc.company_id,\n    ct.kind AS company_type,\n    t.production_year\nFROM aka_name a\nJOIN cast_info c ON a.person_id = c.person_id\nJOIN aka_title t ON c.movie_id = t.movie_id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type ct ON mc.company_type_id = ct.id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nWHERE t.production_year > 2000\n  AND ct.kind = 'Distributor'", "sql2": "SELECT \n    s.actor_name,\n    s.movie_title,\n    s.actor_role,\n    mi.info AS movie_info,\n    k.keyword AS movie_keyword,\n    cn.name AS company_name,\n    s.company_type\nFROM s1 s\nJOIN movie_info mi ON s.movie_id = mi.movie_id\nJOIN keyword k ON s.keyword_id = k.id\nJOIN company_name cn ON s.company_id = cn.id\nORDER BY s.production_year DESC, s.actor_name", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "5388.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    c.kind AS company_type,\n    k.keyword AS movie_keyword,\n    pi.info AS person_info\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nLEFT JOIN \n    person_info pi ON a.person_id = pi.person_id\nWHERE \n    t.production_year >= 2000\n    AND k.keyword ILIKE '%thriller%'\nORDER BY \n    t.production_year DESC, a.name ASC\nLIMIT 100;", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT t.id AS movie_id,\n       t.title AS movie_title,\n       t.production_year,\n       k.keyword AS movie_keyword\nFROM title t\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE t.production_year >= 2000\n  AND k.keyword ILIKE '%thriller%';", "sql2": "SELECT a.name AS actor_name,\n       s1.movie_title,\n       s1.production_year,\n       c.kind AS company_type,\n       s1.movie_keyword,\n       pi.info AS person_info\nFROM s1\nJOIN cast_info ci ON s1.movie_id = ci.movie_id\nJOIN aka_name a ON ci.person_id = a.person_id\nJOIN movie_companies mc ON s1.movie_id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nLEFT JOIN person_info pi ON a.person_id = pi.person_id\nORDER BY s1.production_year DESC, a.name ASC\nLIMIT 100;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "5459.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.nr_order AS cast_order,\n    co.name AS company_name,\n    k.keyword AS movie_keyword,\n    m.info AS movie_info\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    title t ON c.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name co ON mc.company_id = co.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    movie_info m ON t.id = m.movie_id\nWHERE \n    t.production_year BETWEEN 2000 AND 2023\n    AND m.info_type_id = (SELECT id FROM info_type WHERE info = 'Box Office')\nORDER BY \n    a.name, t.production_year DESC, c.nr_order;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "5576.sql", "original_sql": "SELECT \n    a.name AS actor_name, \n    t.title AS movie_title, \n    c.kind AS cast_type, \n    p.info AS person_info,\n    k.keyword AS movie_keyword \nFROM \n    aka_name a \nJOIN \n    cast_info ci ON a.person_id = ci.person_id \nJOIN \n    title t ON ci.movie_id = t.id \nJOIN \n    comp_cast_type c ON ci.person_role_id = c.id \nJOIN \n    person_info p ON a.person_id = p.person_id \nJOIN \n    movie_keyword mk ON t.id = mk.movie_id \nJOIN \n    keyword k ON mk.keyword_id = k.id \nWHERE \n    t.production_year > 2000 \n    AND c.kind LIKE 'Actor%'\n    AND p.info_type_id IN (SELECT id FROM info_type WHERE info = 'Biography') \nORDER BY \n    a.name, t.production_year DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT DISTINCT pi.person_id\nFROM person_info pi\nJOIN info_type it ON pi.info_type_id = it.id\nWHERE it.info = 'Biography'", "sql2": "SELECT a.name AS actor_name,\n       t.title AS movie_title,\n       c.kind AS cast_type,\n       p.info AS person_info,\n       k.keyword AS movie_keyword\nFROM aka_name a\nJOIN cast_info ci ON a.person_id = ci.person_id\nJOIN title t ON ci.movie_id = t.id\nJOIN comp_cast_type c ON ci.person_role_id = c.id\nJOIN person_info p ON a.person_id = p.person_id\nJOIN s1 ON p.person_id = s1.person_id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE t.production_year > 2000\n  AND c.kind LIKE 'Actor%'\nORDER BY a.name, t.production_year DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "5604.sql", "original_sql": "SELECT \n    a.name AS actor_name, \n    t.title AS movie_title, \n    c.kind AS company_type, \n    k.keyword AS movie_keyword, \n    p.info AS person_info\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    person_info p ON a.person_id = p.person_id\nWHERE \n    t.production_year >= 2000 \n    AND c.kind = 'Production'\nORDER BY \n    actor_name, movie_title;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT a.person_id AS actor_id,\n       a.name AS actor_name,\n       t.id AS movie_id,\n       t.title AS movie_title,\n       c.kind AS company_type\nFROM   aka_name a\nJOIN   cast_info ci ON a.person_id = ci.person_id\nJOIN   title t ON ci.movie_id = t.id\nJOIN   movie_companies mc ON t.id = mc.movie_id\nJOIN   company_type c ON mc.company_type_id = c.id\nWHERE  t.production_year >= 2000\n  AND  c.kind = 'Production'", "sql2": "SELECT s1.actor_name,\n       s1.movie_title,\n       s1.company_type,\n       k.keyword AS movie_keyword,\n       p.info AS person_info\nFROM   s1\nJOIN   movie_keyword mk ON s1.movie_id = mk.movie_id\nJOIN   keyword k ON mk.keyword_id = k.id\nJOIN   person_info p ON s1.actor_id = p.person_id\nORDER BY s1.actor_name, s1.movie_title;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "5617.sql", "original_sql": "SELECT \n    a.name AS actor_name, \n    t.title AS movie_title, \n    c.kind AS company_type, \n    k.keyword AS keyword, \n    m.info AS additional_info \nFROM \n    aka_name a \nJOIN \n    cast_info ci ON a.person_id = ci.person_id \nJOIN \n    aka_title t ON ci.movie_id = t.movie_id \nJOIN \n    movie_companies mc ON t.id = mc.movie_id \nJOIN \n    company_name cn ON mc.company_id = cn.id \nJOIN \n    company_type c ON mc.company_type_id = c.id \nJOIN \n    movie_keyword mk ON t.id = mk.movie_id \nJOIN \n    keyword k ON mk.keyword_id = k.id \nLEFT JOIN \n    movie_info m ON t.id = m.movie_id \nWHERE \n    t.production_year >= 2000 \n    AND a.name IS NOT NULL \n    AND ci.nr_order < 5 \nORDER BY \n    a.name, \n    t.title, \n    c.kind \nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT a.name AS actor_name,\n       t.title AS movie_title,\n       c.kind AS company_type,\n       k.keyword AS keyword,\n       t.id AS movie_id\nFROM aka_name a\nJOIN cast_info ci ON a.person_id = ci.person_id\nJOIN aka_title t ON ci.movie_id = t.movie_id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN company_type c ON mc.company_type_id = c.id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE t.production_year >= 2000\n  AND a.name IS NOT NULL\n  AND ci.nr_order < 5\nORDER BY a.name, t.title, c.kind\nLIMIT 100;", "sql2": "SELECT s1.actor_name,\n       s1.movie_title,\n       s1.company_type,\n       s1.keyword,\n       m.info AS additional_info\nFROM s1\nLEFT JOIN movie_info m ON s1.movie_id = m.movie_id\nORDER BY s1.actor_name, s1.movie_title, s1.company_type;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "5707.sql", "original_sql": "WITH MovieDetails AS (\n    SELECT \n        t.title AS movie_title,\n        t.production_year,\n        c.kind AS company_type,\n        k.keyword AS movie_keyword,\n        a.name AS actor_name,\n        p.gender AS actor_gender\n    FROM \n        title t\n    JOIN \n        movie_companies mc ON t.id = mc.movie_id\n    JOIN \n        company_type c ON mc.company_type_id = c.id\n    JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    JOIN \n        cast_info ci ON t.id = ci.movie_id\n    JOIN \n        aka_name a ON ci.person_id = a.person_id\n    JOIN \n        name p ON a.person_id = p.imdb_id\n    WHERE \n        t.production_year BETWEEN 2000 AND 2023\n        AND k.keyword ILIKE '%action%'\n),\nActorSummary AS (\n    SELECT \n        actor_name,\n        actor_gender,\n        COUNT(movie_title) AS movie_count,\n        ARRAY_AGG(DISTINCT movie_title) AS movies\n    FROM \n        MovieDetails\n    GROUP BY \n        actor_name, actor_gender\n)\nSELECT \n    actor_name,\n    actor_gender,\n    movie_count,\n    movies\nFROM \n    ActorSummary\nWHERE \n    movie_count > 5\nORDER BY \n    movie_count DESC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT a.name AS actor_name,\n       p.gender AS actor_gender,\n       t.title AS movie_title\nFROM title t\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nJOIN cast_info ci ON t.id = ci.movie_id\nJOIN aka_name a ON ci.person_id = a.person_id\nJOIN name p ON a.person_id = p.id\nWHERE t.production_year BETWEEN 2000 AND 2023\n  AND k.keyword ILIKE '%action%';", "sql2": "SELECT actor_name,\n       actor_gender,\n       COUNT(movie_title) AS movie_count,\n       ARRAY_AGG(DISTINCT movie_title) AS movies\nFROM s1\nGROUP BY actor_name, actor_gender\nHAVING COUNT(movie_title) > 5\nORDER BY movie_count DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "5765.sql", "original_sql": "\nSELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    STRING_AGG(DISTINCT k.keyword, ', ') AS keywords,\n    STRING_AGG(DISTINCT c.name, ', ') AS companies,\n    COUNT(DISTINCT ci.id) AS role_count\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    aka_title t ON ci.movie_id = t.movie_id\nLEFT JOIN \n    movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN \n    keyword k ON mk.keyword_id = k.id\nLEFT JOIN \n    movie_companies mc ON t.id = mc.movie_id\nLEFT JOIN \n    company_name c ON mc.company_id = c.id\nWHERE \n    a.name IS NOT NULL\n    AND t.production_year BETWEEN 2000 AND 2020\nGROUP BY \n    a.name, t.title, t.production_year\nHAVING \n    COUNT(DISTINCT ci.role_id) > 2\nORDER BY \n    t.production_year DESC, a.name;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "5823.sql", "original_sql": "WITH ranked_actors AS (\n    SELECT a.id AS actor_id, a.name, COUNT(ci.movie_id) AS movie_count\n    FROM aka_name a\n    JOIN cast_info ci ON a.person_id = ci.person_id\n    GROUP BY a.id, a.name\n),\ntop_movies AS (\n    SELECT t.title, t.production_year, COUNT(DISTINCT ci.person_id) AS actor_count\n    FROM aka_title t\n    JOIN cast_info ci ON t.id = ci.movie_id\n    GROUP BY t.id, t.title, t.production_year\n    ORDER BY actor_count DESC\n    LIMIT 10\n),\ndetailed_info AS (\n    SELECT tm.title, tm.production_year, ra.name AS actor_name, ra.movie_count\n    FROM top_movies tm\n    JOIN ranked_actors ra ON ra.movie_count > 2\n)\nSELECT di.title, di.production_year, di.actor_name, di.movie_count\nFROM detailed_info di\nORDER BY di.production_year DESC, di.actor_name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT a.id AS actor_id,\n       a.name,\n       COUNT(ci.movie_id) AS movie_count\nFROM   aka_name a\nJOIN   cast_info ci ON a.person_id = ci.person_id\nGROUP BY a.id, a.name\nHAVING COUNT(ci.movie_id) > 2;", "sql2": "WITH top_movies AS (\n    SELECT t.title,\n           t.production_year,\n           COUNT(DISTINCT ci.person_id) AS actor_count\n    FROM   aka_title t\n    JOIN   cast_info ci ON t.id = ci.movie_id\n    GROUP BY t.id, t.title, t.production_year\n    ORDER BY actor_count DESC\n    LIMIT 10\n)\nSELECT tm.title,\n       tm.production_year,\n       s1.name AS actor_name,\n       s1.movie_count\nFROM   top_movies tm\nCROSS JOIN s1\nORDER BY tm.production_year DESC,\n         s1.name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "5882.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    c.kind AS company_type,\n    k.keyword AS movie_keyword\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    t.production_year BETWEEN 2000 AND 2020\n    AND c.kind ILIKE '%production%'\n    AND k.keyword ILIKE '%action%'\nORDER BY \n    t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS movie_id,\n       t.title,\n       t.production_year,\n       c.kind AS company_type,\n       k.keyword AS movie_keyword\nFROM title t\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE t.production_year BETWEEN 2000 AND 2020\n  AND c.kind ILIKE '%production%'\n  AND k.keyword ILIKE '%action%';", "sql2": "SELECT a.name AS actor_name,\n       s1.title AS movie_title,\n       s1.production_year,\n       s1.company_type,\n       s1.movie_keyword\nFROM s1\nJOIN cast_info ci ON s1.movie_id = ci.movie_id\nJOIN aka_name a ON ci.person_id = a.person_id\nORDER BY s1.production_year DESC, a.name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "5897.sql", "original_sql": "\nSELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    ct.kind AS company_type,\n    COUNT(DISTINCT k.keyword) AS keyword_count,\n    COUNT(DISTINCT p.info) AS personal_info_count\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nLEFT JOIN \n    person_info p ON a.person_id = p.person_id\nWHERE \n    t.production_year BETWEEN 2000 AND 2023\n    AND ct.kind = 'Distributor'\nGROUP BY \n    a.name, t.title, ct.kind\nORDER BY \n    keyword_count DESC, personal_info_count DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT DISTINCT a.id AS actor_id,\n       a.name AS actor_name,\n       t.id AS movie_id,\n       t.title AS movie_title,\n       ct.kind AS company_type\nFROM   aka_name a\nJOIN   cast_info ci ON a.person_id = ci.person_id\nJOIN   title t ON ci.movie_id = t.id\nJOIN   movie_companies mc ON t.id = mc.movie_id\nJOIN   company_type ct ON mc.company_type_id = ct.id\nWHERE  t.production_year BETWEEN 2000 AND 2023\n  AND  ct.kind = 'Distributor';", "sql2": "SELECT s1.actor_name,\n       s1.movie_title,\n       s1.company_type,\n       COUNT(DISTINCT k.keyword) AS keyword_count,\n       COUNT(DISTINCT p.info) AS personal_info_count\nFROM   s1\nJOIN   movie_keyword mk ON s1.movie_id = mk.movie_id\nJOIN   keyword k ON mk.keyword_id = k.id\nLEFT JOIN person_info p ON s1.actor_id = p.person_id\nGROUP BY s1.actor_name, s1.movie_title, s1.company_type\nORDER BY keyword_count DESC, personal_info_count DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "5982.sql", "original_sql": "\nSELECT \n    a.name AS actor_name, \n    t.title AS movie_title, \n    ct.kind AS company_type, \n    k.keyword AS movie_keyword, \n    p.info AS person_info, \n    COUNT(DISTINCT c.person_id) AS total_casts\nFROM \n    aka_name a \nJOIN \n    cast_info c ON a.person_id = c.person_id \nJOIN \n    aka_title t ON c.movie_id = t.movie_id \nJOIN \n    movie_companies mc ON t.id = mc.movie_id \nJOIN \n    company_type ct ON mc.company_type_id = ct.id \nJOIN \n    keyword k ON t.id = k.id \nJOIN \n    person_info p ON a.person_id = p.person_id \nWHERE \n    t.production_year > 2000 \n    AND ct.kind LIKE '%production%' \nGROUP BY \n    a.name, t.title, ct.kind, k.keyword, p.info \nORDER BY \n    total_casts DESC, t.title ASC \nLIMIT 50;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT a.name AS actor_name,\n       t.title AS movie_title,\n       ct.kind AS company_type,\n       k.keyword AS movie_keyword,\n       p.info AS person_info,\n       c.person_id\nFROM aka_name a\nJOIN cast_info c ON a.person_id = c.person_id\nJOIN aka_title t ON c.movie_id = t.movie_id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type ct ON mc.company_type_id = ct.id\nJOIN keyword k ON t.id = k.id\nJOIN person_info p ON a.person_id = p.person_id\nWHERE t.production_year > 2000\n  AND ct.kind LIKE '%production%';", "sql2": "SELECT actor_name,\n       movie_title,\n       company_type,\n       movie_keyword,\n       person_info,\n       COUNT(DISTINCT person_id) AS total_casts\nFROM s1\nGROUP BY actor_name, movie_title, company_type, movie_keyword, person_info\nORDER BY total_casts DESC, movie_title ASC\nLIMIT 50;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "6019.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    c.kind AS cast_type,\n    STRING_AGG(DISTINCT k.keyword, ', ') AS keywords\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    comp_cast_type c ON ci.person_role_id = c.id\nLEFT JOIN \n    movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    t.production_year >= 2000 \n    AND a.name IS NOT NULL\nGROUP BY \n    a.name, t.title, t.production_year, c.kind\nORDER BY \n    t.production_year DESC, actor_name;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "6050.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.nr_order AS role_order,\n    k.keyword AS movie_keyword,\n    cc.kind AS company_type,\n    mi.info AS movie_info_type\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    title t ON c.movie_id = t.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    company_type cc ON mc.company_type_id = cc.id\nJOIN \n    complete_cast cc2 ON t.id = cc2.movie_id\nJOIN \n    movie_info mi ON t.id = mi.movie_id\nWHERE \n    a.name IS NOT NULL\n    AND t.production_year >= 2000\n    AND cc.kind = 'production'\nORDER BY \n    t.production_year DESC, a.name ASC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT DISTINCT t.id AS movie_id, t.title, t.production_year FROM title t JOIN movie_companies mc ON t.id = mc.movie_id JOIN company_type ct ON mc.company_type_id = ct.id WHERE t.production_year >= 2000 AND ct.kind = 'production'", "sql2": "SELECT a.name AS actor_name, s1.title AS movie_title, c.nr_order AS role_order, k.keyword AS movie_keyword, 'production' AS company_type, mi.info AS movie_info_type FROM s1 JOIN cast_info c ON s1.movie_id = c.movie_id JOIN aka_name a ON a.person_id = c.person_id JOIN movie_keyword mk ON s1.movie_id = mk.movie_id JOIN keyword k ON mk.keyword_id = k.id JOIN movie_info mi ON s1.movie_id = mi.movie_id WHERE a.name IS NOT NULL ORDER BY s1.production_year DESC, a.name ASC", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "6084.sql", "original_sql": "\nSELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.kind AS company_type,\n    COUNT(ci.person_id) AS total_cast,\n    AVG(CAST(mi.info AS numeric)) AS avg_movie_rating\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    aka_title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_info mi ON t.id = mi.movie_id\nWHERE \n    t.production_year > 2000\n    AND c.kind = 'Production'\nGROUP BY \n    a.name, t.title, c.kind, mi.info\nHAVING \n    COUNT(ci.person_id) > 3\nORDER BY \n    avg_movie_rating DESC, total_cast DESC\nLIMIT 10;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH filtered AS (\n    SELECT a.name AS actor_name,\n           t.title AS movie_title,\n           c.kind AS company_type,\n           ci.person_id,\n           CAST(mi.info AS numeric) AS rating_val,\n           mi.info AS rating_info\n    FROM aka_name a\n    JOIN cast_info ci ON a.person_id = ci.person_id\n    JOIN aka_title t ON ci.movie_id = t.id\n    JOIN movie_companies mc ON t.id = mc.movie_id\n    JOIN company_type c ON mc.company_type_id = c.id\n    JOIN movie_info mi ON t.id = mi.movie_id\n    WHERE t.production_year > 2000\n      AND c.kind = 'Production'\n)\nSELECT actor_name,\n       movie_title,\n       company_type,\n       COUNT(person_id) AS total_cast,\n       AVG(rating_val) AS avg_movie_rating,\n       rating_info\nFROM filtered\nGROUP BY actor_name, movie_title, company_type, rating_info\nHAVING COUNT(person_id) > 3;", "sql2": "SELECT actor_name,\n       movie_title,\n       company_type,\n       total_cast,\n       avg_movie_rating\nFROM s1\nORDER BY avg_movie_rating DESC, total_cast DESC\nLIMIT 10;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "6123.sql", "original_sql": "SELECT \n    a.name AS actor_name, \n    t.title AS movie_title, \n    c.nr_order AS cast_order, \n    p.info AS actor_info, \n    k.keyword AS movie_keyword, \n    co.name AS company_name, \n    ct.kind AS company_type \nFROM \n    aka_name a \nJOIN \n    cast_info c ON a.person_id = c.person_id \nJOIN \n    title t ON c.movie_id = t.id \nLEFT JOIN \n    movie_keyword mk ON t.id = mk.movie_id \nLEFT JOIN \n    keyword k ON mk.keyword_id = k.id \nJOIN \n    movie_companies mc ON t.id = mc.movie_id \nJOIN \n    company_name co ON mc.company_id = co.id \nJOIN \n    company_type ct ON mc.company_type_id = ct.id \nLEFT JOIN \n    person_info p ON a.person_id = p.person_id \nWHERE \n    t.production_year >= 2000 \n    AND co.country_code = 'USA' \n    AND ct.kind = 'Distributor' \nORDER BY \n    t.production_year DESC, \n    a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS movie_id,\n       t.title AS movie_title,\n       t.production_year,\n       co.name AS company_name,\n       ct.kind AS company_type\nFROM title t\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_name co ON mc.company_id = co.id\nJOIN company_type ct ON mc.company_type_id = ct.id\nWHERE t.production_year >= 2000\n  AND co.country_code = 'USA'\n  AND ct.kind = 'Distributor'", "sql2": "SELECT a.name AS actor_name,\n       s1.movie_title,\n       c.nr_order AS cast_order,\n       p.info AS actor_info,\n       k.keyword AS movie_keyword,\n       s1.company_name,\n       s1.company_type\nFROM s1\nJOIN cast_info c ON s1.movie_id = c.movie_id\nJOIN aka_name a ON a.person_id = c.person_id\nLEFT JOIN movie_keyword mk ON s1.movie_id = mk.movie_id\nLEFT JOIN keyword k ON mk.keyword_id = k.id\nLEFT JOIN person_info p ON a.person_id = p.person_id\nORDER BY s1.production_year DESC, a.name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "6131.sql", "original_sql": "\nSELECT \n    a.name AS actor_name, \n    t.title AS movie_title, \n    t.production_year, \n    STRING_AGG(DISTINCT c.kind, ',') AS company_types,\n    STRING_AGG(DISTINCT k.keyword, ',') AS keywords\nFROM \n    cast_info ci\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    aka_title t ON ci.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    t.production_year BETWEEN 2000 AND 2020\n    AND c.kind IN ('Producer', 'Distributor')\nGROUP BY \n    a.name, t.title, t.production_year\nORDER BY \n    t.production_year DESC, a.name ASC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT a.name AS actor_name,\n       t.title AS movie_title,\n       t.production_year,\n       c.kind AS company_type,\n       k.keyword\nFROM cast_info ci\nJOIN aka_name a ON ci.person_id = a.person_id\nJOIN aka_title t ON ci.movie_id = t.movie_id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE t.production_year BETWEEN 2000 AND 2020\n  AND c.kind IN ('Producer','Distributor');", "sql2": "SELECT actor_name,\n       movie_title,\n       production_year,\n       STRING_AGG(DISTINCT company_type, ',') AS company_types,\n       STRING_AGG(DISTINCT keyword, ',') AS keywords\nFROM s1\nGROUP BY actor_name, movie_title, production_year\nORDER BY production_year DESC, actor_name ASC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "6242.sql", "original_sql": "SELECT \n    a.id AS aka_id,\n    a.name AS aka_name,\n    t.id AS title_id,\n    t.title AS movie_title,\n    t.production_year,\n    p.info AS person_info,\n    c.kind AS cast_kind\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    person_info p ON a.person_id = p.person_id\nJOIN \n    role_type r ON ci.role_id = r.id\nJOIN \n    comp_cast_type c ON ci.person_role_id = c.id\nWHERE \n    t.production_year >= 2000 AND \n    c.kind = 'actor'\nORDER BY \n    t.production_year DESC, \n    a.name ASC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT a.id AS aka_id,\n       a.name AS aka_name,\n       t.id AS title_id,\n       t.title AS movie_title,\n       t.production_year,\n       p.info AS person_info,\n       c.kind AS cast_kind\nFROM   aka_name a\nJOIN   cast_info ci ON a.person_id = ci.person_id\nJOIN   title t ON ci.movie_id = t.id\nJOIN   person_info p ON a.person_id = p.person_id\nJOIN   role_type r ON ci.role_id = r.id\nJOIN   comp_cast_type c ON ci.person_role_id = c.id\nWHERE  t.production_year >= 2000\n  AND  c.kind = 'actor';", "sql2": "SELECT *\nFROM   s1\nORDER BY production_year DESC,\n         aka_name ASC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "6252.sql", "original_sql": "WITH RecursiveMovies AS (\n    SELECT \n        t.id AS movie_id, \n        t.title, \n        t.production_year, \n        m.name AS company_name,\n        STRING_AGG(DISTINCT k.keyword, ', ') AS keywords,\n        STRING_AGG(DISTINCT a.name, ', ') AS actors\n    FROM \n        aka_title t\n    JOIN \n        movie_companies mc ON t.id = mc.movie_id\n    JOIN \n        company_name m ON mc.company_id = m.id\n    LEFT JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    LEFT JOIN \n        keyword k ON mk.keyword_id = k.id\n    LEFT JOIN \n        cast_info ci ON t.id = ci.movie_id\n    LEFT JOIN \n        aka_name a ON ci.person_id = a.person_id\n    WHERE \n        t.production_year >= 2000\n    GROUP BY \n        t.id, t.title, t.production_year, m.name\n),\nStandardMovies AS (\n    SELECT \n        movie_id, \n        title, \n        production_year, \n        company_name, \n        keywords, \n        actors \n    FROM \n        RecursiveMovies\n)\nSELECT \n    sm.movie_id, \n    sm.title, \n    sm.production_year, \n    sm.company_name, \n    sm.keywords, \n    sm.actors,\n    COUNT(DISTINCT ci.id) AS total_cast_members\nFROM \n    StandardMovies sm\nLEFT JOIN \n    cast_info ci ON sm.movie_id = ci.movie_id\nGROUP BY \n    sm.movie_id, sm.title, sm.production_year, sm.company_name, sm.keywords, sm.actors\nORDER BY \n    sm.production_year DESC, \n    COUNT(DISTINCT ci.id) DESC\nLIMIT 50;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "6283.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.kind AS cast_type,\n    d.info AS additional_info,\n    k.keyword AS movie_keyword\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_info d ON t.id = d.movie_id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    comp_cast_type c ON ci.person_role_id = c.id\nWHERE \n    t.production_year BETWEEN 2000 AND 2023\n    AND c.kind ILIKE '%lead%'\nORDER BY \n    a.name, t.production_year DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    a.name AS actor_name,\n    t.id AS movie_id,\n    t.title AS movie_title,\n    t.production_year,\n    c.kind AS cast_type\nFROM aka_name a\nJOIN cast_info ci ON a.person_id = ci.person_id\nJOIN title t ON ci.movie_id = t.id\nJOIN comp_cast_type c ON ci.person_role_id = c.id\nWHERE t.production_year BETWEEN 2000 AND 2023\n  AND c.kind ILIKE '%lead%';", "sql2": "SELECT \n    s1.actor_name,\n    s1.movie_title,\n    s1.cast_type,\n    d.info AS additional_info,\n    k.keyword AS movie_keyword,\n    s1.production_year\nFROM s1\nJOIN movie_info d ON s1.movie_id = d.movie_id\nJOIN movie_keyword mk ON s1.movie_id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nORDER BY s1.actor_name, s1.production_year DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "6320.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.kind AS cast_type,\n    p.info AS person_info,\n    k.keyword AS movie_keyword\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    comp_cast_type c ON ci.person_role_id = c.id\nLEFT JOIN \n    person_info p ON a.person_id = p.person_id\nLEFT JOIN \n    movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    t.production_year >= 2000\n    AND c.kind IN ('actor', 'actress')\nORDER BY \n    t.production_year DESC, \n    a.name ASC\nLIMIT 50;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    a.name AS actor_name,\n    a.person_id,\n    t.id AS movie_id,\n    t.title AS movie_title,\n    c.kind AS cast_type,\n    t.production_year\nFROM aka_name a\nJOIN cast_info ci ON a.person_id = ci.person_id\nJOIN title t ON ci.movie_id = t.id\nJOIN comp_cast_type c ON ci.person_role_id = c.id\nWHERE t.production_year >= 2000\n  AND c.kind IN ('actor','actress');", "sql2": "SELECT \n    s1.actor_name,\n    s1.movie_title,\n    s1.cast_type,\n    p.info AS person_info,\n    k.keyword AS movie_keyword\nFROM s1\nLEFT JOIN person_info p ON s1.person_id = p.person_id\nLEFT JOIN movie_keyword mk ON s1.movie_id = mk.movie_id\nLEFT JOIN keyword k ON mk.keyword_id = k.id\nORDER BY s1.production_year DESC, s1.actor_name ASC\nLIMIT 50;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "6334.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    c.kind AS company_type,\n    k.keyword AS movie_keyword,\n    p.info AS person_info,\n    r.role AS role_description\nFROM \n    cast_info ci \nJOIN \n    aka_name a ON ci.person_id = a.person_id \nJOIN \n    title t ON ci.movie_id = t.id \nJOIN \n    movie_companies mc ON t.id = mc.movie_id \nJOIN \n    company_name cn ON mc.company_id = cn.id \nJOIN \n    company_type c ON mc.company_type_id = c.id \nJOIN \n    movie_keyword mk ON t.id = mk.movie_id \nJOIN \n    keyword k ON mk.keyword_id = k.id \nLEFT JOIN \n    person_info p ON a.id = p.person_id \nLEFT JOIN \n    role_type r ON ci.role_id = r.id \nWHERE \n    t.production_year >= 2000 \n    AND c.kind LIKE '%Film%' \nORDER BY \n    t.production_year DESC, \n    actor_name ASC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    ci.person_id,\n    ci.movie_id,\n    ci.role_id,\n    a.id AS aka_name_id,\n    mc.company_type_id,\n    mk.keyword_id\nFROM cast_info ci\nJOIN title t ON ci.movie_id = t.id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN aka_name a ON ci.person_id = a.person_id\nWHERE t.production_year >= 2000\n  AND c.kind LIKE '%Film%'", "sql2": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    c.kind AS company_type,\n    k.keyword AS movie_keyword,\n    p.info AS person_info,\n    r.role AS role_description\nFROM s1\nJOIN title t ON s1.movie_id = t.id\nJOIN aka_name a ON s1.aka_name_id = a.id\nJOIN company_type c ON s1.company_type_id = c.id\nJOIN keyword k ON s1.keyword_id = k.id\nLEFT JOIN person_info p ON s1.aka_name_id = p.person_id\nLEFT JOIN role_type r ON s1.role_id = r.id\nORDER BY t.production_year DESC, actor_name ASC", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "6352.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    c.kind AS company_type,\n    k.keyword AS movie_keyword,\n    r.role AS role_description,\n    COUNT(DISTINCT p.id) AS total_people_involved\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    role_type r ON ci.role_id = r.id\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    person_info p ON a.id = p.person_id\nWHERE \n    t.production_year >= 2000\n    AND c.kind IN ('Production', 'Distribution')\n    AND k.keyword LIKE '%action%'\nGROUP BY \n    a.name, t.title, t.production_year, c.kind, k.keyword, r.role\nORDER BY \n    total_people_involved DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT DISTINCT\n    a.id AS actor_id,\n    a.name AS actor_name,\n    t.id AS movie_id,\n    t.title AS movie_title,\n    t.production_year,\n    c.kind AS company_type,\n    k.keyword AS movie_keyword,\n    ci.role_id AS role_id\nFROM aka_name a\nJOIN cast_info ci ON a.person_id = ci.person_id\nJOIN title t ON ci.movie_id = t.id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE t.production_year >= 2000\n  AND c.kind IN ('Production','Distribution')\n  AND k.keyword LIKE '%action%';", "sql2": "SELECT \n    s.actor_name,\n    s.movie_title,\n    s.production_year,\n    s.company_type,\n    s.movie_keyword,\n    r.role AS role_description,\n    COUNT(DISTINCT p.id) AS total_people_involved\nFROM s1 s\nJOIN role_type r ON s.role_id = r.id\nJOIN complete_cast cc ON s.movie_id = cc.movie_id\nJOIN person_info p ON s.actor_id = p.person_id\nGROUP BY s.actor_name, s.movie_title, s.production_year, s.company_type, s.movie_keyword, r.role\nORDER BY total_people_involved DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "6436.sql", "original_sql": "WITH RankedMovies AS (\n    SELECT \n        t.title,\n        t.production_year,\n        COUNT(DISTINCT cas.person_id) AS actor_count,\n        AVG(CASE WHEN t.production_year >= 2000 THEN 1 ELSE 0 END) AS modern_ratio\n    FROM \n        title t\n    JOIN \n        movie_companies mc ON t.id = mc.movie_id\n    JOIN \n        company_name cn ON mc.company_id = cn.id\n    JOIN \n        complete_cast cc ON t.id = cc.movie_id\n    JOIN \n        cast_info cas ON cc.subject_id = cas.id\n    GROUP BY \n        t.id, t.title, t.production_year\n),\nHighActorMovies AS (\n    SELECT \n        rm.title,\n        rm.production_year,\n        rm.actor_count,\n        rm.modern_ratio\n    FROM \n        RankedMovies rm\n    WHERE \n        rm.actor_count > 10\n)\nSELECT \n    ham.title,\n    ham.production_year,\n    ham.actor_count,\n    ham.modern_ratio,\n    cn.name AS company_name\nFROM \n    HighActorMovies ham\nJOIN \n    movie_companies mc ON mc.movie_id = (SELECT id FROM title WHERE title = ham.title AND production_year = ham.production_year)\nJOIN \n    company_name cn ON mc.company_id = cn.id\nORDER BY \n    ham.actor_count DESC, ham.production_year ASC\nLIMIT 50;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "6443.sql", "original_sql": "\nWITH MovieStats AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        COUNT(ci.person_id) AS cast_count,\n        STRING_AGG(DISTINCT ak.name, ', ') AS actor_names,\n        COUNT(DISTINCT mk.keyword_id) AS keyword_count\n    FROM \n        title t\n    JOIN \n        complete_cast cc ON t.id = cc.movie_id\n    JOIN \n        cast_info ci ON cc.subject_id = ci.id\n    JOIN \n        aka_name ak ON ci.person_id = ak.person_id\n    LEFT JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    GROUP BY \n        t.id, t.title, t.production_year\n),\nCompanyStats AS (\n    SELECT \n        mc.movie_id,\n        COUNT(DISTINCT c.name) AS company_count,\n        STRING_AGG(DISTINCT c.name, ', ') AS company_names\n    FROM \n        movie_companies mc\n    JOIN \n        company_name c ON mc.company_id = c.id\n    GROUP BY \n        mc.movie_id\n)\nSELECT \n    ms.movie_id,\n    ms.title,\n    ms.production_year,\n    ms.cast_count,\n    ms.actor_names,\n    ms.keyword_count,\n    cs.company_count,\n    cs.company_names\nFROM \n    MovieStats ms\nLEFT JOIN \n    CompanyStats cs ON ms.movie_id = cs.movie_id\nWHERE \n    ms.production_year >= 2000\nORDER BY \n    ms.production_year DESC, ms.cast_count DESC, cs.company_count DESC;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "6491.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.kind AS company_type,\n    m.info AS movie_info,\n    k.keyword AS movie_keyword\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_info m ON t.id = m.movie_id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    a.name LIKE '%Smith%'\n    AND t.production_year > 2000\n    AND c.kind LIKE '%Production%'\nORDER BY \n    t.production_year DESC, \n    a.name ASC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT DISTINCT a.name AS actor_name,\n                t.title AS movie_title,\n                c.kind AS company_type,\n                t.id AS movie_id,\n                t.production_year AS production_year\nFROM aka_name a\nJOIN cast_info ci ON a.person_id = ci.person_id\nJOIN title t ON ci.movie_id = t.id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nWHERE a.name LIKE '%Smith%'\n  AND t.production_year > 2000\n  AND c.kind LIKE '%Production%';", "sql2": "SELECT s1.actor_name,\n       s1.movie_title,\n       s1.company_type,\n       m.info AS movie_info,\n       k.keyword AS movie_keyword\nFROM s1\nJOIN movie_info m ON s1.movie_id = m.movie_id\nJOIN movie_keyword mk ON s1.movie_id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nORDER BY s1.production_year DESC, s1.actor_name ASC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "6497.sql", "original_sql": "SELECT \n    t.title AS movie_title,\n    a.name AS actor_name,\n    c.kind AS company_type,\n    k.keyword AS movie_keyword,\n    pi.info AS person_info\nFROM \n    title t\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info ci ON ci.movie_id = cc.movie_id AND ci.person_id = cc.subject_id\nJOIN \n    aka_name a ON a.person_id = ci.person_id\nJOIN \n    movie_companies mc ON mc.movie_id = t.id \nJOIN \n    company_name cn ON cn.id = mc.company_id\nJOIN \n    company_type c ON c.id = mc.company_type_id\nJOIN \n    movie_keyword mk ON mk.movie_id = t.id\nJOIN \n    keyword k ON k.id = mk.keyword_id\nLEFT JOIN \n    person_info pi ON pi.person_id = a.person_id\nWHERE \n    t.production_year > 2000 AND \n    k.keyword LIKE '%action%' AND \n    c.kind = 'Production'\nORDER BY \n    t.production_year DESC, \n    a.name ASC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT DISTINCT t.id AS movie_id,\n       t.title AS movie_title,\n       k.keyword AS movie_keyword,\n       c.kind AS company_type,\n       t.production_year\nFROM title t\nJOIN movie_keyword mk ON mk.movie_id = t.id\nJOIN keyword k ON k.id = mk.keyword_id\nJOIN movie_companies mc ON mc.movie_id = t.id\nJOIN company_type c ON c.id = mc.company_type_id\nWHERE t.production_year > 2000\n  AND k.keyword LIKE '%action%'\n  AND c.kind = 'Production';", "sql2": "SELECT \n    s1.movie_title,\n    a.name AS actor_name,\n    s1.company_type,\n    s1.movie_keyword,\n    pi.info AS person_info\nFROM s1\nJOIN complete_cast cc ON s1.movie_id = cc.movie_id\nJOIN cast_info ci ON ci.movie_id = cc.movie_id AND ci.person_id = cc.subject_id\nJOIN aka_name a ON a.person_id = ci.person_id\nLEFT JOIN person_info pi ON pi.person_id = a.person_id\nORDER BY s1.production_year DESC, a.name ASC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "6519.sql", "original_sql": "WITH movie_stats AS (\n    SELECT \n        a.title AS movie_title,\n        a.production_year,\n        COUNT(DISTINCT c.person_id) AS num_actors,\n        COUNT(DISTINCT k.keyword) AS num_keywords,\n        STRING_AGG(DISTINCT co.name, ', ') AS companies\n    FROM \n        aka_title a\n    JOIN \n        complete_cast cc ON a.id = cc.movie_id\n    JOIN \n        cast_info c ON cc.subject_id = c.id\n    LEFT JOIN \n        movie_keyword mk ON a.id = mk.movie_id\n    LEFT JOIN \n        keyword k ON mk.keyword_id = k.id\n    LEFT JOIN \n        movie_companies mc ON a.id = mc.movie_id\n    LEFT JOIN \n        company_name co ON mc.company_id = co.id\n    WHERE \n        a.production_year BETWEEN 2000 AND 2023\n    GROUP BY \n        a.id, a.title, a.production_year\n)\nSELECT \n    movie_title,\n    production_year,\n    num_actors,\n    num_keywords,\n    companies\nFROM \n    movie_stats\nWHERE \n    num_actors > 5\nORDER BY \n    production_year DESC, num_actors DESC\nLIMIT 10;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT a.id AS movie_id,\n       a.title AS movie_title,\n       a.production_year,\n       c.person_id,\n       k.keyword,\n       co.name AS company_name\nFROM   aka_title a\nJOIN   complete_cast cc ON a.id = cc.movie_id\nJOIN   cast_info c ON cc.subject_id = c.id\nLEFT JOIN movie_keyword mk ON a.id = mk.movie_id\nLEFT JOIN keyword k ON mk.keyword_id = k.id\nLEFT JOIN movie_companies mc ON a.id = mc.movie_id\nLEFT JOIN company_name co ON mc.company_id = co.id\nWHERE  a.production_year BETWEEN 2000 AND 2023;", "sql2": "SELECT   movie_title,\n         production_year,\n         COUNT(DISTINCT person_id) AS num_actors,\n         COUNT(DISTINCT keyword) AS num_keywords,\n         STRING_AGG(DISTINCT company_name, ', ') AS companies\nFROM     s1\nGROUP BY movie_id, movie_title, production_year\nHAVING   COUNT(DISTINCT person_id) > 5\nORDER BY production_year DESC, num_actors DESC\nLIMIT 10;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "6569.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.kind AS cast_type,\n    cc.name AS company_name,\n    mi.info AS movie_info,\n    k.keyword AS movie_keyword\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    comp_cast_type c ON ci.person_role_id = c.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cc ON mc.company_id = cc.id\nLEFT JOIN \n    movie_info mi ON t.id = mi.movie_id\nLEFT JOIN \n    movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    t.production_year > 2000\n    AND cc.country_code = 'USA'\nORDER BY \n    a.name, t.production_year DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT a.name AS actor_name,\n       t.title AS movie_title,\n       c.kind AS cast_type,\n       cc.name AS company_name,\n       t.id AS movie_id,\n       t.production_year AS prod_year\nFROM   aka_name a\nJOIN   cast_info ci ON a.person_id = ci.person_id\nJOIN   title t ON ci.movie_id = t.id\nJOIN   comp_cast_type c ON ci.person_role_id = c.id\nJOIN   movie_companies mc ON t.id = mc.movie_id\nJOIN   company_name cc ON mc.company_id = cc.id\nWHERE  t.production_year > 2000\n  AND  cc.country_code = 'USA'", "sql2": "SELECT s1.actor_name,\n       s1.movie_title,\n       s1.cast_type,\n       s1.company_name,\n       mi.info AS movie_info,\n       k.keyword AS movie_keyword\nFROM   s1\nLEFT JOIN movie_info mi ON s1.movie_id = mi.movie_id\nLEFT JOIN movie_keyword mk ON s1.movie_id = mk.movie_id\nLEFT JOIN keyword k ON mk.keyword_id = k.id\nORDER BY s1.actor_name,\n         s1.prod_year DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "6596.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.kind AS company_type,\n    STRING_AGG(DISTINCT k.keyword, ', ') AS keywords,\n    COUNT(DISTINCT p.info) AS num_personal_infos\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nLEFT JOIN \n    movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN \n    keyword k ON mk.keyword_id = k.id\nLEFT JOIN \n    person_info p ON a.person_id = p.person_id\nWHERE \n    t.production_year >= 2000\n    AND c.kind LIKE '%Production%'\nGROUP BY \n    a.name, t.title, c.kind\nORDER BY \n    actor_name, movie_title;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'movie_id' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column kw.movie_id\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"movie_id\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"kw\" }), name: \"movie_id\" }, Column { relation: Some(Bare { table: \"kw\" }), name: \"keywords\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "6643.sql", "original_sql": "WITH MovieDetails AS (\n    SELECT \n        t.title AS movie_title,\n        t.production_year,\n        c.kind AS company_type,\n        ak.name AS actor_name,\n        p.info AS person_info,\n        k.keyword AS movie_keyword\n    FROM title t\n    JOIN movie_companies mc ON t.id = mc.movie_id\n    JOIN company_name cn ON mc.company_id = cn.id\n    JOIN company_type c ON mc.company_type_id = c.id\n    JOIN cast_info ci ON t.id = ci.movie_id\n    JOIN aka_name ak ON ci.person_id = ak.person_id\n    LEFT JOIN person_info p ON ak.person_id = p.person_id\n    LEFT JOIN movie_keyword mk ON t.id = mk.movie_id\n    LEFT JOIN keyword k ON mk.keyword_id = k.id\n    WHERE t.production_year > 2000\n      AND c.kind = 'Distributor'\n      AND ak.name IS NOT NULL\n)\nSELECT \n    movie_title,\n    production_year,\n    COUNT(DISTINCT actor_name) AS total_actors,\n    STRING_AGG(DISTINCT movie_keyword, ', ') AS keywords,\n    STRING_AGG(DISTINCT person_info, ', ') AS additional_information\nFROM MovieDetails\nGROUP BY movie_title, production_year\nHAVING COUNT(DISTINCT actor_name) > 5\nORDER BY production_year DESC, movie_title;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT \n    t.title AS movie_title,\n    t.production_year,\n    ak.name AS actor_name,\n    p.info AS person_info,\n    k.keyword AS movie_keyword\nFROM title t\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN company_type c ON mc.company_type_id = c.id\nJOIN cast_info ci ON t.id = ci.movie_id\nJOIN aka_name ak ON ci.person_id = ak.person_id\nLEFT JOIN person_info p ON ak.person_id = p.person_id\nLEFT JOIN movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN keyword k ON mk.keyword_id = k.id\nWHERE t.production_year > 2000\n  AND c.kind = 'Distributor'\n  AND ak.name IS NOT NULL;", "sql2": "SELECT \n    movie_title,\n    production_year,\n    COUNT(DISTINCT actor_name) AS total_actors,\n    STRING_AGG(DISTINCT movie_keyword, ', ') AS keywords,\n    STRING_AGG(DISTINCT person_info, ', ') AS additional_information\nFROM s1\nGROUP BY movie_title, production_year\nHAVING COUNT(DISTINCT actor_name) > 5\nORDER BY production_year DESC, movie_title;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "6668.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    c.nr_order AS cast_order,\n    p.info AS person_info,\n    k.keyword AS movie_keyword,\n    co.name AS company_name,\n    ct.kind AS company_type,\n    ti.info AS additional_info\nFROM \n    aka_name AS a\nJOIN \n    cast_info AS c ON a.person_id = c.person_id\nJOIN \n    title AS t ON c.movie_id = t.id\nLEFT JOIN \n    person_info AS p ON a.person_id = p.person_id\nLEFT JOIN \n    movie_keyword AS mk ON t.id = mk.movie_id\nLEFT JOIN \n    keyword AS k ON mk.keyword_id = k.id\nLEFT JOIN \n    movie_companies AS mc ON t.id = mc.movie_id\nLEFT JOIN \n    company_name AS co ON mc.company_id = co.id\nLEFT JOIN \n    company_type AS ct ON mc.company_type_id = ct.id\nLEFT JOIN \n    movie_info AS ti ON t.id = ti.movie_id\nWHERE \n    t.production_year > 2000 \n    AND co.country_code IN ('USA', 'UK') \n    AND a.name IS NOT NULL\nORDER BY \n    a.name, t.production_year DESC, c.nr_order;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "6718.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    ci.nr_order AS role_order,\n    ct.kind AS cast_type,\n    cn.name AS company_name,\n    mi.info AS movie_info,\n    k.keyword AS movie_keyword\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    kind_type kt ON t.kind_id = kt.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nJOIN \n    movie_info mi ON t.id = mi.movie_id\nJOIN \n    info_type it ON mi.info_type_id = it.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    t.production_year >= 2000\n    AND ct.kind = 'Distributor'\nORDER BY \n    t.production_year DESC,\n    a.name ASC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    t.id AS movie_id,\n    t.title AS movie_title,\n    t.production_year,\n    cn.name AS company_name,\n    ct.kind AS cast_type,\n    mi.info AS movie_info,\n    k.keyword AS movie_keyword\nFROM title t\nJOIN kind_type kt ON t.kind_id = kt.id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN company_type ct ON mc.company_type_id = ct.id\nJOIN movie_info mi ON t.id = mi.movie_id\nJOIN info_type it ON mi.info_type_id = it.id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE t.production_year >= 2000\n  AND ct.kind = 'Distributor';", "sql2": "SELECT\n    a.name AS actor_name,\n    s1.movie_title,\n    ci.nr_order AS role_order,\n    s1.cast_type,\n    s1.company_name,\n    s1.movie_info,\n    s1.movie_keyword\nFROM aka_name a\nJOIN cast_info ci ON a.person_id = ci.person_id\nJOIN s1 ON ci.movie_id = s1.movie_id\nORDER BY s1.production_year DESC,\n         a.name ASC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "6743.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.kind AS company_type,\n    COUNT(DISTINCT m.keyword_id) AS keyword_count,\n    MAX(CASE WHEN i.info_type_id = 1 THEN i.info END) AS movie_tagline,\n    MAX(CASE WHEN i.info_type_id = 2 THEN i.info END) AS movie_synopsis\nFROM \n    cast_info ci\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    aka_title t ON ci.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_keyword m ON t.id = m.movie_id\nJOIN \n    movie_info i ON t.id = i.movie_id\nWHERE \n    t.production_year > 2000\n    AND c.kind LIKE 'Production%'\nGROUP BY \n    a.name, t.title, c.kind\nORDER BY \n    keyword_count DESC, a.name, t.title\nLIMIT 50;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'movie_id' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column ci.movie_id\", span: None }, DiagnosticNote { message: \"possible column ci.role_id\", span: None }, DiagnosticNote { message: \"possible column t.movie_id\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"movie_id\" }, valid_fields: [Column { relation: Some(Bare { table: \"ci\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"person_id\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"movie_id\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"person_role_id\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"note\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"nr_order\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"role_id\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"person_id\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"name\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"imdb_index\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"name_pcode_cf\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"name_pcode_nf\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"surname_pcode\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"md5sum\" }, Column { relation: Some(Bare { table: \"t\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"t\" }), name: \"movie_id\" }, Column { relation: Some(Bare { table: \"t\" }), name: \"title\" }, Column { relation: Some(Bare { table: \"t\" }), name: \"imdb_index\" }, Column { relation: Some(Bare { table: \"t\" }), name: \"kind_id\" }, Column { relation: Some(Bare { table: \"t\" }), name: \"production_year\" }, Column { relation: Some(Bare { table: \"t\" }), name: \"phonetic_code\" }, Column { relation: Some(Bare { table: \"t\" }), name: \"episode_of_id\" }, Column { relation: Some(Bare { table: \"t\" }), name: \"season_nr\" }, Column { relation: Some(Bare { table: \"t\" }), name: \"episode_nr\" }, Column { relation: Some(Bare { table: \"t\" }), name: \"note\" }, Column { relation: Some(Bare { table: \"t\" }), name: \"md5sum\" }, Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "6865.sql", "original_sql": "\nSELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    c.kind AS cast_type,\n    STRING_AGG(DISTINCT k.keyword, ',') AS keywords,\n    STRING_AGG(DISTINCT cn.name, ',') AS companies\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    comp_cast_type c ON ci.person_role_id = c.id\nLEFT JOIN \n    movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN \n    keyword k ON mk.keyword_id = k.id\nLEFT JOIN \n    movie_companies mc ON t.id = mc.movie_id\nLEFT JOIN \n    company_name cn ON mc.company_id = cn.id\nWHERE \n    t.production_year >= 2000 \n    AND a.name IS NOT NULL\nGROUP BY \n    a.name, t.title, t.production_year, c.kind\nORDER BY \n    t.production_year DESC, a.name;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "7004.sql", "original_sql": "\nSELECT \n    a.name AS actor_name, \n    t.title AS movie_title, \n    t.production_year, \n    STRING_AGG(DISTINCT k.keyword, ', ') AS keywords, \n    c.kind AS company_type \nFROM \n    aka_name a \nJOIN \n    cast_info ci ON a.person_id = ci.person_id \nJOIN \n    aka_title t ON ci.movie_id = t.movie_id \nJOIN \n    movie_companies mc ON t.id = mc.movie_id \nJOIN \n    company_type c ON mc.company_type_id = c.id \nLEFT JOIN \n    movie_keyword mk ON t.id = mk.movie_id \nLEFT JOIN \n    keyword k ON mk.keyword_id = k.id \nWHERE \n    t.production_year >= 2000 \nGROUP BY \n    a.name, t.title, t.production_year, c.kind \nORDER BY \n    t.production_year DESC, a.name;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "7072.sql", "original_sql": "\nSELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.role_id AS role,\n    cc.kind AS casting_type,\n    m.name AS company_name,\n    k.keyword AS movie_keyword,\n    i.info AS movie_info,\n    COUNT(DISTINCT a.id) AS actor_count\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    title t ON c.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name m ON mc.company_id = m.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    movie_info mi ON t.id = mi.movie_id\nJOIN \n    info_type i ON mi.info_type_id = i.id\nJOIN \n    comp_cast_type cc ON c.person_role_id = cc.id\nWHERE \n    t.production_year BETWEEN 2000 AND 2023\n    AND k.keyword LIKE '%action%'\nGROUP BY \n    a.name, t.title, c.role_id, cc.kind, m.name, k.keyword, i.info, t.production_year\nORDER BY \n    actor_count DESC, t.production_year DESC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT DISTINCT t.id AS movie_id,\n                t.title,\n                t.production_year,\n                k.keyword\nFROM title t\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE t.production_year BETWEEN 2000 AND 2023\n  AND k.keyword LIKE '%action%';", "sql2": "SELECT \n    a.name AS actor_name,\n    s1.title AS movie_title,\n    c.role_id AS role,\n    cc.kind AS casting_type,\n    m.name AS company_name,\n    s1.keyword AS movie_keyword,\n    i.info AS movie_info,\n    COUNT(DISTINCT a.id) AS actor_count\nFROM s1\nJOIN cast_info c ON s1.movie_id = c.movie_id\nJOIN aka_name a ON a.person_id = c.person_id\nJOIN movie_companies mc ON s1.movie_id = mc.movie_id\nJOIN company_name m ON mc.company_id = m.id\nJOIN movie_info mi ON s1.movie_id = mi.movie_id\nJOIN info_type i ON mi.info_type_id = i.id\nJOIN comp_cast_type cc ON c.person_role_id = cc.id\nGROUP BY \n    a.name,\n    s1.title,\n    c.role_id,\n    cc.kind,\n    m.name,\n    s1.keyword,\n    i.info,\n    s1.production_year\nORDER BY \n    actor_count DESC,\n    s1.production_year DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "7170.sql", "original_sql": "\nSELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    r.role AS character_name,\n    ct.kind AS company_type,\n    COUNT(DISTINCT k.keyword) AS keyword_count\nFROM \n    cast_info ci\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    role_type r ON ci.role_id = r.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    t.production_year BETWEEN 2000 AND 2023 \n    AND ct.kind LIKE 'Producer%'\nGROUP BY \n    a.name, t.title, t.production_year, r.role, ct.kind\nORDER BY \n    keyword_count DESC, t.production_year DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS movie_id,\n       COUNT(DISTINCT k.keyword) AS keyword_count\nFROM   movie_keyword mk\nJOIN   keyword k ON mk.keyword_id = k.id\nJOIN   title t ON mk.movie_id = t.id\nWHERE  t.production_year BETWEEN 2000 AND 2023\nGROUP BY t.id;", "sql2": "SELECT a.name AS actor_name,\n       t.title AS movie_title,\n       t.production_year,\n       r.role AS character_name,\n       ct.kind AS company_type,\n       s1.keyword_count\nFROM   cast_info ci\nJOIN   aka_name a ON ci.person_id = a.person_id\nJOIN   title t ON ci.movie_id = t.id\nJOIN   role_type r ON ci.role_id = r.id\nJOIN   movie_companies mc ON t.id = mc.movie_id\nJOIN   company_type ct ON mc.company_type_id = ct.id\nJOIN   s1 ON t.id = s1.movie_id\nWHERE  t.production_year BETWEEN 2000 AND 2023\n  AND  ct.kind LIKE 'Producer%'\nGROUP BY a.name, t.title, t.production_year, r.role, ct.kind, s1.keyword_count\nORDER BY s1.keyword_count DESC, t.production_year DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "7189.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    c.note AS cast_note,\n    ci.kind AS cast_type,\n    cn.name AS company_name,\n    mi.info AS movie_info,\n    k.keyword AS movie_keyword\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    title t ON c.movie_id = t.id\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    company_name cn ON cc.subject_id = cn.imdb_id\nJOIN \n    movie_info mi ON t.id = mi.movie_id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    comp_cast_type ci ON c.person_role_id = ci.id\nWHERE \n    t.production_year > 2000\n    AND ci.kind = 'Actor'\nORDER BY \n    t.production_year DESC, \n    a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT a.name AS aka_name,\n       t.id AS movie_id,\n       t.title AS movie_title,\n       c.note AS cast_note,\n       ci.kind AS cast_type,\n       t.production_year,\n       cc.subject_id AS subject_id\nFROM   aka_name a\nJOIN   cast_info c        ON a.person_id = c.person_id\nJOIN   title t            ON c.movie_id = t.id\nJOIN   complete_cast cc  ON t.id = cc.movie_id\nJOIN   comp_cast_type ci ON c.person_role_id = ci.id\nWHERE  t.production_year > 2000\n  AND  ci.kind = 'Actor';", "sql2": "SELECT s1.aka_name,\n       s1.movie_title,\n       s1.cast_note,\n       s1.cast_type,\n       cn.name AS company_name,\n       mi.info AS movie_info,\n       k.keyword AS movie_keyword\nFROM   s1\nLEFT JOIN company_name cn   ON s1.subject_id = cn.imdb_id\nLEFT JOIN movie_info mi      ON s1.movie_id = mi.movie_id\nLEFT JOIN movie_keyword mk   ON s1.movie_id = mk.movie_id\nLEFT JOIN keyword k          ON mk.keyword_id = k.id\nORDER BY s1.production_year DESC, s1.aka_name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "7214.sql", "original_sql": "\nSELECT\n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.role_id AS role_id,\n    ct.kind AS company_type,\n    COUNT(DISTINCT m.company_id) AS company_count,\n    AVG(CAST(mi.info AS INTEGER)) AS avg_movie_rating\nFROM\n    aka_name a\nJOIN\n    cast_info c ON a.person_id = c.person_id\nJOIN\n    aka_title t ON c.movie_id = t.id\nLEFT JOIN\n    movie_companies m ON t.id = m.movie_id\nLEFT JOIN\n    company_type ct ON m.company_type_id = ct.id\nLEFT JOIN\n    movie_info mi ON t.id = mi.movie_id AND mi.info_type_id = (SELECT id FROM info_type WHERE info = 'rating')\nWHERE\n    t.production_year BETWEEN 1990 AND 2020\nGROUP BY\n    a.name, t.title, c.role_id, ct.kind\nHAVING\n    COUNT(DISTINCT m.company_id) > 1\nORDER BY\n    avg_movie_rating DESC, actor_name ASC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    mi.movie_id,\n    AVG(CAST(mi.info AS INTEGER)) AS avg_movie_rating,\n    COUNT(DISTINCT mc.company_id) AS company_count\nFROM movie_info mi\nJOIN info_type it ON mi.info_type_id = it.id AND it.info = 'rating'\nLEFT JOIN movie_companies mc ON mi.movie_id = mc.movie_id\nGROUP BY mi.movie_id\nHAVING COUNT(DISTINCT mc.company_id) > 1;", "sql2": "SELECT\n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.role_id AS role_id,\n    ct.kind AS company_type,\n    s1.company_count,\n    s1.avg_movie_rating\nFROM aka_name a\nJOIN cast_info c ON a.person_id = c.person_id\nJOIN aka_title t ON c.movie_id = t.id\nLEFT JOIN movie_companies m ON t.id = m.movie_id\nLEFT JOIN company_type ct ON m.company_type_id = ct.id\nJOIN s1 ON t.id = s1.movie_id\nWHERE t.production_year BETWEEN 1990 AND 2020\nGROUP BY a.name, t.title, c.role_id, ct.kind, s1.company_count, s1.avg_movie_rating\nORDER BY s1.avg_movie_rating DESC, a.name ASC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "7229.sql", "original_sql": "WITH MovieKeywordCounts AS (\n    SELECT mk.movie_id, COUNT(mk.keyword_id) AS keyword_count\n    FROM movie_keyword mk\n    GROUP BY mk.movie_id\n),\nMovieCompanyCounts AS (\n    SELECT mc.movie_id, COUNT(mc.company_id) AS company_count\n    FROM movie_companies mc\n    GROUP BY mc.movie_id\n),\nMovieRoleCounts AS (\n    SELECT ci.movie_id, COUNT(DISTINCT ci.person_id) AS role_count\n    FROM cast_info ci\n    GROUP BY ci.movie_id\n)\nSELECT \n    t.title AS movie_title,\n    t.production_year,\n    mkc.keyword_count,\n    mcc.company_count,\n    mrc.role_count\nFROM title t\nJOIN MovieKeywordCounts mkc ON t.id = mkc.movie_id\nJOIN MovieCompanyCounts mcc ON t.id = mcc.movie_id\nJOIN MovieRoleCounts mrc ON t.id = mrc.movie_id\nWHERE t.production_year BETWEEN 2000 AND 2023\nORDER BY t.production_year DESC, mkc.keyword_count DESC, mcc.company_count DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH kw AS (\n  SELECT movie_id, COUNT(keyword_id) AS keyword_count\n  FROM movie_keyword\n  GROUP BY movie_id\n),\ncomp AS (\n  SELECT movie_id, COUNT(company_id) AS company_count\n  FROM movie_companies\n  GROUP BY movie_id\n),\nrole AS (\n  SELECT movie_id, COUNT(DISTINCT person_id) AS role_count\n  FROM cast_info\n  GROUP BY movie_id\n)\nSELECT kw.movie_id,\n       kw.keyword_count,\n       comp.company_count,\n       role.role_count\nFROM kw\nJOIN comp USING (movie_id)\nJOIN role USING (movie_id);", "sql2": "SELECT t.title AS movie_title,\n       t.production_year,\n       s1.keyword_count,\n       s1.company_count,\n       s1.role_count\nFROM title t\nJOIN s1 ON t.id = s1.movie_id\nWHERE t.production_year BETWEEN 2000 AND 2023\nORDER BY t.production_year DESC,\n         s1.keyword_count DESC,\n         s1.company_count DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "7307.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.kind AS cast_type,\n    cc.name AS company_name,\n    mi.info AS movie_info,\n    k.keyword AS movie_keyword\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    aka_title t ON ci.movie_id = t.movie_id\nJOIN \n    comp_cast_type c ON ci.person_role_id = c.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cc ON mc.company_id = cc.id\nJOIN \n    movie_info mi ON t.id = mi.movie_id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    t.production_year >= 2000 AND \n    cc.country_code = 'USA' AND \n    mi.info_type_id IN (SELECT id FROM info_type WHERE info = 'Box Office') \nORDER BY \n    t.production_year DESC, \n    a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS movie_id,\n       t.title AS movie_title,\n       t.production_year,\n       mi.info AS movie_info\nFROM title t\nJOIN movie_info mi ON t.id = mi.movie_id\nWHERE t.production_year >= 2000\n  AND mi.info_type_id IN (SELECT id FROM info_type WHERE info = 'Box Office')", "sql2": "SELECT a.name AS actor_name,\n       s1.movie_title,\n       c.kind AS cast_type,\n       cc.name AS company_name,\n       s1.movie_info,\n       k.keyword AS movie_keyword\nFROM s1\nJOIN cast_info ci ON ci.movie_id = s1.movie_id\nJOIN aka_name a ON a.person_id = ci.person_id\nJOIN comp_cast_type c ON ci.person_role_id = c.id\nJOIN movie_companies mc ON s1.movie_id = mc.movie_id\nJOIN company_name cc ON mc.company_id = cc.id\nJOIN movie_keyword mk ON s1.movie_id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE cc.country_code = 'USA'\nORDER BY s1.production_year DESC, a.name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "7348.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    m.title AS movie_title,\n    c.kind AS cast_type,\n    co.name AS company_name,\n    COUNT(*) AS total_movies\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    aka_title m ON ci.movie_id = m.movie_id\nJOIN \n    movie_companies mc ON m.id = mc.movie_id\nJOIN \n    company_name co ON mc.company_id = co.id\nJOIN \n    comp_cast_type c ON ci.person_role_id = c.id\nWHERE \n    m.production_year BETWEEN 1990 AND 2023\n    AND co.country_code = 'USA'\nGROUP BY \n    a.name, m.title, c.kind, co.name\nORDER BY \n    total_movies DESC\nLIMIT 50;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT\n    m.id AS movie_id,\n    m.title AS movie_title,\n    co.name AS company_name\nFROM aka_title m\nJOIN movie_companies mc ON m.id = mc.movie_id\nJOIN company_name co ON mc.company_id = co.id\nWHERE m.production_year BETWEEN 1990 AND 2023\n  AND co.country_code = 'USA';", "sql2": "SELECT\n    a.name AS actor_name,\n    s1.movie_title,\n    c.kind AS cast_type,\n    s1.company_name,\n    COUNT(*) AS total_movies\nFROM s1\nJOIN cast_info ci ON s1.movie_id = ci.movie_id\nJOIN aka_name a ON a.person_id = ci.person_id\nJOIN comp_cast_type c ON ci.person_role_id = c.id\nGROUP BY a.name, s1.movie_title, c.kind, s1.company_name\nORDER BY total_movies DESC\nLIMIT 50;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "7429.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.kind AS company_type,\n    k.keyword AS movie_keyword,\n    pi.info AS person_info,\n    COUNT(DISTINCT mi.info) AS movie_info_count,\n    COUNT(DISTINCT mc.company_id) AS company_count\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    person_info pi ON a.person_id = pi.person_id\nJOIN \n    movie_info mi ON t.id = mi.movie_id\nWHERE \n    t.production_year >= 2000\n    AND pi.info_type_id = (SELECT id FROM info_type WHERE info = 'Biography')\nGROUP BY \n    a.name, t.title, c.kind, k.keyword, pi.info\nORDER BY \n    movie_info_count DESC, company_count ASC;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "7558.sql", "original_sql": "SELECT \n    ak.name AS aka_name, \n    t.title AS movie_title, \n    c.nr_order AS cast_order, \n    cn.name AS company_name, \n    g.kind AS genre, \n    ti.info AS additional_info \nFROM \n    aka_name ak \nJOIN \n    cast_info c ON ak.person_id = c.person_id \nJOIN \n    aka_title t ON c.movie_id = t.movie_id \nJOIN \n    movie_companies mc ON t.id = mc.movie_id \nJOIN \n    company_name cn ON mc.company_id = cn.id \nJOIN \n    kind_type g ON t.kind_id = g.id \nLEFT JOIN \n    movie_info mi ON t.id = mi.movie_id \nLEFT JOIN \n    info_type ti ON mi.info_type_id = ti.id \nWHERE \n    t.production_year >= 2000 \n    AND g.kind IN ('Drama', 'Comedy') \nORDER BY \n    t.production_year DESC, \n    ak.name, \n    c.nr_order;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS title_id,\n       t.title AS movie_title,\n       t.production_year,\n       g.kind AS genre\nFROM   title t\nJOIN   kind_type g ON t.kind_id = g.id\nWHERE  t.production_year >= 2000\n  AND  g.kind IN ('Drama','Comedy')", "sql2": "SELECT ak.name AS aka_name,\n       s1.movie_title,\n       c.nr_order AS cast_order,\n       cn.name AS company_name,\n       s1.genre,\n       ti.info AS additional_info\nFROM   s1\nJOIN   cast_info c      ON s1.title_id = c.movie_id\nJOIN   aka_name ak      ON ak.person_id = c.person_id\nJOIN   movie_companies mc ON s1.title_id = mc.movie_id\nJOIN   company_name cn  ON mc.company_id = cn.id\nLEFT JOIN movie_info mi   ON s1.title_id = mi.movie_id\nLEFT JOIN info_type ti   ON mi.info_type_id = ti.id\nORDER BY s1.production_year DESC,\n         ak.name,\n         c.nr_order", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "7575.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    c.kind AS company_type,\n    STRING_AGG(DISTINCT k.keyword, ', ') AS keywords\nFROM \n    cast_info ci\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    aka_title t ON ci.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nLEFT JOIN \n    movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    t.production_year BETWEEN 2000 AND 2020\n    AND c.kind IS NOT NULL\nGROUP BY \n    a.name, t.title, t.production_year, c.kind\nORDER BY \n    t.production_year DESC, a.name;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "7603.sql", "original_sql": "\nWITH RankedMovies AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        COUNT(DISTINCT c.person_id) AS cast_count,\n        STRING_AGG(DISTINCT a.name, ', ') AS actors_list\n    FROM \n        title t\n    JOIN \n        complete_cast cc ON t.id = cc.movie_id\n    JOIN \n        cast_info c ON cc.subject_id = c.id\n    JOIN \n        aka_name a ON c.person_id = a.person_id\n    WHERE \n        t.production_year >= 2000\n    GROUP BY \n        t.id, t.title, t.production_year\n), MovieKeywords AS (\n    SELECT \n        mk.movie_id,\n        STRING_AGG(k.keyword, ', ') AS keywords_list\n    FROM \n        movie_keyword mk\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    GROUP BY \n        mk.movie_id\n), FinalReport AS (\n    SELECT \n        rm.movie_id,\n        rm.title,\n        rm.production_year,\n        rm.cast_count,\n        rm.actors_list,\n        mk.keywords_list\n    FROM \n        RankedMovies rm\n    LEFT JOIN \n        MovieKeywords mk ON rm.movie_id = mk.movie_id\n    ORDER BY \n        rm.production_year DESC, rm.cast_count DESC\n)\nSELECT \n    movie_id,\n    title,\n    production_year,\n    cast_count,\n    actors_list,\n    keywords_list\nFROM \n    FinalReport\nLIMIT 100;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "7611.sql", "original_sql": "\nSELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year AS year,\n    STRING_AGG(DISTINCT k.keyword, ', ') AS keywords,\n    c.kind AS company_type,\n    pi.info AS personal_info\nFROM \n    aka_name a \nJOIN \n    cast_info ci ON a.person_id = ci.person_id \nJOIN \n    title t ON ci.movie_id = t.id \nJOIN \n    movie_keyword mk ON t.id = mk.movie_id \nJOIN \n    keyword k ON mk.keyword_id = k.id \nJOIN \n    movie_companies mc ON t.id = mc.movie_id \nJOIN \n    company_type c ON mc.company_type_id = c.id \nLEFT JOIN \n    person_info pi ON a.person_id = pi.person_id \nWHERE \n    c.kind LIKE '%Production%'\n    AND t.production_year >= 2000 \n    AND pi.info_type_id IN (SELECT id FROM info_type WHERE info LIKE '%biography%')\nGROUP BY \n    a.name, t.title, t.production_year, c.kind, pi.info \nORDER BY \n    t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year AS year,\n    k.keyword,\n    c.kind AS company_type,\n    pi.info AS personal_info\nFROM aka_name a\nJOIN cast_info ci ON a.person_id = ci.person_id\nJOIN title t ON ci.movie_id = t.id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nLEFT JOIN person_info pi ON a.person_id = pi.person_id\nWHERE c.kind LIKE '%Production%'\n  AND t.production_year >= 2000\n  AND pi.info_type_id IN (SELECT id FROM info_type WHERE info LIKE '%biography%')", "sql2": "SELECT \n    actor_name,\n    movie_title,\n    year,\n    STRING_AGG(DISTINCT keyword, ', ') AS keywords,\n    company_type,\n    personal_info\nFROM s1\nGROUP BY actor_name, movie_title, year, company_type, personal_info\nORDER BY year DESC, actor_name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "7758.sql", "original_sql": "SELECT \n    ak.name AS aka_name, \n    t.title AS movie_title, \n    p.name AS person_name, \n    c.note AS cast_note,\n    k.keyword AS movie_keyword, \n    m.info AS movie_info, \n    co.name AS company_name\nFROM \n    aka_name ak\nJOIN \n    cast_info c ON ak.person_id = c.person_id\nJOIN \n    title t ON c.movie_id = t.id\nJOIN \n    name p ON ak.person_id = p.imdb_id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    movie_info m ON t.id = m.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name co ON mc.company_id = co.id\nWHERE \n    t.production_year >= 2000 \n    AND k.keyword LIKE '%Action%'\nORDER BY \n    t.production_year DESC, \n    ak.name;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT DISTINCT t.id AS movie_id,\n       t.production_year\nFROM title t\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE t.production_year >= 2000\n  AND k.keyword LIKE '%Action%';", "sql2": "SELECT \n    ak.name AS aka_name,\n    t.title AS movie_title,\n    p.name AS person_name,\n    c.note AS cast_note,\n    k.keyword AS movie_keyword,\n    m.info AS movie_info,\n    co.name AS company_name,\n    s1.production_year\nFROM s1\nJOIN title t ON s1.movie_id = t.id\nJOIN cast_info c ON t.id = c.movie_id\nJOIN aka_name ak ON c.person_id = ak.person_id\nJOIN name p ON ak.person_id = p.id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nJOIN movie_info m ON t.id = m.movie_id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_name co ON mc.company_id = co.id\nORDER BY s1.production_year DESC,\n         ak.name;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "7823.sql", "original_sql": "SELECT \n    a.id AS aka_id, \n    a.name AS aka_name, \n    t.title AS movie_title, \n    c.nr_order AS cast_order, \n    p.info AS person_info, \n    ct.kind AS company_type, \n    k.keyword AS movie_keyword \nFROM \n    aka_name AS a \nJOIN \n    cast_info AS c ON a.person_id = c.person_id \nJOIN \n    title AS t ON c.movie_id = t.id \nJOIN \n    movie_companies AS mc ON t.id = mc.movie_id \nJOIN \n    company_type AS ct ON mc.company_type_id = ct.id \nJOIN \n    movie_keyword AS mk ON t.id = mk.movie_id \nJOIN \n    keyword AS k ON mk.keyword_id = k.id \nJOIN \n    person_info AS p ON a.person_id = p.person_id \nWHERE \n    t.production_year BETWEEN 2000 AND 2020 \n    AND ct.kind = 'Production' \n    AND k.keyword LIKE '%Drama%' \nORDER BY \n    a.name, t.production_year DESC, c.nr_order;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT a.id AS aka_id,\n       a.name AS aka_name,\n       a.person_id,\n       c.nr_order AS cast_order,\n       p.info AS person_info,\n       t.id AS movie_id,\n       t.title AS movie_title,\n       t.production_year\nFROM   aka_name AS a\nJOIN   cast_info AS c ON a.person_id = c.person_id\nJOIN   title AS t ON c.movie_id = t.id\nJOIN   person_info AS p ON a.person_id = p.person_id\nWHERE  t.production_year BETWEEN 2000 AND 2020;", "sql2": "SELECT s1.aka_id,\n       s1.aka_name,\n       s1.movie_title,\n       s1.cast_order,\n       s1.person_info,\n       ct.kind AS company_type,\n       k.keyword AS movie_keyword\nFROM   s1\nJOIN   movie_companies mc ON s1.movie_id = mc.movie_id\nJOIN   company_type ct ON mc.company_type_id = ct.id\nJOIN   movie_keyword mk ON s1.movie_id = mk.movie_id\nJOIN   keyword k ON mk.keyword_id = k.id\nWHERE  ct.kind = 'Production'\n  AND  k.keyword LIKE '%Drama%'\nORDER BY s1.aka_name,\n         s1.production_year DESC,\n         s1.cast_order;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "7827.sql", "original_sql": "SELECT \n    t.title AS movie_title,\n    a.name AS actor_name,\n    c.kind AS cast_type,\n    m.info AS movie_info,\n    k.keyword AS movie_keyword,\n    co.name AS company_name,\n    p.info AS person_info\nFROM \n    title AS t\nJOIN \n    complete_cast AS cc ON t.id = cc.movie_id\nJOIN \n    cast_info AS ci ON cc.subject_id = ci.id\nJOIN \n    aka_name AS a ON ci.person_id = a.person_id\nJOIN \n    role_type AS r ON ci.role_id = r.id\nJOIN \n    comp_cast_type AS c ON ci.person_role_id = c.id\nJOIN \n    movie_info AS m ON t.id = m.movie_id\nJOIN \n    movie_keyword AS mk ON t.id = mk.movie_id\nJOIN \n    keyword AS k ON mk.keyword_id = k.id\nJOIN \n    movie_companies AS mc ON t.id = mc.movie_id\nJOIN \n    company_name AS co ON mc.company_id = co.id\nJOIN \n    person_info AS p ON a.id = p.person_id\nWHERE \n    t.production_year >= 2000\n    AND c.kind = 'Cast'\n    AND m.info_type_id IN (SELECT id FROM info_type WHERE info = 'Box Office')\nORDER BY \n    t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS movie_id,\n       t.title AS movie_title,\n       m.info AS movie_info,\n       k.keyword AS movie_keyword,\n       co.name AS company_name,\n       t.production_year\nFROM title t\nJOIN movie_info m ON t.id = m.movie_id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_name co ON mc.company_id = co.id\nWHERE t.production_year >= 2000\n  AND m.info_type_id = (SELECT id FROM info_type WHERE info = 'Box Office');", "sql2": "SELECT s1.movie_title,\n       a.name AS actor_name,\n       c.kind AS cast_type,\n       s1.movie_info,\n       s1.movie_keyword,\n       s1.company_name,\n       p.info AS person_info\nFROM s1\nJOIN complete_cast cc ON s1.movie_id = cc.movie_id\nJOIN cast_info ci ON cc.subject_id = ci.id\nJOIN aka_name a ON ci.person_id = a.person_id\nJOIN comp_cast_type c ON ci.person_role_id = c.id\nJOIN person_info p ON a.id = p.person_id\nWHERE c.kind = 'Cast'\nORDER BY s1.production_year DESC, a.name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "7834.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.kind AS cast_type,\n    p.info AS actor_info,\n    k.keyword AS movie_keyword\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    comp_cast_type c ON ci.person_role_id = c.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nLEFT JOIN \n    person_info p ON a.person_id = p.person_id\nWHERE \n    t.production_year BETWEEN 2000 AND 2023\nAND \n    k.keyword LIKE '%action%'\nORDER BY \n    t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT DISTINCT mk.movie_id\nFROM movie_keyword mk\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE k.keyword LIKE '%action%';", "sql2": "SELECT a.name AS actor_name,\n       t.title AS movie_title,\n       c.kind AS cast_type,\n       p.info AS actor_info,\n       k.keyword AS movie_keyword\nFROM aka_name a\nJOIN cast_info ci ON a.person_id = ci.person_id\nJOIN title t ON ci.movie_id = t.id\nJOIN comp_cast_type c ON ci.person_role_id = c.id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nLEFT JOIN person_info p ON a.person_id = p.person_id\nJOIN s1 ON t.id = s1.movie_id\nWHERE t.production_year BETWEEN 2000 AND 2023\n  AND k.keyword LIKE '%action%'\nORDER BY t.production_year DESC, a.name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "7893.sql", "original_sql": "SELECT \n    t.title AS movie_title,\n    a.name AS actor_name,\n    p.info AS actor_info,\n    c.name AS company_name,\n    k.keyword AS movie_keyword,\n    ti.info AS title_info\nFROM \n    title t\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info ci ON cc.subject_id = ci.id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    person_info p ON a.person_id = p.person_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name c ON mc.company_id = c.id\nJOIN \n    movie_info mi ON t.id = mi.movie_id\nJOIN \n    info_type ti ON mi.info_type_id = ti.id\nWHERE \n    t.production_year > 2000\n    AND c.country_code = 'USA'\n    AND k.keyword LIKE '%action%'\nORDER BY \n    t.production_year DESC, a.name ASC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS movie_id,\n       t.title AS movie_title,\n       t.production_year AS prod_year,\n       c.name AS company_name,\n       k.keyword AS movie_keyword,\n       ti.info AS title_info\nFROM title t\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_name c ON mc.company_id = c.id\nJOIN movie_info mi ON t.id = mi.movie_id\nJOIN info_type ti ON mi.info_type_id = ti.id\nWHERE t.production_year > 2000\n  AND c.country_code = 'USA'\n  AND k.keyword LIKE '%action%';", "sql2": "SELECT s1.movie_title,\n       a.name AS actor_name,\n       p.info AS actor_info,\n       s1.company_name,\n       s1.movie_keyword,\n       s1.title_info\nFROM s1\nJOIN complete_cast cc ON s1.movie_id = cc.movie_id\nJOIN cast_info ci ON cc.subject_id = ci.id\nJOIN aka_name a ON ci.person_id = a.person_id\nJOIN person_info p ON a.person_id = p.person_id\nORDER BY s1.prod_year DESC, a.name ASC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "8051.sql", "original_sql": "WITH RankedTitles AS (\n    SELECT \n        a.id AS aka_id,\n        a.name AS aka_name,\n        t.id AS title_id,\n        t.title AS title_name,\n        t.production_year,\n        ROW_NUMBER() OVER (PARTITION BY t.production_year ORDER BY a.name) AS rank\n    FROM \n        aka_name a\n    JOIN \n        aka_title at ON a.id = at.id\n    JOIN \n        title t ON at.movie_id = t.id\n    WHERE \n        t.production_year IS NOT NULL\n),\nCastedTitles AS (\n    SELECT \n        rt.aka_id,\n        rt.aka_name,\n        rt.title_id,\n        rt.title_name,\n        rt.production_year,\n        c.person_role_id,\n        r.role AS role_name\n    FROM \n        RankedTitles rt\n    JOIN \n        cast_info c ON rt.title_id = c.movie_id\n    JOIN \n        role_type r ON c.person_role_id = r.id\n),\nFilteredTitles AS (\n    SELECT \n        ct.aka_id,\n        ct.aka_name,\n        ct.title_name,\n        ct.production_year,\n        COUNT(ct.role_name) AS role_count\n    FROM \n        CastedTitles ct\n    GROUP BY \n        ct.aka_id, ct.aka_name, ct.title_name, ct.production_year\n    HAVING \n        COUNT(ct.role_name) > 2\n)\nSELECT \n    ft.aka_name,\n    ft.title_name,\n    ft.production_year,\n    ft.role_count\nFROM \n    FilteredTitles ft\nORDER BY \n    ft.production_year DESC, ft.role_count DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT c.movie_id AS title_id, COUNT(*) AS role_count FROM cast_info c JOIN role_type r ON c.person_role_id = r.id GROUP BY c.movie_id HAVING COUNT(*) > 2", "sql2": "WITH RankedTitles AS (\n    SELECT \n        a.id AS aka_id,\n        a.name AS aka_name,\n        t.id AS title_id,\n        t.title AS title_name,\n        t.production_year,\n        ROW_NUMBER() OVER (PARTITION BY t.production_year ORDER BY a.name) AS rank\n    FROM \n        aka_name a\n    JOIN \n        aka_title at ON a.id = at.id\n    JOIN \n        title t ON at.movie_id = t.id\n    WHERE \n        t.production_year IS NOT NULL\n),\nFilteredRanked AS (\n    SELECT \n        rt.aka_name,\n        rt.title_name,\n        rt.production_year,\n        s1.role_count\n    FROM \n        RankedTitles rt\n    JOIN \n        s1 ON rt.title_id = s1.title_id\n)\nSELECT \n    fr.aka_name,\n    fr.title_name,\n    fr.production_year,\n    fr.role_count\nFROM \n    FilteredRanked fr\nORDER BY \n    fr.production_year DESC,\n    fr.role_count DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "8053.sql", "original_sql": "\nSELECT \n    a.name AS actor_name, \n    t.title AS movie_title, \n    ct.kind AS company_type, \n    k.keyword AS movie_keyword,\n    pi.info AS actor_info\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    person_info pi ON a.person_id = pi.person_id\nWHERE \n    t.production_year >= 2000\n    AND ct.kind = 'Distributor'\n    AND k.keyword LIKE '%action%'\nORDER BY \n    a.name, t.title\nFETCH FIRST 100 ROWS ONLY;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT DISTINCT t.id AS movie_id,\n       k.keyword AS movie_keyword,\n       ct.kind AS company_type\nFROM title t\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type ct ON mc.company_type_id = ct.id\nWHERE t.production_year >= 2000\n  AND ct.kind = 'Distributor'\n  AND k.keyword LIKE '%action%';", "sql2": "SELECT a.name AS actor_name,\n       t.title AS movie_title,\n       s1.company_type,\n       s1.movie_keyword,\n       pi.info AS actor_info\nFROM s1\nJOIN cast_info ci ON s1.movie_id = ci.movie_id\nJOIN aka_name a ON a.person_id = ci.person_id\nJOIN title t ON ci.movie_id = t.id\nJOIN person_info pi ON a.person_id = pi.person_id\nORDER BY a.name, t.title\nFETCH FIRST 100 ROWS ONLY;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "8078.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.kind AS company_type,\n    k.keyword AS movie_keyword,\n    pi.info AS person_info\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    person_info pi ON a.person_id = pi.person_id\nWHERE \n    t.production_year > 2000\n    AND c.kind LIKE 'Production%'\n    AND pi.info_type_id IN (SELECT id FROM info_type WHERE info = 'Biography')\nORDER BY \n    t.production_year DESC, \n    a.name;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT DISTINCT t.id AS movie_id\nFROM title t\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nWHERE t.production_year > 2000\n  AND c.kind LIKE 'Production%'", "sql2": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.kind AS company_type,\n    k.keyword AS movie_keyword,\n    pi.info AS person_info\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    s1 ON t.id = s1.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    person_info pi ON a.person_id = pi.person_id\nWHERE \n    pi.info_type_id IN (SELECT id FROM info_type WHERE info = 'Biography')\nORDER BY \n    t.production_year DESC, \n    a.name", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "8087.sql", "original_sql": "SELECT \n    t.title AS movie_title, \n    ak.name AS actor_name, \n    c.nr_order AS cast_order, \n    p.info AS person_info, \n    ki.keyword AS movie_keyword, \n    comp.name AS company_name, \n    inf.info AS movie_info\nFROM \n    title t\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info c ON cc.subject_id = c.person_id\nJOIN \n    aka_name ak ON c.person_id = ak.person_id\nLEFT JOIN \n    person_info p ON ak.person_id = p.person_id\nLEFT JOIN \n    movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN \n    keyword ki ON mk.keyword_id = ki.id\nLEFT JOIN \n    movie_companies mc ON t.id = mc.movie_id\nLEFT JOIN \n    company_name comp ON mc.company_id = comp.id\nLEFT JOIN \n    movie_info mi ON t.id = mi.movie_id\nLEFT JOIN \n    info_type inf_type ON mi.info_type_id = inf_type.id\nLEFT JOIN \n    movie_info_idx inf ON t.id = inf.movie_id AND inf_type.id = inf.info_type_id\nWHERE \n    t.production_year BETWEEN 2000 AND 2020 \n    AND ak.name IS NOT NULL \n    AND comp.country_code = 'USA'\nORDER BY \n    t.title, \n    c.nr_order;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    t.id AS movie_id,\n    t.title AS movie_title,\n    ak.person_id AS person_id,\n    ak.name AS actor_name,\n    c.nr_order AS cast_order,\n    comp.name AS company_name\nFROM title t\nJOIN complete_cast cc ON t.id = cc.movie_id\nJOIN cast_info c ON cc.subject_id = c.person_id\nJOIN aka_name ak ON c.person_id = ak.person_id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_name comp ON mc.company_id = comp.id\nWHERE t.production_year BETWEEN 2000 AND 2020\n  AND ak.name IS NOT NULL\n  AND comp.country_code = 'USA';", "sql2": "SELECT \n    s1.movie_title,\n    s1.actor_name,\n    s1.cast_order,\n    p.info AS person_info,\n    ki.keyword AS movie_keyword,\n    s1.company_name,\n    inf.info AS movie_info\nFROM s1\nLEFT JOIN person_info p ON s1.person_id = p.person_id\nLEFT JOIN movie_keyword mk ON s1.movie_id = mk.movie_id\nLEFT JOIN keyword ki ON mk.keyword_id = ki.id\nLEFT JOIN movie_info mi ON s1.movie_id = mi.movie_id\nLEFT JOIN info_type inf_type ON mi.info_type_id = inf_type.id\nLEFT JOIN movie_info_idx inf ON s1.movie_id = inf.movie_id AND inf_type.id = inf.info_type_id\nORDER BY s1.movie_title, s1.cast_order;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "8124.sql", "original_sql": "SELECT \n    a.name AS actor_name, \n    t.title AS movie_title, \n    c.kind AS company_type, \n    k.keyword AS movie_keyword, \n    i.info AS movie_info \nFROM \n    aka_name a \nJOIN \n    cast_info ci ON a.person_id = ci.person_id \nJOIN \n    title t ON ci.movie_id = t.id \nJOIN \n    movie_companies mc ON t.id = mc.movie_id \nJOIN \n    company_type c ON mc.company_type_id = c.id \nJOIN \n    movie_keyword mk ON t.id = mk.movie_id \nJOIN \n    keyword k ON mk.keyword_id = k.id \nJOIN \n    movie_info mi ON t.id = mi.movie_id \nJOIN \n    info_type i ON mi.info_type_id = i.id \nWHERE \n    a.name LIKE '%Smith%' \n    AND t.production_year >= 2000 \nORDER BY \n    t.production_year DESC, a.name ASC \nLIMIT 50;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    a.name AS actor_name,\n    t.id AS movie_id,\n    t.title AS movie_title,\n    c.kind AS company_type,\n    t.production_year AS prod_year\nFROM aka_name a\nJOIN cast_info ci ON a.person_id = ci.person_id\nJOIN title t ON ci.movie_id = t.id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nWHERE a.name LIKE '%Smith%'\n  AND t.production_year >= 2000;", "sql2": "SELECT \n    s1.actor_name,\n    s1.movie_title,\n    s1.company_type,\n    k.keyword AS movie_keyword,\n    i.info AS movie_info\nFROM s1\nJOIN movie_keyword mk ON s1.movie_id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nJOIN movie_info mi ON s1.movie_id = mi.movie_id\nJOIN info_type i ON mi.info_type_id = i.id\nORDER BY s1.prod_year DESC, s1.actor_name ASC\nLIMIT 50;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "8126.sql", "original_sql": "\nSELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    STRING_AGG(DISTINCT k.keyword, ', ') AS keywords,\n    c.kind AS cast_type,\n    cp.name AS company_name,\n    p.info AS actor_info\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cp ON mc.company_id = cp.id\nJOIN \n    role_type r ON ci.role_id = r.id\nJOIN \n    comp_cast_type c ON ci.person_role_id = c.id\nJOIN \n    person_info p ON a.person_id = p.person_id\nWHERE \n    t.production_year >= 2000\n    AND a.name IS NOT NULL\n    AND cp.country_code = 'USA'\nGROUP BY \n    a.name, t.title, t.production_year, c.kind, cp.name, p.info\nORDER BY \n    t.production_year DESC, a.name;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 115, in _run_on_datafusion\n    return df.to_arrow_table()\n           ^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/dataframe.py\", line 1164, in to_arrow_table\n    return self.df.to_arrow_table()\n           ^^^^^^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Shared(ResourcesExhausted(\"Additional allocation failed with top memory consumers (across reservations) as:\\n  RepartitionExec[9]#5646(can spill: false) consumed 11.8 GB, peak 11.8 GB,\\n  RepartitionExec[10]#5647(can spill: false) consumed 11.8 GB, peak 11.8 GB,\\n  RepartitionExec[6]#5643(can spill: false) consumed 11.2 GB, peak 11.7 GB,\\n  RepartitionExec[13]#5650(can spill: false) consumed 11.2 GB, peak 11.2 GB,\\n  RepartitionExec[7]#5644(can spill: false) consumed 11.2 GB, peak 11.7 GB.\\nError: Failed to allocate additional 91.9 MB for RepartitionExec[53] with 3.8 GB already allocated for this reservation - 27.1 MB remain available for the total pool\"))\n", "engine_mem_mb": 500000}
{"query_id": "8183.sql", "original_sql": "\nSELECT \n    a.name AS actor_name, \n    t.title AS movie_title, \n    c.kind AS cast_type, \n    m.info AS movie_info, \n    STRING_AGG(DISTINCT k.keyword, ', ') AS keywords\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    comp_cast_type c ON ci.person_role_id = c.id\nJOIN \n    movie_info m ON t.id = m.movie_id\nLEFT JOIN \n    movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    m.info_type_id IN (SELECT id FROM info_type WHERE info LIKE 'budget')\n    AND t.production_year > 2000\nGROUP BY \n    a.name, t.title, c.kind, m.info\nORDER BY \n    COUNT(DISTINCT k.id) DESC, a.name;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "8240.sql", "original_sql": "SELECT \n    a.name AS actor_name, \n    t.title AS movie_title, \n    c.role_id, \n    ct.kind AS company_type, \n    COUNT(*) AS total_movies\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    aka_title t ON c.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nWHERE \n    t.production_year >= 2000\nAND \n    ct.kind IN ('Distributor', 'Production')\nGROUP BY \n    a.name, t.title, c.role_id, ct.kind\nHAVING \n    COUNT(*) > 5\nORDER BY \n    total_movies DESC, a.name ASC\nLIMIT 10;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT a.name AS actor_name,\n       t.title AS movie_title,\n       c.role_id,\n       ct.kind AS company_type,\n       COUNT(*) AS total_movies\nFROM   aka_name a\nJOIN   cast_info c ON a.person_id = c.person_id\nJOIN   aka_title t ON c.movie_id = t.movie_id\nJOIN   movie_companies mc ON t.id = mc.movie_id\nJOIN   company_type ct ON mc.company_type_id = ct.id\nWHERE  t.production_year >= 2000\n  AND  ct.kind IN ('Distributor','Production')\nGROUP BY a.name, t.title, c.role_id, ct.kind\nHAVING COUNT(*) > 5;", "sql2": "SELECT actor_name,\n       movie_title,\n       role_id,\n       company_type,\n       total_movies\nFROM   s1\nORDER BY total_movies DESC,\n         actor_name ASC\nLIMIT 10;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "8286.sql", "original_sql": "SELECT \n    a.name AS actor_name, \n    t.title AS movie_title, \n    t.production_year, \n    c.kind AS cast_type, \n    k.keyword AS movie_keyword, \n    ci.note AS character_note\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    comp_cast_type c ON ci.role_id = c.id\nWHERE \n    t.production_year > 2000 \n    AND k.keyword LIKE 'action%'\nORDER BY \n    t.production_year DESC, \n    a.name ASC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT \n    t.id AS movie_id,\n    t.title,\n    t.production_year,\n    k.keyword\nFROM title t\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE t.production_year > 2000\n  AND k.keyword LIKE 'action%';", "sql2": "SELECT \n    a.name AS actor_name,\n    s1.title AS movie_title,\n    s1.production_year,\n    c.kind AS cast_type,\n    s1.keyword AS movie_keyword,\n    ci.note AS character_note\nFROM s1\nJOIN cast_info ci ON s1.movie_id = ci.movie_id\nJOIN aka_name a ON a.person_id = ci.person_id\nJOIN comp_cast_type c ON ci.role_id = c.id\nORDER BY s1.production_year DESC, a.name ASC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "8321.sql", "original_sql": "WITH movie_actor_roles AS (\n    SELECT \n        t.id AS movie_id,\n        t.title AS movie_title,\n        a.name AS actor_name,\n        r.role AS actor_role,\n        COUNT(ci.id) AS total_appearances\n    FROM \n        title t\n    JOIN \n        cast_info ci ON t.id = ci.movie_id\n    JOIN \n        aka_name a ON ci.person_id = a.person_id\n    JOIN \n        role_type r ON ci.role_id = r.id\n    GROUP BY \n        t.id, t.title, a.name, r.role\n),\ncompany_movie_info AS (\n    SELECT \n        m.movie_id,\n        c.name AS company_name,\n        ct.kind AS company_type,\n        COUNT(m.id) AS total_movies\n    FROM \n        movie_companies m\n    JOIN \n        company_name c ON m.company_id = c.id\n    JOIN \n        company_type ct ON m.company_type_id = ct.id\n    GROUP BY \n        m.movie_id, c.name, ct.kind\n)\nSELECT \n    ma.movie_id,\n    ma.movie_title,\n    ma.actor_name,\n    ma.actor_role,\n    ma.total_appearances,\n    cm.company_name,\n    cm.company_type,\n    cm.total_movies\nFROM \n    movie_actor_roles ma\nLEFT JOIN \n    complete_cast mc ON ma.movie_id = mc.movie_id\nLEFT JOIN \n    company_movie_info cm ON ma.movie_id = cm.movie_id\nWHERE \n    ma.total_appearances > 1 AND cm.total_movies > 5\nORDER BY \n    ma.total_appearances DESC, \n    cm.total_movies DESC\nLIMIT 100;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 115, in _run_on_datafusion\n    return df.to_arrow_table()\n           ^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/dataframe.py\", line 1164, in to_arrow_table\n    return self.df.to_arrow_table()\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"pyarrow/table.pxi\", line 4767, in pyarrow.lib.Table.from_batches\n  File \"pyarrow/error.pxi\", line 154, in pyarrow.lib.pyarrow_internal_check_status\n  File \"pyarrow/error.pxi\", line 91, in pyarrow.lib.check_status\npyarrow.lib.ArrowInvalid: Schema at index 0 was different: \nmovie_id: int64\nmovie_title: large_string\nactor_name: large_string\nactor_role: large_string\ntotal_appearances: int64\ncompany_name: string_view\ncompany_type: string_view\ntotal_movies: int64\nvs\nmovie_id: int64\nmovie_title: large_string\nactor_name: large_string\nactor_role: large_string\ntotal_appearances: int64\ncompany_name: string_view\ncompany_type: string_view\ntotal_movies: int64 not null\n", "engine_mem_mb": 500000}
{"query_id": "8394.sql", "original_sql": "\nSELECT \n    a.name AS actor_name, \n    t.title AS movie_title, \n    t.production_year, \n    ct.kind AS company_type, \n    m.info AS movie_info, \n    COUNT(DISTINCT k.keyword) AS keyword_count\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nJOIN \n    movie_info m ON t.id = m.movie_id\nLEFT JOIN \n    movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    a.name LIKE 'A%' \n    AND t.production_year >= 2000 \n    AND ct.kind = 'Distributor'\nGROUP BY \n    a.name, t.title, t.production_year, ct.kind, m.info\nORDER BY \n    keyword_count DESC, t.production_year DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT DISTINCT\n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    ct.kind AS company_type,\n    m.info AS movie_info,\n    t.id AS movie_id\nFROM aka_name a\nJOIN cast_info ci ON a.person_id = ci.person_id\nJOIN title t ON ci.movie_id = t.id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type ct ON mc.company_type_id = ct.id\nJOIN movie_info m ON t.id = m.movie_id\nWHERE a.name LIKE 'A%'\n  AND t.production_year >= 2000\n  AND ct.kind = 'Distributor'", "sql2": "SELECT\n    s1.actor_name,\n    s1.movie_title,\n    s1.production_year,\n    s1.company_type,\n    s1.movie_info,\n    COUNT(DISTINCT k.keyword) AS keyword_count\nFROM s1\nLEFT JOIN movie_keyword mk ON s1.movie_id = mk.movie_id\nLEFT JOIN keyword k ON mk.keyword_id = k.id\nGROUP BY\n    s1.actor_name,\n    s1.movie_title,\n    s1.production_year,\n    s1.company_type,\n    s1.movie_info\nORDER BY\n    keyword_count DESC,\n    s1.production_year DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "8480.sql", "original_sql": "SELECT \n    t.title AS movie_title,\n    a.name AS actor_name,\n    ct.kind AS cast_type,\n    c.name AS company_name,\n    ti.info AS movie_info,\n    k.keyword AS movie_keyword,\n    MAX(t.production_year) AS latest_year\nFROM \n    title t\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info ci ON cc.subject_id = ci.id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    company_name c ON t.id = (SELECT mc.movie_id FROM movie_companies mc WHERE mc.company_id = c.id LIMIT 1)\nJOIN \n    movie_info mi ON t.id = mi.movie_id\nJOIN \n    info_type ti ON mi.info_type_id = ti.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    comp_cast_type ct ON ci.person_role_id = ct.id\nWHERE \n    t.production_year >= 2000\nAND \n    ti.info LIKE '%box office%'\nGROUP BY \n    t.title, a.name, ct.kind, c.name, ti.info, k.keyword\nORDER BY \n    latest_year DESC, movie_title ASC\nLIMIT 100;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "8483.sql", "original_sql": "SELECT \n    a.name AS actor_name, \n    at.title AS movie_title, \n    c.nr_order AS role_order, \n    ct.kind AS company_type, \n    mc.note AS company_note,\n    ti.info AS additional_info\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    aka_title at ON c.movie_id = at.movie_id\nJOIN \n    movie_companies mc ON at.id = mc.movie_id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nLEFT JOIN \n    movie_info mi ON at.id = mi.movie_id\nLEFT JOIN \n    info_type ti ON mi.info_type_id = ti.id\nWHERE \n    at.production_year >= 2000 AND \n    ct.kind LIKE '%Production%' \nORDER BY \n    at.production_year DESC, \n    a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    a.name AS actor_name,\n    at.id AS movie_id,\n    at.title AS movie_title,\n    at.production_year,\n    c.nr_order AS role_order\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    aka_title at ON c.movie_id = at.movie_id\nWHERE \n    at.production_year >= 2000;", "sql2": "SELECT \n    s1.actor_name,\n    s1.movie_title,\n    s1.role_order,\n    ct.kind AS company_type,\n    mc.note AS company_note,\n    ti.info AS additional_info\nFROM \n    s1\nJOIN \n    movie_companies mc ON s1.movie_id = mc.movie_id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nLEFT JOIN \n    movie_info mi ON s1.movie_id = mi.movie_id\nLEFT JOIN \n    info_type ti ON mi.info_type_id = ti.id\nWHERE \n    ct.kind LIKE '%Production%'\nORDER BY \n    s1.production_year DESC,\n    s1.actor_name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "8486.sql", "original_sql": "\nSELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    STRING_AGG(DISTINCT k.keyword, ',') AS keywords,\n    STRING_AGG(DISTINCT cn.name, ',') AS companies,\n    COUNT(DISTINCT c.id) AS cast_count,\n    rt.role AS role_type\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    aka_title t ON c.movie_id = t.movie_id\nLEFT JOIN \n    movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN \n    keyword k ON mk.keyword_id = k.id\nLEFT JOIN \n    movie_companies mc ON t.id = mc.movie_id\nLEFT JOIN \n    company_name cn ON mc.company_id = cn.id\nLEFT JOIN \n    role_type rt ON c.role_id = rt.id\nWHERE \n    t.production_year >= 2000\n    AND a.name IS NOT NULL\n    AND t.kind_id IN (SELECT id FROM kind_type WHERE kind = 'feature')\nGROUP BY \n    a.name, t.title, t.production_year, rt.role\nORDER BY \n    t.production_year DESC, actor_name;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    rt.role AS role_type,\n    t.id AS movie_id,\n    c.id AS cast_id\nFROM aka_name a\nJOIN cast_info c ON a.person_id = c.person_id\nJOIN aka_title t ON c.movie_id = t.movie_id\nJOIN role_type rt ON c.role_id = rt.id\nWHERE t.production_year >= 2000\n  AND a.name IS NOT NULL\n  AND t.kind_id IN (SELECT id FROM kind_type WHERE kind = 'feature');", "sql2": "SELECT \n    s1.actor_name,\n    s1.movie_title,\n    s1.production_year,\n    STRING_AGG(DISTINCT k.keyword, ',') AS keywords,\n    STRING_AGG(DISTINCT cn.name, ',') AS companies,\n    COUNT(DISTINCT s1.cast_id) AS cast_count,\n    s1.role_type\nFROM s1\nLEFT JOIN movie_keyword mk ON s1.movie_id = mk.movie_id\nLEFT JOIN keyword k ON mk.keyword_id = k.id\nLEFT JOIN movie_companies mc ON s1.movie_id = mc.movie_id\nLEFT JOIN company_name cn ON mc.company_id = cn.id\nGROUP BY s1.actor_name, s1.movie_title, s1.production_year, s1.role_type\nORDER BY s1.production_year DESC, s1.actor_name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "8551.sql", "original_sql": "WITH MovieDetails AS (\n    SELECT\n        t.title AS MovieTitle,\n        t.production_year AS ProductionYear,\n        a.name AS ActorName,\n        ct.kind AS CastType,\n        c.name AS CompanyName,\n        k.keyword AS Keyword\n    FROM\n        aka_title t\n    JOIN\n        complete_cast cc ON t.id = cc.movie_id\n    JOIN\n        cast_info ci ON cc.subject_id = ci.id\n    JOIN\n        aka_name a ON ci.person_id = a.person_id\n    JOIN\n        movie_companies mc ON t.id = mc.movie_id\n    JOIN\n        company_name c ON mc.company_id = c.id\n    JOIN\n        movie_keyword mk ON t.id = mk.movie_id\n    JOIN\n        keyword k ON mk.keyword_id = k.id\n    JOIN\n        comp_cast_type ct ON ci.person_role_id = ct.id\n    WHERE\n        t.production_year BETWEEN 2000 AND 2020\n        AND k.keyword IS NOT NULL\n),\nRankedMovies AS (\n    SELECT \n        MovieTitle,\n        ProductionYear,\n        ActorName,\n        CastType,\n        CompanyName,\n        Keyword,\n        ROW_NUMBER() OVER (PARTITION BY ProductionYear ORDER BY MovieTitle) AS Rank\n    FROM \n        MovieDetails\n)\nSELECT \n    ProductionYear,\n    COUNT(*) AS TotalMovies,\n    STRING_AGG(DISTINCT MovieTitle, '; ') AS MovieTitles,\n    STRING_AGG(DISTINCT ActorName, '; ') AS Actors,\n    STRING_AGG(DISTINCT CompanyName, '; ') AS ProductionCompanies,\n    STRING_AGG(DISTINCT Keyword, '; ') AS Keywords\nFROM \n    RankedMovies\nGROUP BY \n    ProductionYear\nORDER BY \n    ProductionYear DESC\nLIMIT 10;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "8619.sql", "original_sql": "\nSELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    STRING_AGG(DISTINCT k.keyword, ', ') AS keywords,\n    c.kind AS company_type,\n    pi.info AS person_info\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nLEFT JOIN \n    person_info pi ON a.person_id = pi.person_id\nWHERE \n    t.production_year >= 2000\n    AND c.kind LIKE 'Distributor%'\nGROUP BY \n    a.name, t.title, t.production_year, c.kind, pi.info\nORDER BY \n    t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH filtered_movies AS (\n    SELECT t.id AS movie_id,\n           t.title AS movie_title,\n           t.production_year,\n           c.kind AS company_type\n    FROM title t\n    JOIN movie_companies mc ON t.id = mc.movie_id\n    JOIN company_type c ON mc.company_type_id = c.id\n    WHERE t.production_year >= 2000\n      AND c.kind LIKE 'Distributor%'\n)\nSELECT fm.movie_id,\n       fm.movie_title,\n       fm.production_year,\n       fm.company_type,\n       STRING_AGG(DISTINCT k.keyword, ', ') AS keywords\nFROM filtered_movies fm\nJOIN movie_keyword mk ON fm.movie_id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nGROUP BY fm.movie_id, fm.movie_title, fm.production_year, fm.company_type;", "sql2": "SELECT \n    a.name AS actor_name,\n    s1.movie_title,\n    s1.production_year,\n    s1.keywords,\n    s1.company_type,\n    pi.info AS person_info\nFROM s1\nJOIN cast_info ci ON s1.movie_id = ci.movie_id\nJOIN aka_name a ON ci.person_id = a.person_id\nLEFT JOIN person_info pi ON a.person_id = pi.person_id\nGROUP BY a.name, s1.movie_title, s1.production_year, s1.keywords, s1.company_type, pi.info\nORDER BY s1.production_year DESC, a.name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "8651.sql", "original_sql": "WITH movie_details AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        c.name AS company_name,\n        k.keyword AS movie_keyword,\n        a.name AS actor_name\n    FROM \n        aka_title t\n    JOIN \n        movie_companies mc ON t.id = mc.movie_id\n    JOIN \n        company_name c ON mc.company_id = c.id\n    JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    JOIN \n        cast_info ci ON t.id = ci.movie_id\n    JOIN \n        aka_name a ON ci.person_id = a.person_id\n    WHERE \n        t.production_year >= 2000 \n        AND c.country_code = 'USA'\n),\ninfo_aspect AS (\n    SELECT \n        md.movie_id,\n        COUNT(DISTINCT md.company_name) AS num_companies,\n        COUNT(DISTINCT md.movie_keyword) AS num_keywords,\n        COUNT(DISTINCT md.actor_name) AS num_actors\n    FROM \n        movie_details md\n    GROUP BY \n        md.movie_id\n)\nSELECT \n    md.movie_id,\n    md.title,\n    md.production_year,\n    ia.num_companies,\n    ia.num_keywords,\n    ia.num_actors\nFROM \n    movie_details md\nJOIN \n    info_aspect ia ON md.movie_id = ia.movie_id\nORDER BY \n    md.production_year DESC, \n    ia.num_actors DESC, \n    ia.num_companies DESC\nLIMIT 50;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH movie_details AS (\n    SELECT \n        t.id AS movie_id,\n        c.name AS company_name,\n        k.keyword AS movie_keyword,\n        a.name AS actor_name\n    FROM aka_title t\n    JOIN movie_companies mc ON t.id = mc.movie_id\n    JOIN company_name c ON mc.company_id = c.id\n    JOIN movie_keyword mk ON t.id = mk.movie_id\n    JOIN keyword k ON mk.keyword_id = k.id\n    JOIN cast_info ci ON t.id = ci.movie_id\n    JOIN aka_name a ON ci.person_id = a.person_id\n    WHERE t.production_year >= 2000\n      AND c.country_code = 'USA'\n)\nSELECT \n    md.movie_id,\n    COUNT(DISTINCT md.company_name) AS num_companies,\n    COUNT(DISTINCT md.movie_keyword) AS num_keywords,\n    COUNT(DISTINCT md.actor_name) AS num_actors\nFROM movie_details md\nGROUP BY md.movie_id;", "sql2": "SELECT \n    t.id AS movie_id,\n    t.title,\n    t.production_year,\n    s1.num_companies,\n    s1.num_keywords,\n    s1.num_actors\nFROM aka_title t\nJOIN s1 ON t.id = s1.movie_id\nWHERE t.production_year >= 2000\nORDER BY t.production_year DESC,\n         s1.num_actors DESC,\n         s1.num_companies DESC\nLIMIT 50;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "8656.sql", "original_sql": "WITH RankedMovies AS (\n    SELECT \n        t.id AS movie_id,\n        t.title,\n        t.production_year,\n        COUNT(ka.id) AS aka_count,\n        COUNT(DISTINCT c.person_id) AS cast_count\n    FROM \n        aka_title t\n    LEFT JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    LEFT JOIN \n        aka_name ka ON mk.keyword_id = ka.id\n    LEFT JOIN \n        cast_info c ON t.id = c.movie_id\n    GROUP BY \n        t.id, t.title, t.production_year\n),\nRankedCompanies AS (\n    SELECT \n        mc.movie_id,\n        COUNT(DISTINCT cn.id) AS company_count,\n        STRING_AGG(DISTINCT cn.name, ', ') AS company_names\n    FROM \n        movie_companies mc\n    JOIN \n        company_name cn ON mc.company_id = cn.id\n    GROUP BY \n        mc.movie_id\n)\nSELECT \n    rm.movie_id,\n    rm.title,\n    rm.production_year,\n    rm.aka_count,\n    rm.cast_count,\n    rc.company_count,\n    rc.company_names\nFROM \n    RankedMovies rm\nLEFT JOIN \n    RankedCompanies rc ON rm.movie_id = rc.movie_id\nWHERE \n    rm.production_year >= 2000\nORDER BY \n    rm.production_year DESC, rm.title;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "8690.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.role_id AS role_identification,\n    co.name AS company_name,\n    ki.keyword AS movie_keyword \nFROM \n    aka_name a \nJOIN \n    cast_info c ON a.person_id = c.person_id \nJOIN \n    aka_title t ON c.movie_id = t.movie_id \nJOIN \n    movie_companies mc ON t.id = mc.movie_id \nJOIN \n    company_name co ON mc.company_id = co.id \nJOIN \n    movie_keyword mk ON t.id = mk.movie_id \nJOIN \n    keyword ki ON mk.keyword_id = ki.id \nWHERE \n    t.production_year BETWEEN 2000 AND 2020 \n    AND co.country_code = 'USA' \nORDER BY \n    t.production_year DESC, \n    a.name;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT DISTINCT t.id AS movie_id, co.name AS company_name FROM title t JOIN movie_companies mc ON t.id = mc.movie_id JOIN company_name co ON mc.company_id = co.id WHERE t.production_year BETWEEN 2000 AND 2020 AND co.country_code = 'USA'", "sql2": "SELECT a.name AS actor_name,\n       t.title AS movie_title,\n       c.role_id AS role_identification,\n       s1.company_name,\n       ki.keyword AS movie_keyword\nFROM s1\nJOIN title t ON s1.movie_id = t.id\nJOIN cast_info c ON t.id = c.movie_id\nJOIN aka_name a ON c.person_id = a.person_id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword ki ON mk.keyword_id = ki.id\nORDER BY t.production_year DESC, a.name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "8694.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.kind AS company_type,\n    ci.nr_order AS cast_order,\n    mi.info AS movie_info,\n    k.keyword AS movie_keyword\nFROM\n    aka_name a\nJOIN\n    cast_info ci ON a.person_id = ci.person_id\nJOIN\n    aka_title t ON ci.movie_id = t.movie_id\nJOIN\n    movie_companies mc ON t.id = mc.movie_id\nJOIN\n    company_name cn ON mc.company_id = cn.id\nJOIN\n    company_type c ON mc.company_type_id = c.id\nJOIN\n    movie_info mi ON t.id = mi.movie_id\nJOIN\n    movie_keyword mk ON t.id = mk.movie_id\nJOIN\n    keyword k ON mk.keyword_id = k.id\nWHERE\n    t.production_year > 2000\n    AND c.kind = 'Distributor'\nORDER BY \n    t.production_year DESC, \n    a.name;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'movie_id' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column ci.movie_id\", span: None }, DiagnosticNote { message: \"possible column ci.role_id\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"movie_id\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"person_id\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"movie_id\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"person_role_id\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"note\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"nr_order\" }, Column { relation: Some(Bare { table: \"ci\" }), name: \"role_id\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "8784.sql", "original_sql": "WITH MovieDetails AS (\n    SELECT \n        a.name AS actor_name,\n        t.title AS movie_title,\n        t.production_year,\n        c.kind AS comp_type,\n        k.keyword AS movie_keyword\n    FROM \n        aka_name a\n    JOIN \n        cast_info ci ON a.person_id = ci.person_id\n    JOIN \n        aka_title t ON ci.movie_id = t.movie_id\n    JOIN \n        movie_companies mc ON t.id = mc.movie_id\n    JOIN \n        company_type c ON mc.company_type_id = c.id\n    JOIN \n        movie_keyword mk ON t.id = mk.movie_id\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    WHERE \n        t.production_year > 2000 \n        AND c.kind IN ('Producer', 'Distributor')\n),\nTopMovies AS (\n    SELECT \n        movie_title,\n        COUNT(DISTINCT actor_name) AS actor_count\n    FROM \n        MovieDetails\n    GROUP BY \n        movie_title\n    HAVING \n        COUNT(DISTINCT actor_name) > 5\n)\nSELECT \n    md.actor_name,\n    tm.movie_title,\n    tm.actor_count\nFROM \n    MovieDetails md\nJOIN \n    TopMovies tm ON md.movie_title = tm.movie_title\nORDER BY \n    tm.actor_count DESC, \n    md.movie_title ASC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT a.name AS actor_name,\n       t.title AS movie_title\nFROM aka_name a\nJOIN cast_info ci ON a.person_id = ci.person_id\nJOIN aka_title t ON ci.movie_id = t.movie_id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE t.production_year > 2000\n  AND c.kind IN ('Producer', 'Distributor');", "sql2": "WITH TopMovies AS (\n    SELECT movie_title,\n           COUNT(DISTINCT actor_name) AS actor_count\n    FROM s1\n    GROUP BY movie_title\n    HAVING COUNT(DISTINCT actor_name) > 5\n)\nSELECT s1.actor_name,\n       tm.movie_title,\n       tm.actor_count\nFROM s1\nJOIN TopMovies tm ON s1.movie_title = tm.movie_title\nORDER BY tm.actor_count DESC, s1.movie_title ASC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "8785.sql", "original_sql": "WITH movie_cast AS (\n    SELECT \n        c.movie_id, \n        STRING_AGG(a.name, ', ') AS cast_names, \n        COUNT(DISTINCT c.person_id) AS total_cast_count\n    FROM \n        cast_info c\n    JOIN \n        aka_name a ON c.person_id = a.person_id\n    GROUP BY \n        c.movie_id\n), movie_keywords AS (\n    SELECT \n        mk.movie_id, \n        STRING_AGG(k.keyword, ', ') AS keywords\n    FROM \n        movie_keyword mk\n    JOIN \n        keyword k ON mk.keyword_id = k.id\n    GROUP BY \n        mk.movie_id\n), movie_details AS (\n    SELECT \n        m.id, \n        m.title, \n        m.production_year, \n        mc.cast_names, \n        mk.keywords, \n        COALESCE(mi.info, 'No info') AS movie_info\n    FROM \n        title m\n    LEFT JOIN \n        movie_cast mc ON m.id = mc.movie_id\n    LEFT JOIN \n        movie_keywords mk ON m.id = mk.movie_id\n    LEFT JOIN \n        movie_info mi ON m.id = mi.movie_id\n    ORDER BY \n        m.production_year DESC\n)\nSELECT \n    md.title, \n    md.production_year, \n    md.cast_names, \n    md.keywords, \n    md.movie_info\nFROM \n    movie_details md\nWHERE \n    md.production_year >= 2000 \n    AND md.keywords ILIKE '%action%'\n    AND md.cast_names IS NOT NULL;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "8801.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.kind AS company_type,\n    k.keyword AS movie_keyword,\n    pi.info AS person_info\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    person_info pi ON a.person_id = pi.person_id\nWHERE \n    t.production_year > 2000\n    AND c.kind = 'Production'\n    AND k.keyword LIKE '%drama%'\nORDER BY \n    t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT DISTINCT\n    ci.person_id,\n    t.id AS movie_id,\n    t.title AS movie_title,\n    t.production_year,\n    k.keyword AS movie_keyword\nFROM title t\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nJOIN cast_info ci ON ci.movie_id = t.id\nWHERE t.production_year > 2000\n  AND k.keyword LIKE '%drama%'", "sql2": "SELECT \n    a.name AS actor_name,\n    s1.movie_title,\n    c.kind AS company_type,\n    s1.movie_keyword,\n    pi.info AS person_info\nFROM s1\nJOIN aka_name a ON a.person_id = s1.person_id\nJOIN movie_companies mc ON s1.movie_id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nJOIN person_info pi ON a.person_id = pi.person_id\nWHERE c.kind = 'Production'\nORDER BY s1.production_year DESC, a.name", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "8802.sql", "original_sql": "\nSELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    c.kind AS role_kind,\n    COUNT(DISTINCT kc.keyword) AS keyword_count,\n    STRING_AGG(DISTINCT kc.keyword, ', ') AS keywords\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    comp_cast_type c ON ci.person_role_id = c.id\nLEFT JOIN \n    movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN \n    keyword kc ON mk.keyword_id = kc.id\nWHERE \n    t.production_year BETWEEN 2000 AND 2023\nGROUP BY \n    a.name, t.title, t.production_year, c.kind\nORDER BY \n    keyword_count DESC, a.name ASC;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "8860.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.kind AS company_type,\n    k.keyword AS movie_keyword,\n    p.info AS actor_info\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    person_info p ON a.person_id = p.person_id\nWHERE \n    t.production_year > 2000 \n    AND c.kind LIKE 'Production%'\nORDER BY \n    t.production_year DESC, \n    a.name ASC\nLIMIT 50;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT DISTINCT t.id AS movie_id,\n                t.title AS movie_title,\n                t.production_year,\n                c.kind AS company_type\nFROM title t\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nWHERE t.production_year > 2000\n  AND c.kind LIKE 'Production%';", "sql2": "SELECT a.name AS actor_name,\n       s1.movie_title,\n       s1.company_type,\n       k.keyword AS movie_keyword,\n       p.info AS actor_info\nFROM s1\nJOIN cast_info ci ON s1.movie_id = ci.movie_id\nJOIN aka_name a ON ci.person_id = a.person_id\nJOIN movie_keyword mk ON s1.movie_id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nJOIN person_info p ON a.person_id = p.person_id\nORDER BY s1.production_year DESC, a.name ASC\nLIMIT 50;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "8862.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    c.note AS cast_note,\n    comp.name AS company_name,\n    k.keyword AS movie_keyword,\n    r.role AS role_type,\n    pi.info AS person_info\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    title t ON c.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name comp ON mc.company_id = comp.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    role_type r ON c.role_id = r.id\nJOIN \n    person_info pi ON a.person_id = pi.person_id\nWHERE \n    t.production_year >= 2000 \n    AND comp.country_code = 'USA'\n    AND pi.info_type_id IN (SELECT id FROM info_type WHERE info = 'Biography')\nORDER BY \n    t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT a.name AS aka_name,\n       c.movie_id,\n       c.note AS cast_note,\n       r.role AS role_type,\n       pi.info AS person_info\nFROM   aka_name a\nJOIN   cast_info c ON a.person_id = c.person_id\nJOIN   role_type r ON c.role_id = r.id\nJOIN   person_info pi ON a.person_id = pi.person_id\nWHERE  pi.info_type_id IN (SELECT id FROM info_type WHERE info = 'Biography')", "sql2": "SELECT s1.aka_name,\n       t.title AS movie_title,\n       comp.name AS company_name,\n       k.keyword AS movie_keyword,\n       s1.cast_note,\n       s1.role_type,\n       s1.person_info\nFROM   s1\nJOIN   title t ON s1.movie_id = t.id\nJOIN   movie_companies mc ON t.id = mc.movie_id\nJOIN   company_name comp ON mc.company_id = comp.id\nJOIN   movie_keyword mk ON t.id = mk.movie_id\nJOIN   keyword k ON mk.keyword_id = k.id\nWHERE  t.production_year >= 2000\n  AND  comp.country_code = 'USA'\nORDER BY t.production_year DESC, s1.aka_name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "8865.sql", "original_sql": "\nSELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    STRING_AGG(DISTINCT cct.kind, ', ') AS company_types,\n    STRING_AGG(DISTINCT k.keyword, ', ') AS keywords\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    comp_cast_type cct ON ci.person_role_id = cct.id\nWHERE \n    t.production_year BETWEEN 2000 AND 2020\nGROUP BY \n    a.name, t.title, t.production_year\nORDER BY \n    t.production_year DESC, a.name;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "8899.sql", "original_sql": "SELECT \n    a.name AS actor_name, \n    t.title AS movie_title, \n    t.production_year, \n    k.keyword AS movie_keyword, \n    c.kind AS company_type \nFROM \n    aka_name a \nJOIN \n    cast_info ci ON a.person_id = ci.person_id \nJOIN \n    title t ON ci.movie_id = t.id \nJOIN \n    movie_keyword mk ON t.id = mk.movie_id \nJOIN \n    keyword k ON mk.keyword_id = k.id \nJOIN \n    movie_companies mc ON t.id = mc.movie_id \nJOIN \n    company_type c ON mc.company_type_id = c.id \nWHERE \n    t.production_year BETWEEN 2000 AND 2023 \nAND \n    c.kind LIKE '%Production%' \nORDER BY \n    t.production_year DESC, a.name ASC \nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    t.id AS movie_id,\n    t.title,\n    t.production_year,\n    k.keyword,\n    c.kind AS company_type\nFROM title t\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE t.production_year BETWEEN 2000 AND 2023\n  AND c.kind LIKE '%Production%';", "sql2": "SELECT\n    a.name AS actor_name,\n    s1.title AS movie_title,\n    s1.production_year,\n    s1.keyword AS movie_keyword,\n    s1.company_type\nFROM s1\nJOIN cast_info ci ON s1.movie_id = ci.movie_id\nJOIN aka_name a ON ci.person_id = a.person_id\nORDER BY s1.production_year DESC, a.name ASC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "8902.sql", "original_sql": "SELECT \n    a.name AS actor_name, \n    t.title AS movie_title, \n    c.nr_order AS role_order,\n    ct.kind AS company_type,\n    k.keyword AS movie_keyword,\n    m.info AS movie_info,\n    n.gender AS actor_gender\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    aka_title t ON c.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    movie_info m ON t.id = m.movie_id\nJOIN \n    name n ON a.person_id = n.imdb_id\nWHERE \n    t.production_year BETWEEN 2000 AND 2023\n    AND ct.kind IS NOT NULL\nORDER BY \n    t.production_year DESC, \n    a.name ASC, \n    c.nr_order ASC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    t.id AS movie_id,\n    t.title AS movie_title,\n    t.production_year,\n    k.keyword AS movie_keyword,\n    m.info AS movie_info\nFROM \n    aka_title t\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    movie_info m ON t.id = m.movie_id\nWHERE \n    t.production_year BETWEEN 2000 AND 2023;", "sql2": "SELECT \n    a.name AS actor_name,\n    s1.movie_title,\n    c.nr_order AS role_order,\n    ct.kind AS company_type,\n    s1.movie_keyword,\n    s1.movie_info,\n    n.gender AS actor_gender\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    name n ON a.person_id = n.id\nJOIN \n    movie_companies mc ON c.movie_id = mc.movie_id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nJOIN \n    s1 ON c.movie_id = s1.movie_id\nWHERE \n    ct.kind IS NOT NULL\nORDER BY \n    s1.production_year DESC,\n    a.name ASC,\n    c.nr_order ASC\nLIMIT 100;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "9101.sql", "original_sql": "SELECT \n    a.id AS aka_id,\n    a.name AS aka_name,\n    t.title AS movie_title,\n    t.production_year,\n    ci.nr_order,\n    c.kind AS cast_type,\n    cn.name AS company_name,\n    kt.keyword AS movie_keyword\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    comp_cast_type c ON ci.person_role_id = c.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword kt ON mk.keyword_id = kt.id\nWHERE \n    t.production_year BETWEEN 2000 AND 2023\n    AND a.name LIKE '%Smith%'\n    AND ci.nr_order <= 5\nORDER BY \n    t.production_year DESC, \n    a.name;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT \n    a.id AS aka_id,\n    a.name AS aka_name,\n    t.id AS movie_id,\n    t.title AS movie_title,\n    t.production_year,\n    ci.nr_order,\n    c.kind AS cast_type,\n    cn.name AS company_name\nFROM aka_name a\nJOIN cast_info ci ON a.person_id = ci.person_id\nJOIN title t ON ci.movie_id = t.id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN comp_cast_type c ON ci.person_role_id = c.id\nWHERE t.production_year BETWEEN 2000 AND 2023\n  AND a.name LIKE '%Smith%'\n  AND ci.nr_order <= 5;", "sql2": "SELECT \n    s1.aka_id,\n    s1.aka_name,\n    s1.movie_title,\n    s1.production_year,\n    s1.nr_order,\n    s1.cast_type,\n    s1.company_name,\n    kt.keyword AS movie_keyword\nFROM s1\nJOIN movie_keyword mk ON s1.movie_id = mk.movie_id\nJOIN keyword kt ON mk.keyword_id = kt.id\nORDER BY s1.production_year DESC, s1.aka_name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "9165.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.kind AS company_type,\n    k.keyword AS movie_keyword,\n    pi.info AS person_info\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    person_info pi ON a.person_id = pi.person_id\nWHERE \n    t.production_year >= 2000 AND\n    k.keyword LIKE '%action%'\nORDER BY \n    a.name, t.production_year DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT DISTINCT t.id AS movie_id\nFROM title t\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE t.production_year >= 2000\n  AND k.keyword LIKE '%action%';", "sql2": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.kind AS company_type,\n    k.keyword AS movie_keyword,\n    pi.info AS person_info\nFROM aka_name a\nJOIN cast_info ci ON a.person_id = ci.person_id\nJOIN title t ON ci.movie_id = t.id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nJOIN person_info pi ON a.person_id = pi.person_id\nJOIN (\n    SELECT movie_id FROM (\n        SELECT DISTINCT t.id AS movie_id\n        FROM title t\n        JOIN movie_keyword mk ON t.id = mk.movie_id\n        JOIN keyword k ON mk.keyword_id = k.id\n        WHERE t.production_year >= 2000\n          AND k.keyword LIKE '%action%'\n    )\n) AS s1 ON t.id = s1.movie_id\nWHERE k.keyword LIKE '%action%'\n  AND t.production_year >= 2000\nORDER BY a.name, t.production_year DESC\nLIMIT 100;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "9214.sql", "original_sql": "\nSELECT \n    t.title AS movie_title, \n    p.name AS actor_name, \n    COUNT(ka.id) AS alias_count, \n    STRING_AGG(k.keyword, ',') AS keywords, \n    c.kind AS company_type\nFROM \n    title t\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    cast_info ci ON cc.subject_id = ci.id\nJOIN \n    aka_name ka ON ci.person_id = ka.person_id\nJOIN \n    name p ON ka.person_id = p.imdb_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    t.production_year > 2000\nGROUP BY \n    t.title, p.name, c.kind\nORDER BY \n    alias_count DESC, movie_title ASC\nFETCH FIRST 50 ROWS ONLY;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "9289.sql", "original_sql": "\nSELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    p.info AS person_info,\n    c.kind AS company_type,\n    k.keyword AS movie_keyword,\n    r.role AS role_name,\n    t.production_year AS year\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    person_info p ON a.person_id = p.person_id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    role_type r ON ci.role_id = r.id\nWHERE \n    t.production_year > 2000\n    AND cn.country_code = 'USA'\n    AND k.keyword LIKE '%Drama%'\nORDER BY \n    t.production_year DESC, \n    a.name, \n    t.title;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT DISTINCT t.id AS movie_id,\n       t.title AS movie_title,\n       t.production_year AS year,\n       c.kind AS company_type,\n       k.keyword AS movie_keyword\nFROM title t\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_name cn ON mc.company_id = cn.id\nJOIN company_type c ON mc.company_type_id = c.id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nWHERE t.production_year > 2000\n  AND cn.country_code = 'USA'\n  AND k.keyword LIKE '%Drama%';", "sql2": "SELECT \n    a.name AS aka_name,\n    s1.movie_title,\n    p.info AS person_info,\n    s1.company_type,\n    s1.movie_keyword,\n    r.role AS role_name,\n    s1.year\nFROM s1\nJOIN cast_info ci ON s1.movie_id = ci.movie_id\nJOIN aka_name a ON a.person_id = ci.person_id\nJOIN person_info p ON a.person_id = p.person_id\nJOIN role_type r ON ci.role_id = r.id\nJOIN complete_cast cc ON s1.movie_id = cc.movie_id\nORDER BY s1.year DESC, a.name, s1.movie_title;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "9316.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    c.nr_order AS cast_order,\n    p.info AS person_info,\n    co.name AS company_name,\n    k.keyword AS movie_keyword,\n    r.role AS actor_role\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    title t ON c.movie_id = t.id\nLEFT JOIN \n    person_info p ON a.person_id = p.person_id\nLEFT JOIN \n    movie_companies mc ON t.id = mc.movie_id\nLEFT JOIN \n    company_name co ON mc.company_id = co.id\nLEFT JOIN \n    movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    role_type r ON c.role_id = r.id\nWHERE \n    t.production_year > 2000 \n    AND r.role = 'Actor'\nORDER BY \n    t.production_year DESC, \n    a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    c.nr_order AS cast_order,\n    a.person_id,\n    t.id AS movie_id,\n    t.production_year\nFROM aka_name a\nJOIN cast_info c ON a.person_id = c.person_id\nJOIN title t ON c.movie_id = t.id\nJOIN role_type r ON c.role_id = r.id\nWHERE t.production_year > 2000\n  AND r.role = 'Actor'", "sql2": "SELECT \n    s1.aka_name,\n    s1.movie_title,\n    s1.cast_order,\n    p.info AS person_info,\n    co.name AS company_name,\n    k.keyword AS movie_keyword,\n    'Actor' AS actor_role\nFROM s1\nLEFT JOIN person_info p ON s1.person_id = p.person_id\nLEFT JOIN movie_companies mc ON s1.movie_id = mc.movie_id\nLEFT JOIN company_name co ON mc.company_id = co.id\nLEFT JOIN movie_keyword mk ON s1.movie_id = mk.movie_id\nLEFT JOIN keyword k ON mk.keyword_id = k.id\nORDER BY s1.production_year DESC, s1.aka_name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "9504.sql", "original_sql": "SELECT \n    t.title AS movie_title,\n    a.name AS actor_name,\n    c.kind AS cast_role,\n    m.info AS movie_info,\n    k.keyword AS movie_keyword,\n    cm.name AS company_name,\n    ct.kind AS company_type\nFROM \n    aka_title t\nJOIN \n    cast_info ci ON t.id = ci.movie_id\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    comp_cast_type c ON ci.person_role_id = c.id\nJOIN \n    complete_cast cc ON t.id = cc.movie_id\nJOIN \n    movie_info m ON t.id = m.movie_id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cm ON mc.company_id = cm.id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nWHERE \n    t.production_year >= 2000 \nAND \n    a.surname_pcode IS NOT NULL \nAND \n    m.info_type_id IN (SELECT id FROM info_type WHERE info LIKE '%box office%')\nORDER BY \n    t.production_year DESC, a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS movie_id,\n       t.title AS movie_title,\n       t.production_year,\n       m.info AS movie_info,\n       k.keyword AS movie_keyword\nFROM   aka_title t\nJOIN   movie_info m      ON t.id = m.movie_id\nJOIN   info_type it      ON m.info_type_id = it.id\nJOIN   movie_keyword mk  ON t.id = mk.movie_id\nJOIN   keyword k         ON mk.keyword_id = k.id\nWHERE  t.production_year >= 2000\n  AND  it.info LIKE '%box office%';", "sql2": "SELECT s1.movie_title,\n       a.name AS actor_name,\n       c.kind AS cast_role,\n       s1.movie_info,\n       s1.movie_keyword,\n       cm.name AS company_name,\n       ct.kind AS company_type\nFROM   s1\nJOIN   cast_info ci      ON s1.movie_id = ci.movie_id\nJOIN   aka_name a        ON ci.person_id = a.person_id\nJOIN   comp_cast_type c  ON ci.person_role_id = c.id\nJOIN   movie_companies mc ON s1.movie_id = mc.movie_id\nJOIN   company_name cm   ON mc.company_id = cm.id\nJOIN   company_type ct   ON mc.company_type_id = ct.id\nWHERE  a.surname_pcode IS NOT NULL\nORDER BY s1.production_year DESC, a.name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "9563.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.kind AS company_type,\n    co.name AS company_name,\n    m.production_year,\n    k.keyword AS movie_keyword,\n    SUM(CASE WHEN a.name IS NOT NULL THEN 1 ELSE 0 END) AS actor_count\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    aka_title t ON ci.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name co ON mc.company_id = co.id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    title m ON t.id = m.id\nWHERE \n    m.production_year > 2000\nGROUP BY \n    a.name, t.title, c.kind, co.name, m.production_year, k.keyword\nORDER BY \n    actor_count DESC, m.production_year DESC\nLIMIT 50;\n", "status": "oom", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 178, in _run_single_node\n    out_tbl = self._run_on_duckdb(node.sql)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 104, in _run_on_duckdb\n    return self.con.execute(sql).arrow()\n           ^^^^^^^^^^^^^^^^^^^^^\nduckdb.duckdb.OutOfMemoryException: Out of Memory Error: Failed to allocate block of 262144 bytes (bad allocation)\n", "engine_mem_mb": 500000}
{"query_id": "9606.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    c.nr_order AS cast_order,\n    p.info AS person_info,\n    co.name AS company_name,\n    k.keyword AS movie_keyword,\n    r.role AS role_type\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    title t ON c.movie_id = t.id\nJOIN \n    person_info p ON a.person_id = p.person_id AND p.info_type_id = (SELECT id FROM info_type WHERE info = 'Biography')\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name co ON mc.company_id = co.id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    role_type r ON c.role_id = r.id\nWHERE \n    t.production_year BETWEEN 2000 AND 2020\n    AND co.country_code = 'USA'\nORDER BY \n    t.production_year DESC, \n    c.nr_order ASC\nLIMIT 50;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT a.person_id,\n       a.name AS aka_name,\n       p.info AS person_info\nFROM aka_name a\nJOIN person_info p\n  ON a.person_id = p.person_id\nWHERE p.info_type_id = (SELECT id FROM info_type WHERE info = 'Biography')", "sql2": "SELECT \n    s1.aka_name,\n    t.title AS movie_title,\n    c.nr_order AS cast_order,\n    s1.person_info,\n    co.name AS company_name,\n    k.keyword AS movie_keyword,\n    r.role AS role_type\nFROM s1\nJOIN cast_info c ON s1.person_id = c.person_id\nJOIN title t ON c.movie_id = t.id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_name co ON mc.company_id = co.id\nJOIN movie_keyword mk ON t.id = mk.movie_id\nJOIN keyword k ON mk.keyword_id = k.id\nJOIN role_type r ON c.role_id = r.id\nWHERE t.production_year BETWEEN 2000 AND 2020\n  AND co.country_code = 'USA'\nORDER BY t.production_year DESC, c.nr_order ASC\nLIMIT 50;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "9611.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    c.role_id,\n    co.name AS company_name,\n    COUNT(DISTINCT k.keyword) AS keyword_count\nFROM \n    cast_info c\nJOIN \n    aka_name a ON c.person_id = a.person_id\nJOIN \n    aka_title t ON c.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name co ON mc.company_id = co.id\nLEFT JOIN \n    movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    t.production_year >= 2000\n    AND c.nr_order < 10\n    AND co.country_code = 'USA'\nGROUP BY \n    a.name, t.title, c.role_id, co.name\nORDER BY \n    keyword_count DESC, a.name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH base AS (\n    SELECT \n        a.name AS actor_name,\n        t.title AS movie_title,\n        c.role_id,\n        co.name AS company_name,\n        t.id AS movie_id\n    FROM cast_info c\n    JOIN aka_name a ON c.person_id = a.person_id\n    JOIN aka_title t ON c.movie_id = t.movie_id\n    JOIN movie_companies mc ON t.id = mc.movie_id\n    JOIN company_name co ON mc.company_id = co.id\n    WHERE t.production_year >= 2000\n      AND c.nr_order < 10\n      AND co.country_code = 'USA'\n)\nSELECT actor_name, movie_title, role_id, company_name, movie_id\nFROM base;", "sql2": "SELECT \n    s1.actor_name,\n    s1.movie_title,\n    s1.role_id,\n    s1.company_name,\n    kw.keyword_count\nFROM s1\nJOIN (\n    SELECT mk.movie_id, COUNT(DISTINCT k.keyword) AS keyword_count\n    FROM movie_keyword mk\n    JOIN keyword k ON mk.keyword_id = k.id\n    GROUP BY mk.movie_id\n) kw ON s1.movie_id = kw.movie_id\nORDER BY kw.keyword_count DESC, s1.actor_name;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "9629.sql", "original_sql": "\nSELECT \n    a.name AS actor_name, \n    t.title AS movie_title, \n    c.kind AS company_type, \n    STRING_AGG(DISTINCT k.keyword, ',') AS keywords,\n    COUNT(DISTINCT mi.id) AS info_count\nFROM \n    cast_info ci \nJOIN \n    aka_name a ON ci.person_id = a.person_id \nJOIN \n    aka_title t ON ci.movie_id = t.movie_id \nJOIN \n    movie_companies mc ON t.id = mc.movie_id \nJOIN \n    company_type c ON mc.company_type_id = c.id \nLEFT JOIN \n    movie_keyword mk ON t.id = mk.movie_id \nLEFT JOIN \n    keyword k ON mk.keyword_id = k.id \nLEFT JOIN \n    movie_info mi ON t.id = mi.movie_id \nWHERE \n    t.production_year > 2000 \n    AND c.kind IS NOT NULL \nGROUP BY \n    a.name, t.title, c.kind \nORDER BY \n    info_count DESC, actor_name ASC;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "9776.sql", "original_sql": "\nSELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    STRING_AGG(DISTINCT c.kind, ', ') AS company_types,\n    STRING_AGG(DISTINCT k.keyword, ', ') AS keywords,\n    COUNT(DISTINCT p.id) AS total_person_info\nFROM \n    cast_info ci\nJOIN \n    aka_name a ON ci.person_id = a.person_id\nJOIN \n    aka_title t ON ci.movie_id = t.movie_id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type c ON mc.company_type_id = c.id\nLEFT JOIN \n    movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN \n    keyword k ON mk.keyword_id = k.id\nLEFT JOIN \n    person_info p ON ci.person_id = p.person_id\nWHERE \n    t.production_year >= 2000 \nGROUP BY \n    a.name, t.title, t.production_year\nORDER BY \n    t.production_year DESC, actor_name;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    c.kind AS company_type,\n    k.keyword,\n    p.id AS person_info_id\nFROM cast_info ci\nJOIN aka_name a ON ci.person_id = a.person_id\nJOIN aka_title t ON ci.movie_id = t.movie_id\nJOIN movie_companies mc ON t.id = mc.movie_id\nJOIN company_type c ON mc.company_type_id = c.id\nLEFT JOIN movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN keyword k ON mk.keyword_id = k.id\nLEFT JOIN person_info p ON ci.person_id = p.person_id\nWHERE t.production_year >= 2000;", "sql2": "SELECT \n    actor_name,\n    movie_title,\n    production_year,\n    STRING_AGG(DISTINCT company_type, ', ') AS company_types,\n    STRING_AGG(DISTINCT keyword, ', ') AS keywords,\n    COUNT(DISTINCT person_info_id) AS total_person_info\nFROM s1\nGROUP BY actor_name, movie_title, production_year\nORDER BY production_year DESC, actor_name;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "9809.sql", "original_sql": "SELECT \n    ak.name AS actor_name,\n    ak.imdb_index AS actor_imdb_index,\n    at.title AS movie_title,\n    at.production_year AS movie_year,\n    c.role_id AS role_id,\n    ct.kind AS company_type,\n    cn.name AS company_name,\n    mi.info AS movie_info,\n    k.keyword AS movie_keyword\nFROM \n    aka_name ak\nJOIN \n    cast_info c ON ak.person_id = c.person_id\nJOIN \n    aka_title at ON c.movie_id = at.movie_id\nJOIN \n    movie_companies mc ON at.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nLEFT JOIN \n    movie_info mi ON at.id = mi.movie_id AND mi.info_type_id = (SELECT id FROM info_type WHERE info = 'Box Office')\nLEFT JOIN \n    movie_keyword mk ON at.id = mk.movie_id\nLEFT JOIN \n    keyword k ON mk.keyword_id = k.id\nWHERE \n    at.production_year > 2000\n    AND ak.name IS NOT NULL\nORDER BY \n    at.production_year DESC, ak.name ASC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    ak.name AS actor_name,\n    ak.imdb_index AS actor_imdb_index,\n    at.title AS movie_title,\n    at.production_year AS movie_year,\n    c.role_id AS role_id,\n    ct.kind AS company_type,\n    cn.name AS company_name,\n    at.id AS movie_id\nFROM \n    aka_name ak\nJOIN \n    cast_info c ON ak.person_id = c.person_id\nJOIN \n    aka_title at ON c.movie_id = at.movie_id\nJOIN \n    movie_companies mc ON at.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nWHERE \n    at.production_year > 2000\n    AND ak.name IS NOT NULL", "sql2": "SELECT \n    s1.actor_name,\n    s1.actor_imdb_index,\n    s1.movie_title,\n    s1.movie_year,\n    s1.role_id,\n    s1.company_type,\n    s1.company_name,\n    mi.info AS movie_info,\n    k.keyword AS movie_keyword\nFROM \n    s1\nLEFT JOIN \n    movie_info mi ON s1.movie_id = mi.movie_id AND mi.info_type_id = (SELECT id FROM info_type WHERE info = 'Box Office')\nLEFT JOIN \n    movie_keyword mk ON s1.movie_id = mk.movie_id\nLEFT JOIN \n    keyword k ON mk.keyword_id = k.id\nORDER BY \n    s1.movie_year DESC, s1.actor_name ASC\nLIMIT 100", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "9823.sql", "original_sql": "SELECT \n    a.name AS aka_name,\n    t.title AS movie_title,\n    c.note AS cast_note,\n    p.info AS person_info,\n    k.keyword AS movie_keyword,\n    comp.name AS company_name,\n    r.role AS role_type\nFROM \n    aka_name a\nJOIN \n    cast_info c ON a.person_id = c.person_id\nJOIN \n    title t ON c.movie_id = t.id\nJOIN \n    person_info p ON a.person_id = p.person_id\nJOIN \n    movie_keyword mk ON t.id = mk.movie_id\nJOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name comp ON mc.company_id = comp.id\nJOIN \n    role_type r ON c.role_id = r.id\nWHERE \n    t.production_year > 2000\nAND \n    p.info_type_id = (SELECT id FROM info_type WHERE info = 'Biography')\nORDER BY \n    t.production_year DESC, a.name;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "9936.sql", "original_sql": "SELECT \n    an.name AS actor_name,\n    at.title AS movie_title,\n    at.production_year,\n    c.role_id,\n    COUNT(*) AS total_movies\nFROM \n    aka_name an\nJOIN \n    cast_info c ON an.person_id = c.person_id\nJOIN \n    aka_title at ON c.movie_id = at.movie_id\nJOIN \n    complete_cast cc ON at.id = cc.movie_id\nJOIN \n    movie_companies mc ON at.id = mc.movie_id\nJOIN \n    company_name co ON mc.company_id = co.id\nJOIN \n    role_type rt ON c.role_id = rt.id\nWHERE \n    at.production_year >= 2000 AND \n    co.country_code = 'USA'\nGROUP BY \n    an.name, at.title, at.production_year, c.role_id\nHAVING \n    COUNT(*) > 1\nORDER BY \n    total_movies DESC, an.name ASC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT DISTINCT\n    at.id AS movie_id,\n    at.title AS movie_title,\n    at.production_year\nFROM aka_title AS at\nJOIN movie_companies AS mc ON at.id = mc.movie_id\nJOIN company_name AS co ON mc.company_id = co.id\nWHERE at.production_year >= 2000\n  AND co.country_code = 'USA';", "sql2": "SELECT \n    an.name AS actor_name,\n    s1.movie_title,\n    s1.production_year,\n    c.role_id,\n    COUNT(*) AS total_movies\nFROM aka_name AS an\nJOIN cast_info AS c ON an.person_id = c.person_id\nJOIN s1 ON c.movie_id = s1.movie_id\nJOIN complete_cast AS cc ON s1.movie_id = cc.movie_id\nJOIN role_type AS rt ON c.role_id = rt.id\nGROUP BY \n    an.name,\n    s1.movie_title,\n    s1.production_year,\n    c.role_id\nHAVING COUNT(*) > 1\nORDER BY \n    total_movies DESC,\n    an.name ASC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "9945.sql", "original_sql": "SELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    t.production_year,\n    cp.kind AS company_type,\n    k.keyword AS movie_keyword,\n    r.role AS actor_role\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_name cn ON mc.company_id = cn.id\nJOIN \n    company_type cp ON mc.company_type_id = cp.id\nLEFT JOIN \n    movie_keyword mk ON t.id = mk.movie_id\nLEFT JOIN \n    keyword k ON mk.keyword_id = k.id\nJOIN \n    role_type r ON ci.role_id = r.id\nWHERE \n    a.name IS NOT NULL \n    AND t.production_year >= 2000\nORDER BY \n    t.production_year DESC, \n    a.name ASC \nLIMIT 100;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'movie_id' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column mc.movie_id\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"movie_id\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"mc\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"mc\" }), name: \"movie_id\" }, Column { relation: Some(Bare { table: \"mc\" }), name: \"company_id\" }, Column { relation: Some(Bare { table: \"mc\" }), name: \"company_type_id\" }, Column { relation: Some(Bare { table: \"mc\" }), name: \"note\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "9978.sql", "original_sql": "\nSELECT \n    a.name AS actor_name,\n    t.title AS movie_title,\n    ct.kind AS company_type,\n    mc.note AS company_note,\n    mi.info AS movie_info\nFROM \n    aka_name a\nJOIN \n    cast_info ci ON a.person_id = ci.person_id\nJOIN \n    title t ON ci.movie_id = t.id\nJOIN \n    movie_companies mc ON t.id = mc.movie_id\nJOIN \n    company_type ct ON mc.company_type_id = ct.id\nJOIN \n    movie_info mi ON t.id = mi.movie_id\nJOIN \n    info_type it ON mi.info_type_id = it.id\nWHERE \n    it.info = 'budget'\n    AND t.production_year BETWEEN 2000 AND 2023\nGROUP BY \n    a.name, \n    t.title, \n    ct.kind, \n    mc.note, \n    mi.info, \n    t.production_year\nORDER BY \n    t.production_year DESC, \n    actor_name;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT t.id AS movie_id,\n       t.title AS movie_title,\n       mi.info AS movie_info,\n       t.production_year\nFROM title t\nJOIN movie_info mi ON t.id = mi.movie_id\nJOIN info_type it ON mi.info_type_id = it.id\nWHERE it.info = 'budget'\n  AND t.production_year BETWEEN 2000 AND 2023;", "sql2": "SELECT a.name AS actor_name,\n       s1.movie_title,\n       ct.kind AS company_type,\n       mc.note AS company_note,\n       s1.movie_info\nFROM s1\nJOIN cast_info ci ON ci.movie_id = s1.movie_id\nJOIN aka_name a ON a.person_id = ci.person_id\nJOIN movie_companies mc ON mc.movie_id = s1.movie_id\nJOIN company_type ct ON mc.company_type_id = ct.id\nGROUP BY a.name,\n         s1.movie_title,\n         ct.kind,\n         mc.note,\n         s1.movie_info,\n         s1.production_year\nORDER BY s1.production_year DESC,\n         actor_name;", "results_match": true, "engine_mem_mb": 500000}
