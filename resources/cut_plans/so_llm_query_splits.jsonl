{"query_id": "10053.sql", "original_sql": "WITH UserVoteSummary AS (\n    SELECT\n        U.Id AS UserId,\n        U.DisplayName,\n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n        COUNT(DISTINCT P.Id) AS PostCount\n    FROM\n        Users U\n    LEFT JOIN\n        Posts P ON U.Id = P.OwnerUserId\n    LEFT JOIN\n        Votes V ON P.Id = V.PostId\n    GROUP BY\n        U.Id, U.DisplayName\n),\nTopUsers AS (\n    SELECT\n        *,\n        (UpVotes - DownVotes) AS VoteBalance\n    FROM\n        UserVoteSummary\n    ORDER BY\n        VoteBalance DESC\n    LIMIT 10\n)\n\nSELECT\n    T.DisplayName,\n    T.UpVotes,\n    T.DownVotes,\n    T.VoteBalance,\n    P.CreationDate AS PostCreationDate,\n    P.Title AS PostTitle,\n    P.ViewCount,\n    P.Score\nFROM\n    TopUsers T\nJOIN\n    Posts P ON T.UserId = P.OwnerUserId\nORDER BY\n    T.VoteBalance DESC, P.ViewCount DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    U.Id AS UserId,\n    U.DisplayName,\n    SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n    SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n    COUNT(DISTINCT P.Id) AS PostCount,\n    (SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) -\n     SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END)) AS VoteBalance\nFROM Users U\nLEFT JOIN Posts P ON U.Id = P.OwnerUserId\nLEFT JOIN Votes V ON P.Id = V.PostId\nGROUP BY U.Id, U.DisplayName\nORDER BY VoteBalance DESC\nLIMIT 10;", "sql2": "SELECT\n    s1.DisplayName,\n    s1.UpVotes,\n    s1.DownVotes,\n    s1.VoteBalance,\n    P.CreationDate AS PostCreationDate,\n    P.Title AS PostTitle,\n    P.ViewCount,\n    P.Score\nFROM s1\nJOIN Posts P ON s1.UserId = P.OwnerUserId\nORDER BY s1.VoteBalance DESC, P.ViewCount DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "10060.sql", "original_sql": "WITH PostMetrics AS (\n    SELECT \n        P.Id AS PostId,\n        P.Title,\n        P.CreationDate,\n        P.Score,\n        P.ViewCount,\n        P.AnswerCount,\n        P.CommentCount,\n        U.DisplayName AS OwnerDisplayName,\n        P.LastActivityDate,\n        PT.Name AS PostType\n    FROM \n        Posts P\n    JOIN \n        Users U ON P.OwnerUserId = U.Id\n    JOIN \n        PostTypes PT ON P.PostTypeId = PT.Id\n),\nVoteMetrics AS (\n    SELECT \n        PostId,\n        COUNT(CASE WHEN VoteTypeId = 2 THEN 1 END) AS Upvotes,\n        COUNT(CASE WHEN VoteTypeId = 3 THEN 1 END) AS Downvotes\n    FROM \n        Votes\n    GROUP BY \n        PostId\n),\nBadgeMetrics AS (\n    SELECT \n        UserId,\n        COUNT(*) AS BadgeCount\n    FROM \n        Badges\n    GROUP BY \n        UserId\n)\nSELECT \n    PM.PostId,\n    PM.Title,\n    PM.CreationDate,\n    PM.Score,\n    PM.ViewCount,\n    PM.AnswerCount,\n    PM.CommentCount,\n    PM.OwnerDisplayName,\n    PM.LastActivityDate,\n    PM.PostType,\n    VM.Upvotes,\n    VM.Downvotes,\n    BM.BadgeCount\nFROM \n    PostMetrics PM\nLEFT JOIN \n    VoteMetrics VM ON PM.PostId = VM.PostId\nLEFT JOIN \n    BadgeMetrics BM ON PM.OwnerDisplayName = (SELECT DisplayName FROM Users WHERE Id = BM.UserId)\nORDER BY \n    PM.LastActivityDate DESC\nLIMIT 100;", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "10094.sql", "original_sql": "\nSELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate AS PostCreationDate,\n    p.ViewCount,\n    p.Score,\n    u.Id AS UserId,\n    u.DisplayName AS UserDisplayName,\n    u.Reputation AS UserReputation,\n    COUNT(v.Id) AS VoteCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n    COUNT(c.Id) AS CommentCount,\n    COUNT(b.Id) AS BadgeCount\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Badges b ON u.Id = b.UserId\nWHERE \n    p.CreationDate >= '2020-01-01'  \nGROUP BY \n    p.Id, p.Title, p.CreationDate, p.ViewCount, p.Score, \n    u.Id, u.DisplayName, u.Reputation\nORDER BY \n    p.Score DESC, p.ViewCount DESC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT\n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate AS PostCreationDate,\n    p.ViewCount,\n    p.Score,\n    p.OwnerUserId,\n    COUNT(v.Id) AS VoteCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n    COUNT(c.Id) AS CommentCount\nFROM Posts p\nLEFT JOIN Votes v ON p.Id = v.PostId\nLEFT JOIN Comments c ON p.Id = c.PostId\nWHERE p.CreationDate >= DATE '2020-01-01'\nGROUP BY p.Id, p.Title, p.CreationDate, p.ViewCount, p.Score, p.OwnerUserId;", "sql2": "SELECT\n    s1.PostId,\n    s1.Title,\n    s1.PostCreationDate,\n    s1.ViewCount,\n    s1.Score,\n    u.Id AS UserId,\n    u.DisplayName AS UserDisplayName,\n    u.Reputation AS UserReputation,\n    s1.VoteCount,\n    s1.UpVotes,\n    s1.DownVotes,\n    s1.CommentCount,\n    COALESCE(b.BadgeCount, 0) AS BadgeCount\nFROM s1\nJOIN Users u ON s1.OwnerUserId = u.Id\nLEFT JOIN (\n    SELECT UserId, COUNT(Id) AS BadgeCount\n    FROM Badges\n    GROUP BY UserId\n) b ON u.Id = b.UserId\nORDER BY s1.Score DESC, s1.ViewCount DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "10099.sql", "original_sql": "SELECT \n    pt.Name AS PostType,\n    COUNT(p.Id) AS PostCount,\n    AVG(p.Score) AS AverageScore,\n    SUM(c.CommentCount) AS TotalComments\nFROM \n    Posts p\nJOIN \n    PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN \n    (SELECT \n         PostId, COUNT(Id) AS CommentCount \n     FROM \n         Comments \n     GROUP BY \n         PostId) c ON p.Id = c.PostId\nGROUP BY \n    pt.Name\nORDER BY \n    PostCount DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT PostId, COUNT(Id) AS CommentCount FROM Comments GROUP BY PostId;", "sql2": "SELECT pt.Name AS PostType,\n       COUNT(p.Id) AS PostCount,\n       AVG(p.Score) AS AverageScore,\n       SUM(COALESCE(s1.CommentCount, 0)) AS TotalComments\nFROM Posts p\nJOIN PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN s1 ON p.Id = s1.PostId\nGROUP BY pt.Name\nORDER BY PostCount DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "10118.sql", "original_sql": "WITH PostStats AS (\n    SELECT \n        COUNT(*) AS TotalPosts,\n        COUNT(DISTINCT OwnerUserId) AS TotalUsers,\n        AVG(ViewCount) AS AvgViewCount,\n        AVG(Score) AS AvgScore\n    FROM Posts\n),\nUserStats AS (\n    SELECT\n        COUNT(*) AS TotalUsers,\n        AVG(Reputation) AS AvgReputation,\n        AVG(UpVotes) AS AvgUpVotes,\n        AVG(DownVotes) AS AvgDownVotes\n    FROM Users\n),\nVoteStats AS (\n    SELECT\n        COUNT(*) AS TotalVotes,\n        COUNT(DISTINCT PostId) AS TotalPostVotes,\n        AVG(CASE WHEN VoteTypeId = 2 THEN 1 ELSE 0 END) AS AvgUpVotes,\n        AVG(CASE WHEN VoteTypeId = 3 THEN 1 ELSE 0 END) AS AvgDownVotes\n    FROM Votes\n)\n\nSELECT \n    p.TotalPosts,\n    p.TotalUsers AS UniquePostOwners,\n    p.AvgViewCount,\n    p.AvgScore,\n    u.TotalUsers AS UserCount,\n    u.AvgReputation,\n    u.AvgUpVotes AS UserAvgUpVotes,\n    u.AvgDownVotes AS UserAvgDownVotes,\n    v.TotalVotes,\n    v.TotalPostVotes,\n    v.AvgUpVotes AS VoteAvgUpVotes,\n    v.AvgDownVotes AS VoteAvgDownVotes\nFROM PostStats p\nJOIN UserStats u ON 1=1\nJOIN VoteStats v ON 1=1;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH PostStats AS (\n    SELECT \n        COUNT(*) AS TotalPosts,\n        COUNT(DISTINCT OwnerUserId) AS TotalPostOwners,\n        AVG(ViewCount) AS AvgViewCount,\n        AVG(Score) AS AvgScore\n    FROM Posts\n),\nUserStats AS (\n    SELECT\n        COUNT(*) AS UserCount,\n        AVG(Reputation) AS AvgReputation,\n        AVG(UpVotes) AS UserAvgUpVotes,\n        AVG(DownVotes) AS UserAvgDownVotes\n    FROM Users\n)\nSELECT \n    p.TotalPosts,\n    p.TotalPostOwners,\n    p.AvgViewCount,\n    p.AvgScore,\n    u.UserCount,\n    u.AvgReputation,\n    u.UserAvgUpVotes,\n    u.UserAvgDownVotes\nFROM PostStats p\nCROSS JOIN UserStats u;", "sql2": "WITH VoteStats AS (\n    SELECT\n        COUNT(*) AS TotalVotes,\n        COUNT(DISTINCT PostId) AS TotalPostVotes,\n        AVG(CASE WHEN VoteTypeId = 2 THEN 1 ELSE 0 END) AS VoteAvgUpVotes,\n        AVG(CASE WHEN VoteTypeId = 3 THEN 1 ELSE 0 END) AS VoteAvgDownVotes\n    FROM Votes\n)\nSELECT \n    s1.*, \n    v.TotalVotes,\n    v.TotalPostVotes,\n    v.VoteAvgUpVotes,\n    v.VoteAvgDownVotes\nFROM s1\nCROSS JOIN VoteStats v;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "10129.sql", "original_sql": "WITH UserPostStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(DISTINCT P.Id) AS PostsCount,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionsCount,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswersCount,\n        COUNT(DISTINCT C.Id) AS CommentsCount,\n        COUNT(DISTINCT B.Id) AS BadgesCount,\n        SUM(V.BountyAmount) AS TotalBountyAmount\n    FROM Users U\n    LEFT JOIN Posts P ON U.Id = P.OwnerUserId\n    LEFT JOIN Comments C ON P.Id = C.PostId\n    LEFT JOIN Badges B ON U.Id = B.UserId\n    LEFT JOIN Votes V ON P.Id = V.PostId AND V.UserId = U.Id\n    GROUP BY U.Id, U.DisplayName\n)\nSELECT \n    UserId,\n    DisplayName,\n    PostsCount,\n    QuestionsCount,\n    AnswersCount,\n    CommentsCount,\n    BadgesCount,\n    TotalBountyAmount\nFROM UserPostStats\nORDER BY PostsCount DESC\nLIMIT 100;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH posts_agg AS (\n    SELECT OwnerUserId AS UserId,\n           COUNT(*) AS PostsCount,\n           SUM(CASE WHEN PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionsCount,\n           SUM(CASE WHEN PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswersCount\n    FROM Posts\n    WHERE OwnerUserId IS NOT NULL\n    GROUP BY OwnerUserId\n),\ncomments_agg AS (\n    SELECT P.OwnerUserId AS UserId,\n           COUNT(DISTINCT C.Id) AS CommentsCount\n    FROM Comments C\n    JOIN Posts P ON C.PostId = P.Id\n    GROUP BY P.OwnerUserId\n),\nbadges_agg AS (\n    SELECT UserId,\n           COUNT(*) AS BadgesCount\n    FROM Badges\n    GROUP BY UserId\n),\nvotes_agg AS (\n    SELECT P.OwnerUserId AS UserId,\n           COALESCE(SUM(V.BountyAmount), 0) AS TotalBountyAmount\n    FROM Votes V\n    JOIN Posts P ON V.PostId = P.Id\n    WHERE V.UserId = P.OwnerUserId\n    GROUP BY P.OwnerUserId\n)\nSELECT U.Id AS UserId,\n       U.DisplayName,\n       COALESCE(p.PostsCount, 0) AS PostsCount,\n       COALESCE(p.QuestionsCount, 0) AS QuestionsCount,\n       COALESCE(p.AnswersCount, 0) AS AnswersCount,\n       COALESCE(c.CommentsCount, 0) AS CommentsCount,\n       COALESCE(b.BadgesCount, 0) AS BadgesCount,\n       COALESCE(v.TotalBountyAmount, 0) AS TotalBountyAmount\nFROM Users U\nLEFT JOIN posts_agg p ON U.Id = p.UserId\nLEFT JOIN comments_agg c ON U.Id = c.UserId\nLEFT JOIN badges_agg b ON U.Id = b.UserId\nLEFT JOIN votes_agg v ON U.Id = v.UserId;", "sql2": "SELECT UserId,\n       DisplayName,\n       PostsCount,\n       QuestionsCount,\n       AnswersCount,\n       CommentsCount,\n       BadgesCount,\n       TotalBountyAmount\nFROM s1\nORDER BY PostsCount DESC\nLIMIT 100;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "10181.sql", "original_sql": "\nWITH PostDetails AS (\n    SELECT \n        P.Id AS PostId,\n        P.Title,\n        P.Body,\n        U.DisplayName AS OwnerDisplayName,\n        P.CreationDate AS PostCreationDate,\n        P.Score,\n        P.ViewCount,\n        COUNT(CASE WHEN C.PostId IS NOT NULL THEN 1 END) AS CommentCount,\n        COUNT(PH.Id) AS HistoryCount\n    FROM \n        Posts P\n    LEFT JOIN \n        Users U ON P.OwnerUserId = U.Id\n    LEFT JOIN \n        Comments C ON P.Id = C.PostId\n    LEFT JOIN \n        PostHistory PH ON P.Id = PH.PostId\n    GROUP BY \n        P.Id, P.Title, P.Body, U.DisplayName,\n        P.CreationDate, P.Score, P.ViewCount\n),\nPostStatistics AS (\n    SELECT \n        PD.PostId,\n        PD.Title,\n        PD.OwnerDisplayName,\n        PD.PostCreationDate,\n        PD.Score,\n        PD.ViewCount,\n        PD.CommentCount,\n        PD.HistoryCount,\n        COUNT(V.Id) AS VoteCount\n    FROM \n        PostDetails PD\n    LEFT JOIN \n        Votes V ON PD.PostId = V.PostId\n    GROUP BY \n        PD.PostId, PD.Title, PD.OwnerDisplayName,\n        PD.PostCreationDate, PD.Score, PD.ViewCount, \n        PD.CommentCount, PD.HistoryCount\n)\n\nSELECT \n    PS.PostId,\n    PS.Title,\n    PS.OwnerDisplayName,\n    PS.PostCreationDate,\n    PS.Score,\n    PS.ViewCount,\n    PS.CommentCount,\n    PS.HistoryCount,\n    PS.VoteCount\nFROM \n    PostStatistics PS\nORDER BY \n    PS.Score DESC, PS.ViewCount DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    P.Id AS PostId,\n    P.Title,\n    P.Body,\n    U.DisplayName AS OwnerDisplayName,\n    P.CreationDate AS PostCreationDate,\n    P.Score,\n    P.ViewCount,\n    COUNT(C.Id) AS CommentCount,\n    COUNT(PH.Id) AS HistoryCount\nFROM Posts P\nLEFT JOIN Users U ON P.OwnerUserId = U.Id\nLEFT JOIN Comments C ON P.Id = C.PostId\nLEFT JOIN PostHistory PH ON P.Id = PH.PostId\nGROUP BY\n    P.Id,\n    P.Title,\n    P.Body,\n    U.DisplayName,\n    P.CreationDate,\n    P.Score,\n    P.ViewCount", "sql2": "SELECT\n    s1.PostId,\n    s1.Title,\n    s1.OwnerDisplayName,\n    s1.PostCreationDate,\n    s1.Score,\n    s1.ViewCount,\n    s1.CommentCount,\n    s1.HistoryCount,\n    COUNT(V.Id) AS VoteCount\nFROM s1\nLEFT JOIN Votes V ON s1.PostId = V.PostId\nGROUP BY\n    s1.PostId,\n    s1.Title,\n    s1.OwnerDisplayName,\n    s1.PostCreationDate,\n    s1.Score,\n    s1.ViewCount,\n    s1.CommentCount,\n    s1.HistoryCount\nORDER BY\n    s1.Score DESC,\n    s1.ViewCount DESC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "10214.sql", "original_sql": "\nWITH PostMetrics AS (\n    SELECT \n        P.Id AS PostId,\n        P.Title,\n        U.DisplayName AS OwnerDisplayName,\n        P.CreationDate,\n        P.Score,\n        P.ViewCount,\n        COUNT(CASE WHEN C.Id IS NOT NULL THEN 1 END) AS CommentCount,\n        COUNT(A.Id) AS AnswerCount,\n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM \n        Posts P\n    LEFT JOIN \n        Users U ON P.OwnerUserId = U.Id\n    LEFT JOIN \n        Comments C ON P.Id = C.PostId\n    LEFT JOIN \n        Posts A ON P.Id = A.ParentId\n    LEFT JOIN \n        Votes V ON P.Id = V.PostId\n    WHERE \n        P.PostTypeId = 1 \n    GROUP BY \n        P.Id, P.Title, U.DisplayName, P.CreationDate, P.Score, P.ViewCount\n),\nPostHistoryMetrics AS (\n    SELECT \n        PH.PostId,\n        COUNT(PH.Id) AS EditCount,\n        COUNT(CASE WHEN PH.PostHistoryTypeId = 10 THEN 1 END) AS CloseCount,\n        COUNT(CASE WHEN PH.PostHistoryTypeId = 11 THEN 1 END) AS ReopenCount,\n        COUNT(CASE WHEN PH.PostHistoryTypeId = 12 THEN 1 END) AS DeleteCount\n    FROM \n        PostHistory PH\n    GROUP BY \n        PH.PostId\n)\n\nSELECT \n    PM.PostId,\n    PM.Title,\n    PM.OwnerDisplayName,\n    PM.CreationDate,\n    PM.Score,\n    PM.ViewCount,\n    PM.CommentCount,\n    PM.AnswerCount,\n    PM.UpVotes,\n    PM.DownVotes,\n    PHM.EditCount,\n    PHM.CloseCount,\n    PHM.ReopenCount,\n    PHM.DeleteCount\nFROM \n    PostMetrics PM\nLEFT JOIN \n    PostHistoryMetrics PHM ON PM.PostId = PHM.PostId\nORDER BY \n    PM.ViewCount DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    P.Id AS PostId,\n    P.Title,\n    U.DisplayName AS OwnerDisplayName,\n    P.CreationDate,\n    P.Score,\n    P.ViewCount,\n    COUNT(CASE WHEN C.Id IS NOT NULL THEN 1 END) AS CommentCount,\n    COUNT(A.Id) AS AnswerCount,\n    SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n    SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\nFROM Posts P\nLEFT JOIN Users U ON P.OwnerUserId = U.Id\nLEFT JOIN Comments C ON P.Id = C.PostId\nLEFT JOIN Posts A ON P.Id = A.ParentId\nLEFT JOIN Votes V ON P.Id = V.PostId\nWHERE P.PostTypeId = 1\nGROUP BY P.Id, P.Title, U.DisplayName, P.CreationDate, P.Score, P.ViewCount;", "sql2": "SELECT\n    s1.PostId,\n    s1.Title,\n    s1.OwnerDisplayName,\n    s1.CreationDate,\n    s1.Score,\n    s1.ViewCount,\n    s1.CommentCount,\n    s1.AnswerCount,\n    s1.UpVotes,\n    s1.DownVotes,\n    COALESCE(PHM.EditCount,0) AS EditCount,\n    COALESCE(PHM.CloseCount,0) AS CloseCount,\n    COALESCE(PHM.ReopenCount,0) AS ReopenCount,\n    COALESCE(PHM.DeleteCount,0) AS DeleteCount\nFROM s1\nLEFT JOIN (\n    SELECT\n        PH.PostId,\n        COUNT(*) AS EditCount,\n        SUM(CASE WHEN PH.PostHistoryTypeId = 10 THEN 1 ELSE 0 END) AS CloseCount,\n        SUM(CASE WHEN PH.PostHistoryTypeId = 11 THEN 1 ELSE 0 END) AS ReopenCount,\n        SUM(CASE WHEN PH.PostHistoryTypeId = 12 THEN 1 ELSE 0 END) AS DeleteCount\n    FROM PostHistory PH\n    GROUP BY PH.PostId\n) PHM ON s1.PostId = PHM.PostId\nORDER BY s1.ViewCount DESC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "10246.sql", "original_sql": "\nWITH PostStats AS (\n    SELECT \n        p.Id AS PostId,\n        p.PostTypeId,\n        COUNT(c.Id) AS CommentCount,\n        COUNT(v.Id) AS VoteCount,\n        MAX(p.CreationDate) AS LastActivityDate,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    GROUP BY \n        p.Id, p.PostTypeId\n),\nUserStats AS (\n    SELECT \n        u.Id AS UserId,\n        COUNT(b.Id) AS BadgeCount,\n        SUM(u.Reputation) AS TotalReputation,\n        COUNT(DISTINCT p.Id) AS PostCount\n    FROM \n        Users u\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    GROUP BY \n        u.Id\n)\nSELECT \n    ps.PostId,\n    ps.PostTypeId,\n    ps.CommentCount,\n    ps.VoteCount,\n    ps.LastActivityDate,\n    ps.UpVotes,\n    ps.DownVotes,\n    us.UserId,\n    us.BadgeCount,\n    us.TotalReputation,\n    us.PostCount\nFROM \n    PostStats ps\nJOIN \n    UserStats us ON ps.PostTypeId = us.UserId\nORDER BY \n    ps.VoteCount DESC, \n    ps.CommentCount DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT p.Id AS PostId,\n       p.PostTypeId,\n       COUNT(c.Id) AS CommentCount,\n       COUNT(v.Id) AS VoteCount,\n       MAX(p.CreationDate) AS LastActivityDate,\n       SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n       SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\nFROM Posts p\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Votes v ON p.Id = v.PostId\nGROUP BY p.Id, p.PostTypeId", "sql2": "SELECT ps.PostId,\n       ps.PostTypeId,\n       ps.CommentCount,\n       ps.VoteCount,\n       ps.LastActivityDate,\n       ps.UpVotes,\n       ps.DownVotes,\n       us.UserId,\n       us.BadgeCount,\n       us.TotalReputation,\n       us.PostCount\nFROM s1 ps\nJOIN (\n    SELECT u.Id AS UserId,\n           COUNT(b.Id) AS BadgeCount,\n           SUM(u.Reputation) AS TotalReputation,\n           COUNT(DISTINCT p.Id) AS PostCount\n    FROM Users u\n    LEFT JOIN Badges b ON u.Id = b.UserId\n    LEFT JOIN Posts p ON u.Id = p.OwnerUserId\n    GROUP BY u.Id\n) us ON ps.PostTypeId = us.UserId\nORDER BY ps.VoteCount DESC, ps.CommentCount DESC\nLIMIT 100", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "10258.sql", "original_sql": "WITH PostStats AS (\n    SELECT \n        p.Id AS PostId,\n        p.PostTypeId,\n        COUNT(DISTINCT c.Id) AS CommentCount,\n        COUNT(DISTINCT v.Id) AS VoteCount,\n        COUNT(DISTINCT b.Id) AS BadgeCount\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    LEFT JOIN \n        Badges b ON p.OwnerUserId = b.UserId\n    GROUP BY \n        p.Id, p.PostTypeId\n),\nUserStats AS (\n    SELECT \n        u.Id AS UserId,\n        COUNT(DISTINCT p.Id) AS PostCount,\n        SUM(u.UpVotes) AS TotalUpVotes,\n        SUM(u.DownVotes) AS TotalDownVotes\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    GROUP BY \n        u.Id\n)\nSELECT \n    ps.PostId,\n    ps.PostTypeId,\n    ps.CommentCount,\n    ps.VoteCount,\n    us.PostCount AS UserPostCount,\n    us.TotalUpVotes,\n    us.TotalDownVotes\nFROM \n    PostStats ps\nJOIN \n    Users u ON ps.PostTypeId = u.Id \nJOIN \n    UserStats us ON u.Id = us.UserId\nORDER BY \n    ps.VoteCount DESC, \n    ps.CommentCount DESC, \n    us.PostCount DESC\nLIMIT 100;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH PostStats AS (\n    SELECT \n        p.Id AS PostId,\n        p.PostTypeId,\n        COUNT(DISTINCT c.Id) AS CommentCount,\n        COUNT(DISTINCT v.Id) AS VoteCount,\n        COUNT(DISTINCT b.Id) AS BadgeCount\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    LEFT JOIN \n        Badges b ON p.OwnerUserId = b.UserId\n    GROUP BY \n        p.Id, p.PostTypeId\n)\nSELECT * FROM PostStats;", "sql2": "WITH UserStats AS (\n    SELECT \n        u.Id AS UserId,\n        COUNT(DISTINCT p.Id) AS PostCount,\n        SUM(u.UpVotes) AS TotalUpVotes,\n        SUM(u.DownVotes) AS TotalDownVotes\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    GROUP BY \n        u.Id\n)\nSELECT \n    s1.PostId,\n    s1.PostTypeId,\n    s1.CommentCount,\n    s1.VoteCount,\n    us.PostCount AS UserPostCount,\n    us.TotalUpVotes,\n    us.TotalDownVotes\nFROM \n    s1\nJOIN \n    Users u ON s1.PostTypeId = u.Id\nJOIN \n    UserStats us ON u.Id = us.UserId\nORDER BY \n    s1.VoteCount DESC,\n    s1.CommentCount DESC,\n    us.PostCount DESC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "10261.sql", "original_sql": "SELECT \n    PT.Name AS PostType,\n    COUNT(P.Id) AS TotalPosts,\n    SUM(CASE WHEN P.Score > 0 THEN 1 ELSE 0 END) AS PositiveScoredPosts,\n    SUM(P.ViewCount) AS TotalViews,\n    AVG(P.Score) AS AverageScore,\n    AVG(COALESCE(P.AnswerCount, 0)) AS AverageAnswerCount,\n    AVG(COALESCE(P.CommentCount, 0)) AS AverageCommentCount,\n    COUNT(DISTINCT P.OwnerUserId) AS UniquePostOwners,\n    AVG(UP.Reputation) AS AverageUserReputation\nFROM \n    Posts P\nJOIN \n    PostTypes PT ON P.PostTypeId = PT.Id\nJOIN \n    Users UP ON P.OwnerUserId = UP.Id\nGROUP BY \n    PT.Name\nORDER BY \n    TotalPosts DESC;", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "10276.sql", "original_sql": "\nWITH PostDetails AS (\n    SELECT \n        P.Id AS PostId,\n        P.Title,\n        P.CreationDate,\n        P.Score,\n        P.ViewCount,\n        U.DisplayName AS OwnerDisplayName,\n        COUNT(C.ID) AS CommentCount,\n        COUNT(DISTINCT B.Id) AS BadgeCount\n    FROM \n        Posts P\n    LEFT JOIN \n        Users U ON P.OwnerUserId = U.Id\n    LEFT JOIN \n        Comments C ON P.Id = C.PostId\n    LEFT JOIN \n        Badges B ON U.Id = B.UserId\n    GROUP BY \n        P.Id, P.Title, P.CreationDate, P.Score, P.ViewCount, U.DisplayName\n),\nVotingDetails AS (\n    SELECT \n        V.PostId,\n        COUNT(V.Id) AS VoteCount,\n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVoteCount,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVoteCount\n    FROM \n        Votes V\n    GROUP BY \n        V.PostId\n)\nSELECT \n    PD.PostId,\n    PD.Title,\n    PD.CreationDate,\n    PD.Score,\n    PD.ViewCount,\n    PD.OwnerDisplayName,\n    PD.CommentCount,\n    VD.VoteCount,\n    VD.UpVoteCount,\n    VD.DownVoteCount,\n    PD.BadgeCount\nFROM \n    PostDetails PD\nLEFT JOIN \n    VotingDetails VD ON PD.PostId = VD.PostId\nORDER BY \n    PD.Score DESC, PD.ViewCount DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    P.Id AS PostId,\n    P.Title,\n    P.CreationDate,\n    P.Score,\n    P.ViewCount,\n    U.DisplayName AS OwnerDisplayName,\n    COUNT(C.ID) AS CommentCount,\n    COUNT(DISTINCT B.Id) AS BadgeCount\nFROM Posts P\nLEFT JOIN Users U ON P.OwnerUserId = U.Id\nLEFT JOIN Comments C ON P.Id = C.PostId\nLEFT JOIN Badges B ON U.Id = B.UserId\nGROUP BY P.Id, P.Title, P.CreationDate, P.Score, P.ViewCount, U.DisplayName;", "sql2": "SELECT\n    s1.PostId,\n    s1.Title,\n    s1.CreationDate,\n    s1.Score,\n    s1.ViewCount,\n    s1.OwnerDisplayName,\n    s1.CommentCount,\n    vd.VoteCount,\n    vd.UpVoteCount,\n    vd.DownVoteCount,\n    s1.BadgeCount\nFROM s1\nLEFT JOIN (\n    SELECT\n        V.PostId,\n        COUNT(*) AS VoteCount,\n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVoteCount,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVoteCount\n    FROM Votes V\n    GROUP BY V.PostId\n) vd ON s1.PostId = vd.PostId\nORDER BY s1.Score DESC, s1.ViewCount DESC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "10304.sql", "original_sql": "SELECT \n    pt.Name AS PostType,\n    COUNT(p.Id) AS TotalPosts,\n    SUM(CASE WHEN p.Score IS NOT NULL THEN p.Score ELSE 0 END) AS TotalScore,\n    AVG(vote_score.VoteCount) AS AverageVotes,\n    AVG(c.CommentCount) AS AverageComments,\n    MAX(p.CreationDate) AS LatestPostDate,\n    MIN(p.CreationDate) AS EarliestPostDate\nFROM \n    Posts p\nJOIN \n    PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN \n    (SELECT PostId, COUNT(*) AS VoteCount \n     FROM Votes \n     GROUP BY PostId) AS vote_score ON p.Id = vote_score.PostId\nLEFT JOIN \n    (SELECT PostId, COUNT(*) AS CommentCount \n     FROM Comments \n     GROUP BY PostId) AS c ON p.Id = c.PostId\nGROUP BY \n    pt.Name\nORDER BY \n    TotalPosts DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH vote_agg AS (\n    SELECT PostId, COUNT(*) AS VoteCount\n    FROM Votes\n    GROUP BY PostId\n),\ncomment_agg AS (\n    SELECT PostId, COUNT(*) AS CommentCount\n    FROM Comments\n    GROUP BY PostId\n)\nSELECT \n    COALESCE(v.PostId, c.PostId) AS PostId,\n    COALESCE(v.VoteCount, 0) AS VoteCount,\n    COALESCE(c.CommentCount, 0) AS CommentCount\nFROM vote_agg v\nFULL OUTER JOIN comment_agg c\nON v.PostId = c.PostId;", "sql2": "SELECT \n    pt.Name AS PostType,\n    COUNT(p.Id) AS TotalPosts,\n    SUM(COALESCE(p.Score, 0)) AS TotalScore,\n    AVG(s1.VoteCount) AS AverageVotes,\n    AVG(s1.CommentCount) AS AverageComments,\n    MAX(p.CreationDate) AS LatestPostDate,\n    MIN(p.CreationDate) AS EarliestPostDate\nFROM Posts p\nJOIN PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN s1 ON p.Id = s1.PostId\nGROUP BY pt.Name\nORDER BY TotalPosts DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "10310.sql", "original_sql": "\nSELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.Score,\n    p.ViewCount,\n    u.DisplayName AS OwnerDisplayName,\n    u.Reputation AS OwnerReputation,\n    pt.Name AS PostType,\n    COUNT(c.Id) AS CommentCount,\n    COUNT(v.Id) AS VoteCount\nFROM \n    Posts p\nLEFT JOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nGROUP BY \n    p.Id, p.Title, p.CreationDate, p.Score, p.ViewCount, u.DisplayName, u.Reputation, pt.Name\nORDER BY \n    p.CreationDate DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH cc AS (\n    SELECT PostId, COUNT(*) AS CommentCount\n    FROM Comments\n    GROUP BY PostId\n),\nvc AS (\n    SELECT PostId, COUNT(*) AS VoteCount\n    FROM Votes\n    GROUP BY PostId\n)\nSELECT COALESCE(cc.PostId, vc.PostId) AS PostId,\n       COALESCE(cc.CommentCount, 0) AS CommentCount,\n       COALESCE(vc.VoteCount, 0) AS VoteCount\nFROM cc\nFULL OUTER JOIN vc USING (PostId);", "sql2": "SELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.Score,\n    p.ViewCount,\n    u.DisplayName AS OwnerDisplayName,\n    u.Reputation AS OwnerReputation,\n    pt.Name AS PostType,\n    COALESCE(s1.CommentCount, 0) AS CommentCount,\n    COALESCE(s1.VoteCount, 0) AS VoteCount\nFROM Posts p\nLEFT JOIN Users u ON p.OwnerUserId = u.Id\nLEFT JOIN PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN (\n    SELECT PostId, CommentCount, VoteCount\n    FROM s1\n) s1 ON p.Id = s1.PostId\nORDER BY p.CreationDate DESC\nLIMIT 100;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "10347.sql", "original_sql": "SELECT \n    pt.Name AS PostType,\n    COUNT(p.Id) AS PostCount,\n    AVG(p.Score) AS AverageScore,\n    SUM(c.CommentCount) AS TotalComments\nFROM \n    Posts p\nJOIN \n    PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN (\n    SELECT \n        PostId,\n        COUNT(*) AS CommentCount\n    FROM \n        Comments\n    GROUP BY \n        PostId\n) c ON p.Id = c.PostId\nGROUP BY \n    pt.Name\nORDER BY \n    PostCount DESC;", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT PostId, COUNT(*) AS CommentCount FROM Comments GROUP BY PostId", "sql2": "SELECT pt.Name AS PostType,\n       COUNT(p.Id) AS PostCount,\n       AVG(p.Score) AS AverageScore,\n       SUM(COALESCE(s1.CommentCount, 0)) AS TotalComments\nFROM Posts p\nJOIN PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN s1 ON p.Id = s1.PostId\nGROUP BY pt.Name\nORDER BY PostCount DESC", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "10350.sql", "original_sql": "\nSELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.Score,\n    p.ViewCount,\n    p.AnswerCount,\n    p.CommentCount,\n    p.FavoriteCount,\n    u.DisplayName AS OwnerDisplayName,\n    u.Reputation AS OwnerReputation,\n    ph.PostHistoryTypeId,\n    ph.CreationDate AS PostHistoryDate,\n    COUNT(c.Id) AS CommentCountTotal,\n    COUNT(v.Id) AS VoteCount\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    PostHistory ph ON p.Id = ph.PostId\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nWHERE \n    p.CreationDate >= DATE '2020-01-01' AND p.CreationDate < DATE '2023-01-01'  \nGROUP BY \n    p.Id, p.Title, p.CreationDate, p.Score, p.ViewCount, p.AnswerCount, p.CommentCount, p.FavoriteCount, \n    u.DisplayName, u.Reputation, ph.PostHistoryTypeId, ph.CreationDate\nORDER BY \n    p.CreationDate DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT COALESCE(c.PostId, v.PostId) AS PostId,\n       COALESCE(c.CommentCountTotal, 0) AS CommentCountTotal,\n       COALESCE(v.VoteCount, 0) AS VoteCount\nFROM   (SELECT PostId, COUNT(*) AS CommentCountTotal FROM Comments GROUP BY PostId) c\nFULL   OUTER JOIN (SELECT PostId, COUNT(*) AS VoteCount FROM Votes GROUP BY PostId) v\n       ON c.PostId = v.PostId;", "sql2": "SELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.Score,\n    p.ViewCount,\n    p.AnswerCount,\n    p.CommentCount,\n    p.FavoriteCount,\n    u.DisplayName AS OwnerDisplayName,\n    u.Reputation AS OwnerReputation,\n    ph.PostHistoryTypeId,\n    ph.CreationDate AS PostHistoryDate,\n    MAX(s1.CommentCountTotal) AS CommentCountTotal,\n    MAX(s1.VoteCount) AS VoteCount\nFROM   Posts p\nJOIN   Users u ON p.OwnerUserId = u.Id\nLEFT   JOIN PostHistory ph ON p.Id = ph.PostId\nLEFT   JOIN s1 ON p.Id = s1.PostId\nWHERE  p.CreationDate >= DATE '2020-01-01' AND p.CreationDate < DATE '2023-01-01'\nGROUP  BY p.Id, p.Title, p.CreationDate, p.Score, p.ViewCount, p.AnswerCount,\n          p.CommentCount, p.FavoriteCount, u.DisplayName, u.Reputation,\n          ph.PostHistoryTypeId, ph.CreationDate\nORDER  BY p.CreationDate DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "10360.sql", "original_sql": "\nWITH RankedPosts AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        COUNT(DISTINCT c.Id) AS CommentCount,\n        COUNT(DISTINCT v.Id) AS VoteCount,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVoteCount,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVoteCount\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    WHERE \n        p.CreationDate >= CURRENT_DATE - INTERVAL '1 year'  \n    GROUP BY \n        p.Id, p.Title, p.CreationDate\n),\nUserActivity AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(DISTINCT p.Id) AS PostsCount,\n        COUNT(DISTINCT b.Id) AS BadgesCount,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalDownVotes\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    WHERE \n        u.CreationDate >= CURRENT_DATE - INTERVAL '1 year'  \n    GROUP BY \n        u.Id, u.DisplayName\n)\nSELECT \n    rp.PostId, \n    rp.Title,\n    rp.CreationDate,\n    rp.CommentCount,\n    rp.VoteCount,\n    rp.UpVoteCount,\n    rp.DownVoteCount,\n    ua.UserId,\n    ua.DisplayName,\n    ua.PostsCount,\n    ua.BadgesCount,\n    ua.TotalUpVotes,\n    ua.TotalDownVotes\nFROM \n    RankedPosts rp\nJOIN \n    UserActivity ua ON rp.PostId = ua.UserId\nORDER BY \n    rp.CreationDate DESC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'postid' not found in 'rp'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"rp\" }), name: \"postid\" }, valid_fields: [Column { relation: Some(Bare { table: \"rp\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"ua\" }), name: \"userid\" }, Column { relation: Some(Bare { table: \"ua\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"ua\" }), name: \"postscount\" }, Column { relation: Some(Bare { table: \"ua\" }), name: \"badgescount\" }, Column { relation: Some(Bare { table: \"ua\" }), name: \"totalupvotes\" }, Column { relation: Some(Bare { table: \"ua\" }), name: \"totaldownvotes\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "10371.sql", "original_sql": "SELECT \n    u.Id AS UserId,\n    u.DisplayName AS UserName,\n    u.Reputation,\n    COUNT(p.Id) AS TotalPosts,\n    COUNT(CASE WHEN p.PostTypeId = 1 THEN 1 END) AS TotalQuestions,\n    COUNT(CASE WHEN p.PostTypeId = 2 THEN 1 END) AS TotalAnswers,\n    SUM(COALESCE(p.Score, 0)) AS TotalScore,\n    SUM(COALESCE(p.ViewCount, 0)) AS TotalViews,\n    AVG(COALESCE(p.Score, 0)) AS AverageScore,\n    AVG(COALESCE(p.ViewCount, 0)) AS AverageViews\nFROM \n    Users u\nLEFT JOIN \n    Posts p ON u.Id = p.OwnerUserId\nGROUP BY \n    u.Id, u.DisplayName, u.Reputation\nORDER BY \n    TotalPosts DESC\nLIMIT 100;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    u.Id AS UserId,\n    u.DisplayName AS UserName,\n    u.Reputation,\n    COUNT(p.Id) AS TotalPosts,\n    COUNT(CASE WHEN p.PostTypeId = 1 THEN 1 END) AS TotalQuestions,\n    COUNT(CASE WHEN p.PostTypeId = 2 THEN 1 END) AS TotalAnswers,\n    SUM(COALESCE(p.Score, 0)) AS TotalScore,\n    SUM(COALESCE(p.ViewCount, 0)) AS TotalViews,\n    AVG(COALESCE(p.Score, 0)) AS AverageScore,\n    AVG(COALESCE(p.ViewCount, 0)) AS AverageViews\nFROM Users u\nLEFT JOIN Posts p ON u.Id = p.OwnerUserId\nGROUP BY u.Id, u.DisplayName, u.Reputation;", "sql2": "SELECT *\nFROM s1\nORDER BY TotalPosts DESC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "10380.sql", "original_sql": "SELECT \n    pt.Name AS PostType,\n    COUNT(p.Id) AS TotalPosts,\n    SUM(COALESCE(p.ViewCount, 0)) AS TotalViews,\n    AVG(p.Score) AS AverageScore,\n    COUNT(DISTINCT p.OwnerUserId) AS UniqueUsers,\n    SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n    SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers,\n    SUM(CASE WHEN p.PostTypeId = 4 THEN 1 ELSE 0 END) AS TotalTagWikis,\n    SUM(CASE WHEN p.PostTypeId = 10 THEN 1 ELSE 0 END) AS TotalClosedPosts,\n    AVG(u.Reputation) AS AverageUserReputation\nFROM \n    Posts p\nJOIN \n    PostTypes pt ON p.PostTypeId = pt.Id\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nWHERE \n    p.CreationDate >= cast('2024-10-01 12:34:56' as timestamp) - INTERVAL '1 year'\nGROUP BY \n    pt.Name\nORDER BY \n    TotalPosts DESC;", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "10395.sql", "original_sql": "WITH UserPostStats AS (\n    SELECT \n        u.Id AS UserId,\n        COUNT(DISTINCT p.Id) AS PostCount,\n        COUNT(DISTINCT c.Id) AS CommentCount,\n        COUNT(DISTINCT v.Id) AS VoteCount\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    GROUP BY \n        u.Id\n)\n\nSELECT \n    u.Id AS UserId,\n    u.DisplayName,\n    ups.PostCount,\n    ups.CommentCount,\n    ups.VoteCount\nFROM \n    Users u\nLEFT JOIN \n    UserPostStats ups ON u.Id = ups.UserId\nORDER BY \n    ups.PostCount DESC, ups.CommentCount DESC, ups.VoteCount DESC;", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT u.Id AS UserId,\n       COUNT(DISTINCT p.Id) AS PostCount,\n       COUNT(DISTINCT c.Id) AS CommentCount,\n       COUNT(DISTINCT v.Id) AS VoteCount\nFROM   Users u\nLEFT JOIN Posts p    ON u.Id = p.OwnerUserId\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Votes v    ON p.Id = v.PostId\nGROUP BY u.Id", "sql2": "SELECT u.Id AS UserId,\n       u.DisplayName,\n       s1.PostCount,\n       s1.CommentCount,\n       s1.VoteCount\nFROM   Users u\nLEFT JOIN s1 ON u.Id = s1.UserId\nORDER BY s1.PostCount DESC,\n         s1.CommentCount DESC,\n         s1.VoteCount DESC", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "10406.sql", "original_sql": "WITH PostStatistics AS (\n    SELECT \n        P.Id AS PostId,\n        P.Title,\n        P.CreationDate,\n        P.ViewCount,\n        P.Score,\n        P.AnswerCount,\n        P.CommentCount,\n        U.DisplayName AS OwnerDisplayName,\n        U.Reputation AS OwnerReputation\n    FROM Posts P\n    JOIN Users U ON P.OwnerUserId = U.Id\n),\nUserActivity AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(P.Id) AS PostsCreated,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionsCreated,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswersCreated\n    FROM Users U\n    LEFT JOIN Posts P ON U.Id = P.OwnerUserId\n    GROUP BY U.Id, U.DisplayName\n),\nVotingSummary AS (\n    SELECT \n        V.UserId,\n        COUNT(V.Id) AS VotesCount,\n        SUM(CASE WHEN VT.Name = 'UpMod' THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN VT.Name = 'DownMod' THEN 1 ELSE 0 END) AS DownVotes\n    FROM Votes V\n    JOIN VoteTypes VT ON V.VoteTypeId = VT.Id\n    GROUP BY V.UserId\n)\n\nSELECT \n    PS.PostId,\n    PS.Title,\n    PS.CreationDate,\n    PS.ViewCount,\n    PS.Score,\n    PS.AnswerCount,\n    PS.CommentCount,\n    PS.OwnerDisplayName,\n    PS.OwnerReputation,\n    UA.PostsCreated,\n    UA.QuestionsCreated,\n    UA.AnswersCreated,\n    VS.VotesCount,\n    VS.UpVotes,\n    VS.DownVotes\nFROM PostStatistics PS\nLEFT JOIN UserActivity UA ON PS.OwnerDisplayName = UA.DisplayName\nLEFT JOIN VotingSummary VS ON UA.UserId = VS.UserId\nORDER BY PS.CreationDate DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    P.Id AS PostId,\n    P.Title,\n    P.CreationDate,\n    P.ViewCount,\n    P.Score,\n    P.AnswerCount,\n    P.CommentCount,\n    U.DisplayName AS OwnerDisplayName,\n    U.Reputation AS OwnerReputation,\n    U.Id AS OwnerUserId\nFROM Posts P\nJOIN Users U ON P.OwnerUserId = U.Id;", "sql2": "WITH UserActivity AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(P.Id) AS PostsCreated,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionsCreated,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswersCreated\n    FROM Users U\n    LEFT JOIN Posts P ON U.Id = P.OwnerUserId\n    GROUP BY U.Id, U.DisplayName\n),\nVotingSummary AS (\n    SELECT \n        V.UserId,\n        COUNT(V.Id) AS VotesCount,\n        SUM(CASE WHEN VT.Name = 'UpMod' THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN VT.Name = 'DownMod' THEN 1 ELSE 0 END) AS DownVotes\n    FROM Votes V\n    JOIN VoteTypes VT ON V.VoteTypeId = VT.Id\n    GROUP BY V.UserId\n)\nSELECT \n    s1.PostId,\n    s1.Title,\n    s1.CreationDate,\n    s1.ViewCount,\n    s1.Score,\n    s1.AnswerCount,\n    s1.CommentCount,\n    s1.OwnerDisplayName,\n    s1.OwnerReputation,\n    UA.PostsCreated,\n    UA.QuestionsCreated,\n    UA.AnswersCreated,\n    VS.VotesCount,\n    VS.UpVotes,\n    VS.DownVotes\nFROM s1\nLEFT JOIN UserActivity UA ON s1.OwnerDisplayName = UA.DisplayName\nLEFT JOIN VotingSummary VS ON UA.UserId = VS.UserId\nORDER BY s1.CreationDate DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "10433.sql", "original_sql": "SELECT \n    pt.Name AS PostType,\n    COUNT(p.Id) AS PostCount,\n    SUM(COALESCE(v.UpVotes, 0)) AS TotalUpVotes,\n    SUM(COALESCE(v.DownVotes, 0)) AS TotalDownVotes,\n    SUM(COALESCE(c.CommentCount, 0)) AS TotalComments,\n    SUM(COALESCE(p.ViewCount, 0)) AS TotalViews,\n    AVG(p.Score) AS AverageScore\nFROM \n    Posts p\nJOIN \n    PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN \n    (SELECT PostId, COUNT(*) AS CommentCount FROM Comments GROUP BY PostId) c ON p.Id = c.PostId\nLEFT JOIN \n    (SELECT PostId, SUM(CASE WHEN VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n            SUM(CASE WHEN VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes \n     FROM Votes GROUP BY PostId) v ON p.Id = v.PostId\nGROUP BY \n    pt.Name\nORDER BY \n    AverageScore DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH c AS (\n    SELECT PostId, COUNT(*) AS CommentCount\n    FROM Comments\n    GROUP BY PostId\n),\nv AS (\n    SELECT PostId,\n        SUM(CASE WHEN VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM Votes\n    GROUP BY PostId\n)\nSELECT\n    COALESCE(c.PostId, v.PostId) AS PostId,\n    COALESCE(CommentCount, 0) AS CommentCount,\n    COALESCE(UpVotes, 0) AS UpVotes,\n    COALESCE(DownVotes, 0) AS DownVotes\nFROM c\nFULL OUTER JOIN v USING (PostId);", "sql2": "SELECT\n    pt.Name AS PostType,\n    COUNT(p.Id) AS PostCount,\n    SUM(COALESCE(s1.UpVotes, 0)) AS TotalUpVotes,\n    SUM(COALESCE(s1.DownVotes, 0)) AS TotalDownVotes,\n    SUM(COALESCE(s1.CommentCount, 0)) AS TotalComments,\n    SUM(COALESCE(p.ViewCount, 0)) AS TotalViews,\n    AVG(p.Score) AS AverageScore\nFROM Posts p\nJOIN PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN s1 ON p.Id = s1.PostId\nGROUP BY pt.Name\nORDER BY AverageScore DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "10467.sql", "original_sql": "WITH PostDetails AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        p.Score,\n        p.ViewCount,\n        p.OwnerUserId,\n        p.AnswerCount,\n        p.CommentCount,\n        p.FavoriteCount,\n        p.LastActivityDate,\n        u.Reputation AS OwnerReputation,\n        u.DisplayName AS OwnerDisplayName\n    FROM \n        Posts p\n    JOIN \n        Users u ON p.OwnerUserId = u.Id\n    WHERE \n        p.CreationDate >= '2023-01-01'\n),\nVoteStats AS (\n    SELECT \n        v.PostId,\n        COUNT(CASE WHEN v.VoteTypeId = 2 THEN 1 END) AS UpVoteCount,\n        COUNT(CASE WHEN v.VoteTypeId = 3 THEN 1 END) AS DownVoteCount\n    FROM \n        Votes v\n    GROUP BY \n        v.PostId\n),\nCommentCounts AS (\n    SELECT \n        c.PostId,\n        COUNT(c.Id) AS TotalComments\n    FROM \n        Comments c\n    GROUP BY \n        c.PostId\n)\nSELECT \n    pd.PostId,\n    pd.Title,\n    pd.CreationDate,\n    pd.Score,\n    pd.ViewCount,\n    pd.OwnerReputation,\n    pd.OwnerDisplayName,\n    COALESCE(vs.UpVoteCount, 0) AS UpVoteCount,\n    COALESCE(vs.DownVoteCount, 0) AS DownVoteCount,\n    COALESCE(cc.TotalComments, 0) AS TotalComments,\n    pd.AnswerCount,\n    pd.CommentCount,\n    pd.FavoriteCount,\n    pd.LastActivityDate\nFROM \n    PostDetails pd\nLEFT JOIN \n    VoteStats vs ON pd.PostId = vs.PostId\nLEFT JOIN \n    CommentCounts cc ON pd.PostId = cc.PostId\nORDER BY \n    pd.CreationDate DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT v.PostId,\n       v.UpVoteCount,\n       v.DownVoteCount,\n       COALESCE(cc.TotalComments, 0) AS TotalComments\nFROM (\n    SELECT PostId,\n           COUNT(CASE WHEN VoteTypeId = 2 THEN 1 END) AS UpVoteCount,\n           COUNT(CASE WHEN VoteTypeId = 3 THEN 1 END) AS DownVoteCount\n    FROM Votes\n    GROUP BY PostId\n) v\nLEFT JOIN (\n    SELECT PostId, COUNT(*) AS TotalComments\n    FROM Comments\n    GROUP BY PostId\n) cc ON v.PostId = cc.PostId;", "sql2": "SELECT \n    pd.Id AS PostId,\n    pd.Title,\n    pd.CreationDate,\n    pd.Score,\n    pd.ViewCount,\n    u.Reputation AS OwnerReputation,\n    u.DisplayName AS OwnerDisplayName,\n    COALESCE(s1.UpVoteCount, 0) AS UpVoteCount,\n    COALESCE(s1.DownVoteCount, 0) AS DownVoteCount,\n    COALESCE(s1.TotalComments, 0) AS TotalComments,\n    pd.AnswerCount,\n    pd.CommentCount,\n    pd.FavoriteCount,\n    pd.LastActivityDate\nFROM Posts pd\nJOIN Users u ON pd.OwnerUserId = u.Id\nLEFT JOIN s1 ON pd.Id = s1.PostId\nWHERE pd.CreationDate >= '2023-01-01'\nORDER BY pd.CreationDate DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "10491.sql", "original_sql": "WITH PostStats AS (\n    SELECT \n        p.Id AS PostId,\n        pt.Name AS PostType,\n        COUNT(c.Id) AS CommentCount,\n        COUNT(DISTINCT v.UserId) AS VoteCount,\n        AVG(u.Reputation) AS AvgUserReputation\n    FROM \n        Posts p\n    LEFT JOIN \n        PostTypes pt ON p.PostTypeId = pt.Id\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    LEFT JOIN \n        Users u ON v.UserId = u.Id\n    GROUP BY \n        p.Id, pt.Name\n),\nPostHistoryStats AS (\n    SELECT \n        ph.PostId,\n        COUNT(*) AS HistoryCount,\n        COUNT(CASE WHEN ph.PostHistoryTypeId = 10 THEN 1 END) AS CloseCount,\n        COUNT(CASE WHEN ph.PostHistoryTypeId = 11 THEN 1 END) AS ReopenCount\n    FROM \n        PostHistory ph\n    GROUP BY \n        ph.PostId\n)\nSELECT \n    ps.PostId,\n    ps.PostType,\n    ps.CommentCount,\n    ps.VoteCount,\n    ps.AvgUserReputation,\n    phs.HistoryCount,\n    phs.CloseCount,\n    phs.ReopenCount\nFROM \n    PostStats ps\nLEFT JOIN \n    PostHistoryStats phs ON ps.PostId = phs.PostId\nORDER BY \n    ps.VoteCount DESC, ps.CommentCount DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    p.Id AS PostId,\n    pt.Name AS PostType,\n    COUNT(c.Id) AS CommentCount,\n    COUNT(DISTINCT v.UserId) AS VoteCount,\n    AVG(u.Reputation) AS AvgUserReputation\nFROM Posts p\nLEFT JOIN PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Votes v ON p.Id = v.PostId\nLEFT JOIN Users u ON v.UserId = u.Id\nGROUP BY p.Id, pt.Name;", "sql2": "SELECT \n    s1.PostId,\n    s1.PostType,\n    s1.CommentCount,\n    s1.VoteCount,\n    s1.AvgUserReputation,\n    phs.HistoryCount,\n    phs.CloseCount,\n    phs.ReopenCount\nFROM s1\nLEFT JOIN (\n    SELECT \n        ph.PostId,\n        COUNT(*) AS HistoryCount,\n        SUM(CASE WHEN ph.PostHistoryTypeId = 10 THEN 1 ELSE 0 END) AS CloseCount,\n        SUM(CASE WHEN ph.PostHistoryTypeId = 11 THEN 1 ELSE 0 END) AS ReopenCount\n    FROM PostHistory ph\n    GROUP BY ph.PostId\n) phs ON s1.PostId = phs.PostId\nORDER BY s1.VoteCount DESC, s1.CommentCount DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "10563.sql", "original_sql": "SELECT \n    P.Id AS PostId,\n    P.Title,\n    P.CreationDate,\n    U.DisplayName AS OwnerDisplayName,\n    COALESCE(V.UpVotes, 0) AS UpVotes,\n    COALESCE(V.DownVotes, 0) AS DownVotes,\n    COALESCE(V.VoteCount, 0) AS VoteCount\nFROM \n    Posts P\nLEFT JOIN \n    Users U ON P.OwnerUserId = U.Id\nLEFT JOIN (\n    SELECT \n        PostId, \n        SUM(CASE WHEN VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n        COUNT(Id) AS VoteCount\n    FROM \n        Votes\n    GROUP BY \n        PostId\n) V ON P.Id = V.PostId\nORDER BY \n    P.CreationDate DESC\nLIMIT 100;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT Id AS PostId, Title, CreationDate, OwnerUserId FROM Posts ORDER BY CreationDate DESC LIMIT 100", "sql2": "SELECT s1.PostId,\n       s1.Title,\n       s1.CreationDate,\n       u.DisplayName AS OwnerDisplayName,\n       COALESCE(v.UpVotes, 0) AS UpVotes,\n       COALESCE(v.DownVotes, 0) AS DownVotes,\n       COALESCE(v.VoteCount, 0) AS VoteCount\nFROM s1\nLEFT JOIN Users u ON s1.OwnerUserId = u.Id\nLEFT JOIN (\n    SELECT PostId,\n           SUM(CASE WHEN VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n           SUM(CASE WHEN VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n           COUNT(*) AS VoteCount\n    FROM Votes\n    GROUP BY PostId\n) v ON s1.PostId = v.PostId\nORDER BY s1.CreationDate DESC", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "10584.sql", "original_sql": "WITH PostMetrics AS (\n    SELECT \n        PT.Name AS PostType,\n        COUNT(P.Id) AS PostCount,\n        AVG(P.ViewCount) AS AvgViews,\n        AVG(P.Score) AS AvgScore\n    FROM \n        Posts P\n    JOIN \n        PostTypes PT ON P.PostTypeId = PT.Id\n    GROUP BY \n        PT.Name\n),\nTopUsers AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        U.Reputation,\n        COUNT(P.Id) AS TotalPosts\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    GROUP BY \n        U.Id, U.DisplayName, U.Reputation\n    ORDER BY \n        U.Reputation DESC\n    LIMIT 5\n)\n\nSELECT \n    PM.PostType,\n    PM.PostCount,\n    PM.AvgViews,\n    PM.AvgScore,\n    TU.DisplayName AS TopUser,\n    TU.Reputation,\n    TU.TotalPosts\nFROM \n    PostMetrics PM\nCROSS JOIN \n    TopUsers TU\nORDER BY \n    PM.PostCount DESC;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Collection([Diagnostic(Diagnostic { kind: Error, message: \"column 'posttype' not found in 'pm'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"pm\" }), name: \"posttype\" }, valid_fields: [Column { relation: Some(Bare { table: \"pm\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"userid\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"reputation\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"totalposts\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'postcount' not found in 'pm'\", span: None, notes: [DiagnosticNote { message: \"possible column pm.count\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"pm\" }), name: \"postcount\" }, valid_fields: [Column { relation: Some(Bare { table: \"pm\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"userid\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"reputation\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"totalposts\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'avgviews' not found in 'pm'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"pm\" }), name: \"avgviews\" }, valid_fields: [Column { relation: Some(Bare { table: \"pm\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"userid\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"reputation\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"totalposts\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'avgscore' not found in 'pm'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"pm\" }), name: \"avgscore\" }, valid_fields: [Column { relation: Some(Bare { table: \"pm\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"userid\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"reputation\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"totalposts\" }] }, Some(\"\")))])\n", "engine_mem_mb": 500000}
{"query_id": "10604.sql", "original_sql": "SELECT \n    PT.Name AS PostType,\n    COUNT(P.Id) AS TotalPosts,\n    SUM(CASE WHEN P.ViewCount IS NOT NULL THEN P.ViewCount ELSE 0 END) AS TotalViews,\n    SUM(CASE WHEN P.Score IS NOT NULL THEN P.Score ELSE 0 END) AS TotalScore,\n    AVG(P.AnswerCount) AS AverageAnswers,\n    AVG(P.CommentCount) AS AverageComments,\n    AVG(P.FavoriteCount) AS AverageFavorites,\n    U.Reputation AS UserReputation,\n    COUNT(DISTINCT U.Id) AS ActiveUsers\nFROM \n    Posts P\nJOIN \n    PostTypes PT ON P.PostTypeId = PT.Id\nJOIN \n    Users U ON P.OwnerUserId = U.Id\nWHERE \n    P.CreationDate >= cast('2024-10-01 12:34:56' as timestamp) - INTERVAL '1 year'  \nGROUP BY \n    PT.Name, U.Reputation\nORDER BY \n    TotalPosts DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT P.OwnerUserId AS OwnerUserId,\n       P.PostTypeId AS PostTypeId,\n       COUNT(*) AS PostCnt,\n       SUM(COALESCE(P.ViewCount,0)) AS ViewSum,\n       SUM(COALESCE(P.Score,0)) AS ScoreSum,\n       SUM(COALESCE(P.AnswerCount,0)) AS AnswerSum,\n       SUM(COALESCE(P.CommentCount,0)) AS CommentSum,\n       SUM(COALESCE(P.FavoriteCount,0)) AS FavoriteSum\nFROM Posts P\nWHERE P.CreationDate >= CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '1 year'\nGROUP BY P.OwnerUserId, P.PostTypeId;", "sql2": "SELECT PT.Name AS PostType,\n       SUM(s1.PostCnt) AS TotalPosts,\n       SUM(s1.ViewSum) AS TotalViews,\n       SUM(s1.ScoreSum) AS TotalScore,\n       SUM(s1.AnswerSum)::DOUBLE / NULLIF(SUM(s1.PostCnt),0) AS AverageAnswers,\n       SUM(s1.CommentSum)::DOUBLE / NULLIF(SUM(s1.PostCnt),0) AS AverageComments,\n       SUM(s1.FavoriteSum)::DOUBLE / NULLIF(SUM(s1.PostCnt),0) AS AverageFavorites,\n       U.Reputation AS UserReputation,\n       COUNT(DISTINCT U.Id) AS ActiveUsers\nFROM s1\nJOIN PostTypes PT ON s1.PostTypeId = PT.Id\nJOIN Users U ON s1.OwnerUserId = U.Id\nGROUP BY PT.Name, U.Reputation\nORDER BY TotalPosts DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "10665.sql", "original_sql": "\nWITH UserStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        U.Reputation,\n        COUNT(DISTINCT P.Id) AS PostCount,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        SUM(CASE WHEN C.Id IS NOT NULL THEN 1 ELSE 0 END) AS CommentCount\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    LEFT JOIN \n        Comments C ON P.Id = C.PostId\n    WHERE \n        U.Reputation > 0 \n    GROUP BY \n        U.Id, U.DisplayName, U.Reputation\n),\nPostDetails AS (\n    SELECT \n        P.Id AS PostId,\n        P.Title,\n        P.CreationDate,\n        P.Score,\n        P.ViewCount,\n        PT.Name AS PostType,\n        PH.CreationDate AS HistoryDate,\n        P.OwnerUserId\n    FROM \n        Posts P\n    JOIN \n        PostTypes PT ON P.PostTypeId = PT.Id\n    LEFT JOIN \n        PostHistory PH ON P.Id = PH.PostId\n)\nSELECT \n    US.UserId,\n    US.DisplayName,\n    US.Reputation,\n    US.PostCount,\n    US.QuestionCount,\n    US.AnswerCount,\n    US.CommentCount,\n    PD.PostId,\n    PD.Title AS PostTitle,\n    PD.CreationDate AS PostCreationDate,\n    PD.Score AS PostScore,\n    PD.ViewCount AS PostViewCount,\n    PD.PostType,\n    COUNT(PD.HistoryDate) AS HistoryCount\nFROM \n    UserStats US\nLEFT JOIN \n    PostDetails PD ON US.UserId = PD.OwnerUserId\nGROUP BY \n    US.UserId, US.DisplayName, US.Reputation, US.PostCount, \n    US.QuestionCount, US.AnswerCount, US.CommentCount, \n    PD.PostId, PD.Title, PD.CreationDate, PD.Score, \n    PD.ViewCount, PD.PostType\nORDER BY \n    US.Reputation DESC, US.PostCount DESC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "WITH PostDetailsAgg AS (\n    SELECT \n        P.Id AS PostId,\n        P.Title,\n        P.CreationDate,\n        P.Score,\n        P.ViewCount,\n        PT.Name AS PostType,\n        P.OwnerUserId,\n        COUNT(PH.Id) AS HistoryCount\n    FROM Posts P\n    JOIN PostTypes PT ON P.PostTypeId = PT.Id\n    LEFT JOIN PostHistory PH ON P.Id = PH.PostId\n    GROUP BY P.Id, P.Title, P.CreationDate, P.Score, P.ViewCount, PT.Name, P.OwnerUserId\n)\nSELECT * FROM PostDetailsAgg;", "sql2": "WITH UserStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        U.Reputation,\n        COUNT(DISTINCT P.Id) AS PostCount,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        SUM(CASE WHEN C.Id IS NOT NULL THEN 1 ELSE 0 END) AS CommentCount\n    FROM Users U\n    LEFT JOIN Posts P ON U.Id = P.OwnerUserId\n    LEFT JOIN Comments C ON P.Id = C.PostId\n    WHERE U.Reputation > 0\n    GROUP BY U.Id, U.DisplayName, U.Reputation\n)\nSELECT \n    US.UserId,\n    US.DisplayName,\n    US.Reputation,\n    US.PostCount,\n    US.QuestionCount,\n    US.AnswerCount,\n    US.CommentCount,\n    s1.PostId,\n    s1.Title AS PostTitle,\n    s1.CreationDate AS PostCreationDate,\n    s1.Score AS PostScore,\n    s1.ViewCount AS PostViewCount,\n    s1.PostType,\n    s1.HistoryCount\nFROM UserStats US\nLEFT JOIN s1 ON US.UserId = s1.OwnerUserId\nORDER BY US.Reputation DESC, US.PostCount DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "10667.sql", "original_sql": "WITH PostStats AS (\n    SELECT \n        pt.Name AS PostType,\n        COUNT(p.Id) AS TotalPosts,\n        AVG(p.Score) AS AverageScore,\n        COUNT(DISTINCT p.OwnerUserId) AS UniqueUsers,\n        SUM(p.ViewCount) AS TotalViews,\n        SUM(p.CommentCount) AS TotalComments,\n        SUM(p.AnswerCount) AS TotalAnswers\n    FROM \n        Posts p\n    JOIN \n        PostTypes pt ON p.PostTypeId = pt.Id\n    GROUP BY \n        pt.Name\n),\nUserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(p.Id) AS PostsCreated,\n        SUM(v.BountyAmount) AS TotalBountyReceived\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN \n        Votes v ON u.Id = v.UserId\n    GROUP BY \n        u.Id, u.DisplayName\n)\n\nSELECT \n    ps.PostType,\n    ps.TotalPosts,\n    ps.AverageScore,\n    ps.UniqueUsers,\n    ps.TotalViews,\n    ps.TotalComments,\n    ps.TotalAnswers,\n    us.UserId,\n    us.DisplayName,\n    us.PostsCreated,\n    us.TotalBountyReceived\nFROM \n    PostStats ps\nJOIN \n    UserStats us ON ps.UniqueUsers = us.PostsCreated\nORDER BY \n    TotalPosts DESC;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'uniqueusers' not found in 's1'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"uniqueusers\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"userid\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"postscreated\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"totalbountyreceived\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "10685.sql", "original_sql": "\nSELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    u.DisplayName AS OwnerDisplayName,\n    pt.Name AS PostType,\n    COUNT(c.Id) AS CommentCount,\n    COUNT(v.Id) AS VoteCount\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nJOIN \n    PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nGROUP BY \n    p.Id, p.Title, p.CreationDate, u.DisplayName, pt.Name\nORDER BY \n    p.CreationDate DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT p.Id AS PostId,\n       COUNT(DISTINCT c.Id) AS CommentCount,\n       COUNT(DISTINCT v.Id) AS VoteCount\nFROM Posts p\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Votes v ON p.Id = v.PostId\nGROUP BY p.Id;", "sql2": "SELECT p.Id AS PostId,\n       p.Title,\n       p.CreationDate,\n       u.DisplayName AS OwnerDisplayName,\n       pt.Name AS PostType,\n       COALESCE(s1.CommentCount,0) AS CommentCount,\n       COALESCE(s1.VoteCount,0) AS VoteCount\nFROM Posts p\nJOIN Users u ON p.OwnerUserId = u.Id\nJOIN PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN s1 ON p.Id = s1.PostId\nORDER BY p.CreationDate DESC\nLIMIT 100;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "10707.sql", "original_sql": "\nWITH PostStats AS (\n    SELECT\n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        p.Score,\n        p.ViewCount,\n        p.AnswerCount,\n        COUNT(c.Id) AS CommentCount,\n        COUNT(v.Id) AS VoteCount,\n        u.Id AS OwnerUserId,\n        u.Reputation AS OwnerReputation,\n        u.CreationDate AS UserCreationDate,\n        u.DisplayName AS OwnerDisplayName\n    FROM\n        Posts p\n    LEFT JOIN\n        Comments c ON p.Id = c.PostId\n    LEFT JOIN\n        Votes v ON p.Id = v.PostId\n    LEFT JOIN\n        Users u ON p.OwnerUserId = u.Id\n    GROUP BY\n        p.Id, p.Title, p.CreationDate, p.Score, p.ViewCount, p.AnswerCount, u.Id, u.Reputation, u.CreationDate, u.DisplayName\n),\nUserStats AS (\n    SELECT\n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(b.Id) AS BadgeCount,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n        SUM(v.BountyAmount) AS TotalBounty\n    FROM\n        Users u\n    LEFT JOIN\n        Badges b ON u.Id = b.UserId\n    LEFT JOIN\n        Votes v ON u.Id = v.UserId\n    GROUP BY\n        u.Id, u.DisplayName\n)\nSELECT\n    ps.PostId,\n    ps.Title,\n    ps.CreationDate,\n    ps.Score,\n    ps.ViewCount,\n    ps.AnswerCount,\n    ps.CommentCount,\n    ps.VoteCount,\n    ps.OwnerUserId,\n    ps.OwnerReputation,\n    ps.UserCreationDate,\n    ps.OwnerDisplayName,\n    us.UserId,\n    us.DisplayName AS UserDisplayName,\n    us.BadgeCount,\n    us.UpVotes,\n    us.DownVotes,\n    us.TotalBounty\nFROM\n    PostStats ps\nJOIN\n    UserStats us ON ps.OwnerUserId = us.UserId\nORDER BY\n    ps.CreationDate DESC\nLIMIT 100;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 178, in _run_single_node\n    out_tbl = self._run_on_duckdb(node.sql)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 104, in _run_on_duckdb\n    return self.con.execute(sql).arrow()\n           ^^^^^^^^^^^^^^^^^^^^^\nduckdb.duckdb.ParserException: Parser Error: syntax error at or near \"ON\"\n", "engine_mem_mb": 500000}
{"query_id": "10786.sql", "original_sql": "SELECT \n    P.Id AS PostId,\n    P.Title,\n    U.DisplayName AS OwnerDisplayName,\n    P.CreationDate,\n    P.ViewCount,\n    P.Score,\n    COUNT(CASE WHEN C.PostId = P.Id THEN 1 END) AS CommentCount,\n    COUNT(CASE WHEN V.PostId = P.Id THEN 1 END) AS VoteCount,\n    T.TagName,\n    PT.Name AS PostType,\n    BH.UserDisplayName AS LastEditedBy,\n    BH.CreationDate AS LastEditedDate\nFROM \n    Posts P\nJOIN \n    Users U ON P.OwnerUserId = U.Id\nLEFT JOIN \n    Comments C ON P.Id = C.PostId\nLEFT JOIN \n    Votes V ON P.Id = V.PostId\nLEFT JOIN \n    Tags T ON T.ExcerptPostId = P.Id\nLEFT JOIN \n    PostTypes PT ON P.PostTypeId = PT.Id\nLEFT JOIN \n    PostHistory BH ON P.Id = BH.PostId \nWHERE \n    P.CreationDate >= cast('2024-10-01 12:34:56' as timestamp) - INTERVAL '1 year' \nGROUP BY \n    P.Id, U.DisplayName, P.Title, P.CreationDate, P.ViewCount, P.Score, T.TagName, PT.Name, BH.UserDisplayName, BH.CreationDate\nORDER BY \n    P.CreationDate DESC;", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "10799.sql", "original_sql": "SELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.ViewCount,\n    p.Score,\n    COALESCE(uv.UpVoteCount, 0) AS UpVoteCount,\n    COALESCE(dv.DownVoteCount, 0) AS DownVoteCount,\n    COALESCE(c.CommentCount, 0) AS CommentCount,\n    COALESCE(b.BadgeCount, 0) AS BadgeCount,\n    COALESCE(u.Reputation, 0) AS UserReputation\nFROM \n    Posts p\nLEFT JOIN \n    (SELECT PostId, COUNT(*) AS UpVoteCount \n     FROM Votes \n     WHERE VoteTypeId = 2 \n     GROUP BY PostId) uv ON p.Id = uv.PostId\nLEFT JOIN \n    (SELECT PostId, COUNT(*) AS DownVoteCount \n     FROM Votes \n     WHERE VoteTypeId = 3 \n     GROUP BY PostId) dv ON p.Id = dv.PostId\nLEFT JOIN \n    (SELECT PostId, COUNT(*) AS CommentCount \n     FROM Comments \n     GROUP BY PostId) c ON p.Id = c.PostId\nLEFT JOIN \n    (SELECT UserId, COUNT(*) AS BadgeCount \n     FROM Badges \n     GROUP BY UserId) b ON p.OwnerUserId = b.UserId\nLEFT JOIN \n    Users u ON p.OwnerUserId = u.Id\nWHERE \n    p.CreationDate >= cast('2024-10-01 12:34:56' as timestamp) - INTERVAL '1 year'\nORDER BY \n    p.CreationDate DESC\nLIMIT 100;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: SchemaError(FieldNotFound { field: Column { relation: None, name: \"creationdate\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))\n", "engine_mem_mb": 500000}
{"query_id": "10819.sql", "original_sql": "\nSELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.Score,\n    p.ViewCount,\n    u.DisplayName AS OwnerDisplayName,\n    u.Reputation,\n    COUNT(c.Id) AS CommentCount,\n    COUNT(v.Id) AS VoteCount,\n    t.TagName,\n    ph.PostHistoryTypeId,\n    ph.CreationDate AS HistoryCreationDate\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nLEFT JOIN \n    Tags t ON t.ExcerptPostId = p.Id\nLEFT JOIN \n    PostHistory ph ON p.Id = ph.PostId\nWHERE \n    p.CreationDate >= DATE '2023-01-01' AND p.CreationDate < DATE '2024-01-01'\nGROUP BY \n    p.Id, p.Title, p.CreationDate, p.Score, p.ViewCount, \n    u.DisplayName, u.Reputation, \n    t.TagName, \n    ph.PostHistoryTypeId, ph.CreationDate\nORDER BY \n    p.Score DESC, p.ViewCount DESC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.Score,\n    p.ViewCount,\n    u.DisplayName AS OwnerDisplayName,\n    u.Reputation,\n    t.TagName,\n    ph.PostHistoryTypeId,\n    ph.CreationDate AS HistoryCreationDate\nFROM Posts p\nJOIN Users u ON p.OwnerUserId = u.Id\nLEFT JOIN Tags t ON t.ExcerptPostId = p.Id\nLEFT JOIN PostHistory ph ON p.Id = ph.PostId\nWHERE p.CreationDate >= DATE '2023-01-01' AND p.CreationDate < DATE '2024-01-01';", "sql2": "SELECT \n    s1.PostId,\n    s1.Title,\n    s1.CreationDate,\n    s1.Score,\n    s1.ViewCount,\n    s1.OwnerDisplayName,\n    s1.Reputation,\n    COALESCE(cc.CommentCount,0) AS CommentCount,\n    COALESCE(vc.VoteCount,0) AS VoteCount,\n    s1.TagName,\n    s1.PostHistoryTypeId,\n    s1.HistoryCreationDate\nFROM s1\nLEFT JOIN (\n    SELECT p.Id AS PostId, COUNT(c.Id) AS CommentCount\n    FROM Posts p\n    LEFT JOIN Comments c ON p.Id = c.PostId\n    WHERE p.CreationDate >= DATE '2023-01-01' AND p.CreationDate < DATE '2024-01-01'\n    GROUP BY p.Id\n) cc ON s1.PostId = cc.PostId\nLEFT JOIN (\n    SELECT p.Id AS PostId, COUNT(v.Id) AS VoteCount\n    FROM Posts p\n    LEFT JOIN Votes v ON p.Id = v.PostId\n    WHERE p.CreationDate >= DATE '2023-01-01' AND p.CreationDate < DATE '2024-01-01'\n    GROUP BY p.Id\n) vc ON s1.PostId = vc.PostId\nORDER BY s1.Score DESC, s1.ViewCount DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "10823.sql", "original_sql": "\nSELECT \n    u.DisplayName AS UserName,\n    COUNT(DISTINCT p.Id) AS TotalPosts,\n    SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n    SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers,\n    AVG(p.Score) AS AverageScore,\n    SUM(p.ViewCount) AS TotalViews,\n    MAX(p.CreationDate) AS LastPostDate\nFROM \n    Users u\nLEFT JOIN \n    Posts p ON u.Id = p.OwnerUserId\nGROUP BY \n    u.DisplayName, u.Id\nORDER BY \n    TotalPosts DESC\nLIMIT 10;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 's1'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"u\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"reputation\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"creationdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"lastaccessdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"websiteurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"location\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"aboutme\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"views\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"upvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"downvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"profileimageurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"accountid\" }, Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "10924.sql", "original_sql": "WITH UserPostStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(p.Id) AS TotalPosts,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers,\n        SUM(CASE WHEN p.PostTypeId IN (3, 4, 5) THEN 1 ELSE 0 END) AS TotalWikis\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    GROUP BY \n        u.Id, u.DisplayName\n),\nUserBadgeStats AS (\n    SELECT \n        b.UserId,\n        COUNT(b.Id) AS TotalBadges,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Badges b\n    GROUP BY \n        b.UserId\n)\nSELECT \n    ups.UserId,\n    ups.DisplayName,\n    ups.TotalPosts,\n    ups.TotalQuestions,\n    ups.TotalAnswers,\n    ups.TotalWikis,\n    ubs.TotalBadges,\n    ubs.GoldBadges,\n    ubs.SilverBadges,\n    ubs.BronzeBadges\nFROM \n    UserPostStats ups\nLEFT JOIN \n    UserBadgeStats ubs ON ups.UserId = ubs.UserId\nORDER BY \n    ups.TotalPosts DESC\nLIMIT 100;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column ubs.userid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"ubs\" }), name: \"userid\" }, Column { relation: Some(Bare { table: \"ubs\" }), name: \"totalbadges\" }, Column { relation: Some(Bare { table: \"ubs\" }), name: \"goldbadges\" }, Column { relation: Some(Bare { table: \"ubs\" }), name: \"silverbadges\" }, Column { relation: Some(Bare { table: \"ubs\" }), name: \"bronzebadges\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "10950.sql", "original_sql": "\nWITH UserActivity AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        u.Reputation,\n        COUNT(p.Id) AS PostCount,\n        COUNT(c.Id) AS CommentCount,\n        SUM(CASE WHEN v.CreationDate IS NOT NULL THEN 1 ELSE 0 END) AS VoteCount,\n        SUM(CASE WHEN b.Id IS NOT NULL THEN 1 ELSE 0 END) AS BadgeCount\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON u.Id = v.UserId\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    WHERE \n        u.Reputation > 0 \n    GROUP BY \n        u.Id, u.DisplayName, u.Reputation\n)\n\nSELECT \n    UserId,\n    DisplayName,\n    Reputation,\n    PostCount,\n    CommentCount,\n    VoteCount,\n    BadgeCount\nFROM \n    UserActivity\nORDER BY \n    PostCount DESC, Reputation DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    u.Id AS UserId,\n    COALESCE(p.PostCount, 0) AS PostCount,\n    COALESCE(c.CommentCount, 0) AS CommentCount,\n    COALESCE(v.VoteCount, 0) AS VoteCount,\n    COALESCE(b.BadgeCount, 0) AS BadgeCount\nFROM Users u\nLEFT JOIN (\n    SELECT OwnerUserId AS UserId, COUNT(*) AS PostCount\n    FROM Posts\n    GROUP BY OwnerUserId\n) p ON u.Id = p.UserId\nLEFT JOIN (\n    SELECT p.OwnerUserId AS UserId, COUNT(*) AS CommentCount\n    FROM Posts p\n    JOIN Comments c ON p.Id = c.PostId\n    GROUP BY p.OwnerUserId\n) c ON u.Id = c.UserId\nLEFT JOIN (\n    SELECT UserId, COUNT(*) AS VoteCount\n    FROM Votes\n    GROUP BY UserId\n) v ON u.Id = v.UserId\nLEFT JOIN (\n    SELECT UserId, COUNT(*) AS BadgeCount\n    FROM Badges\n    GROUP BY UserId\n) b ON u.Id = b.UserId\nWHERE u.Reputation > 0;", "sql2": "SELECT\n    u.Id AS UserId,\n    u.DisplayName,\n    u.Reputation,\n    s1.PostCount,\n    s1.CommentCount,\n    s1.VoteCount,\n    s1.BadgeCount\nFROM Users u\nJOIN s1 ON u.Id = s1.UserId\nWHERE u.Reputation > 0\nORDER BY s1.PostCount DESC, u.Reputation DESC\nLIMIT 100;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "10972.sql", "original_sql": "\nWITH PostMetrics AS (\n    SELECT \n        P.Id AS PostId,\n        P.Title,\n        P.CreationDate,\n        P.ViewCount,\n        P.Score,\n        P.AnswerCount,\n        COUNT(CASE WHEN C.Id IS NOT NULL THEN 1 END) AS CommentCount,\n        COALESCE(SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END), 0) AS Upvotes,\n        COALESCE(SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END), 0) AS Downvotes,\n        U.DisplayName AS OwnerDisplayName\n    FROM Posts P\n    LEFT JOIN Users U ON P.OwnerUserId = U.Id\n    LEFT JOIN Votes V ON P.Id = V.PostId\n    LEFT JOIN Comments C ON P.Id = C.PostId\n    GROUP BY P.Id, P.Title, P.CreationDate, P.ViewCount, P.Score, P.AnswerCount, U.DisplayName\n),\nPostHistoryMetrics AS (\n    SELECT \n        PH.PostId,\n        COUNT(CASE WHEN PH.PostHistoryTypeId = 10 THEN 1 END) AS CloseCount,\n        COUNT(CASE WHEN PH.PostHistoryTypeId = 11 THEN 1 END) AS ReopenCount\n    FROM PostHistory PH\n    GROUP BY PH.PostId\n)\nSELECT \n    PM.PostId,\n    PM.Title,\n    PM.CreationDate,\n    PM.ViewCount,\n    PM.Score,\n    PM.AnswerCount,\n    PM.CommentCount,\n    PM.OwnerDisplayName,\n    PM.Upvotes,\n    PM.Downvotes,\n    COALESCE(PHM.CloseCount, 0) AS CloseCount,\n    COALESCE(PHM.ReopenCount, 0) AS ReopenCount\nFROM PostMetrics PM\nLEFT JOIN PostHistoryMetrics PHM ON PM.PostId = PHM.PostId\nORDER BY PM.Score DESC, PM.ViewCount DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT PH.PostId,\n       COUNT(CASE WHEN PH.PostHistoryTypeId = 10 THEN 1 END) AS CloseCount,\n       COUNT(CASE WHEN PH.PostHistoryTypeId = 11 THEN 1 END) AS ReopenCount\nFROM PostHistory PH\nGROUP BY PH.PostId;", "sql2": "WITH PostMetrics AS (\n    SELECT \n        P.Id AS PostId,\n        P.Title,\n        P.CreationDate,\n        P.ViewCount,\n        P.Score,\n        P.AnswerCount,\n        COUNT(CASE WHEN C.Id IS NOT NULL THEN 1 END) AS CommentCount,\n        COALESCE(SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END), 0) AS Upvotes,\n        COALESCE(SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END), 0) AS Downvotes,\n        U.DisplayName AS OwnerDisplayName\n    FROM Posts P\n    LEFT JOIN Users U ON P.OwnerUserId = U.Id\n    LEFT JOIN Votes V ON P.Id = V.PostId\n    LEFT JOIN Comments C ON P.Id = C.PostId\n    GROUP BY P.Id, P.Title, P.CreationDate, P.ViewCount, P.Score, P.AnswerCount, U.DisplayName\n)\nSELECT \n    PM.PostId,\n    PM.Title,\n    PM.CreationDate,\n    PM.ViewCount,\n    PM.Score,\n    PM.AnswerCount,\n    PM.CommentCount,\n    PM.OwnerDisplayName,\n    PM.Upvotes,\n    PM.Downvotes,\n    COALESCE(s1.CloseCount, 0) AS CloseCount,\n    COALESCE(s1.ReopenCount, 0) AS ReopenCount\nFROM PostMetrics PM\nLEFT JOIN s1 ON PM.PostId = s1.PostId\nORDER BY PM.Score DESC, PM.ViewCount DESC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "10975.sql", "original_sql": "SELECT \n    ph.PostId,\n    COUNT(*) AS RevisionCount,\n    MIN(ph.CreationDate) AS FirstRevisionDate,\n    MAX(ph.CreationDate) AS LastRevisionDate,\n    STRING_AGG(DISTINCT p.Title, ', ') AS PostTitles,\n    COUNT(DISTINCT c.Id) AS CommentCount,\n    COUNT(DISTINCT v.Id) AS VoteCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVoteCount,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVoteCount\nFROM \n    PostHistory ph\nJOIN \n    Posts p ON ph.PostId = p.Id\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nGROUP BY \n    ph.PostId\nORDER BY \n    RevisionCount DESC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: SQL(ParserError(\"Expected: identifier, found: ) at Line: 13, Column: 1\"), None)\n", "engine_mem_mb": 500000}
{"query_id": "10988.sql", "original_sql": "\nWITH UserStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.Reputation,\n        COUNT(DISTINCT P.Id) AS PostCount,\n        SUM(COALESCE(P.Score, 0)) AS TotalScore,\n        SUM(COALESCE(C.CommentCount, 0)) AS TotalComments\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    LEFT JOIN \n        (SELECT PostId, COUNT(*) AS CommentCount FROM Comments GROUP BY PostId) C ON P.Id = C.PostId\n    WHERE \n        U.Reputation > 0\n    GROUP BY \n        U.Id, U.Reputation\n),\nPostDetails AS (\n    SELECT \n        P.Id AS PostId,\n        P.Title,\n        P.CreationDate,\n        PT.Name AS PostType,\n        COALESCE(V.UpVotes, 0) AS UpVotes,\n        COALESCE(V.DownVotes, 0) AS DownVotes,\n        P.OwnerUserId\n    FROM \n        Posts P\n    JOIN \n        PostTypes PT ON P.PostTypeId = PT.Id\n    LEFT JOIN \n        (SELECT \n            PostId, \n            SUM(CASE WHEN VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n            SUM(CASE WHEN VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n        FROM \n            Votes \n        GROUP BY PostId) V ON P.Id = V.PostId\n)\nSELECT \n    U.UserId,\n    U.Reputation,\n    U.PostCount,\n    U.TotalScore,\n    U.TotalComments,\n    P.PostId,\n    P.Title,\n    P.CreationDate,\n    P.PostType,\n    P.UpVotes,\n    P.DownVotes\nFROM \n    UserStats U\nJOIN \n    PostDetails P ON U.UserId = P.OwnerUserId\nORDER BY \n    U.Reputation DESC, \n    U.TotalScore DESC, \n    P.UpVotes DESC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 'u'\", span: None, notes: [DiagnosticNote { message: \"possible column p.owneruserid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"u\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"u\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"postid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"title\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"creationdate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"posttype\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"upvotes\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"downvotes\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"owneruserid\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "11002.sql", "original_sql": "WITH PostStats AS (\n    SELECT \n        pt.Name AS PostType,\n        COUNT(p.Id) AS TotalPosts,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers,\n        SUM(p.ViewCount) AS TotalViews,\n        AVG(p.Score) AS AvgScore,\n        AVG(p.AnswerCount) AS AvgAnswersPerQuestion\n    FROM \n        Posts p\n    JOIN \n        PostTypes pt ON p.PostTypeId = pt.Id\n    GROUP BY \n        pt.Name\n),\n\nUserStats AS (\n    SELECT \n        COUNT(u.Id) AS TotalUsers,\n        SUM(u.Reputation) AS TotalReputation,\n        AVG(u.Reputation) AS AvgReputation,\n        COUNT(DISTINCT CASE WHEN u.UpVotes > 0 THEN u.Id END) AS ActiveUsers,\n        SUM(CASE WHEN u.LastAccessDate > cast('2024-10-01' as date) - INTERVAL '30 days' THEN 1 ELSE 0 END) AS RecentUsers\n    FROM \n        Users u\n),\n\nCommentStats AS (\n    SELECT \n        COUNT(c.Id) AS TotalComments,\n        AVG(LENGTH(c.Text)) AS AvgCommentLength,\n        SUM(CASE WHEN c.Score > 0 THEN 1 ELSE 0 END) AS PositiveComments\n    FROM \n        Comments c\n)\n\nSELECT \n    ps.PostType,\n    ps.TotalPosts,\n    ps.TotalQuestions,\n    ps.TotalAnswers,\n    ps.TotalViews,\n    ps.AvgScore,\n    ps.AvgAnswersPerQuestion,\n    us.TotalUsers,\n    us.TotalReputation,\n    us.AvgReputation,\n    us.ActiveUsers,\n    us.RecentUsers,\n    cs.TotalComments,\n    cs.AvgCommentLength,\n    cs.PositiveComments\nFROM \n    PostStats ps,\n    UserStats us,\n    CommentStats cs\nORDER BY \n    ps.TotalPosts DESC;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Collection([Diagnostic(Diagnostic { kind: Error, message: \"column 'posttype' not found in 'ps'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"ps\" }), name: \"posttype\" }, valid_fields: [Column { relation: Some(Bare { table: \"ps\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"totalusers\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"totalreputation\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"avgreputation\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"activeusers\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"recentusers\" }, Column { relation: Some(Bare { table: \"cs\" }), name: \"totalcomments\" }, Column { relation: Some(Bare { table: \"cs\" }), name: \"avgcommentlength\" }, Column { relation: Some(Bare { table: \"cs\" }), name: \"positivecomments\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'totalposts' not found in 'ps'\", span: None, notes: [DiagnosticNote { message: \"possible column us.totalusers\", span: None }, DiagnosticNote { message: \"possible column cs.totalcomments\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"ps\" }), name: \"totalposts\" }, valid_fields: [Column { relation: Some(Bare { table: \"ps\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"totalusers\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"totalreputation\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"avgreputation\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"activeusers\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"recentusers\" }, Column { relation: Some(Bare { table: \"cs\" }), name: \"totalcomments\" }, Column { relation: Some(Bare { table: \"cs\" }), name: \"avgcommentlength\" }, Column { relation: Some(Bare { table: \"cs\" }), name: \"positivecomments\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'totalquestions' not found in 'ps'\", span: None, notes: [DiagnosticNote { message: \"possible column us.totalusers\", span: None }, DiagnosticNote { message: \"possible column us.totalreputation\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"ps\" }), name: \"totalquestions\" }, valid_fields: [Column { relation: Some(Bare { table: \"ps\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"totalusers\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"totalreputation\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"avgreputation\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"activeusers\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"recentusers\" }, Column { relation: Some(Bare { table: \"cs\" }), name: \"totalcomments\" }, Column { relation: Some(Bare { table: \"cs\" }), name: \"avgcommentlength\" }, Column { relation: Some(Bare { table: \"cs\" }), name: \"positivecomments\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'totalanswers' not found in 'ps'\", span: None, notes: [DiagnosticNote { message: \"possible column us.totalusers\", span: None }, DiagnosticNote { message: \"possible column cs.totalcomments\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"ps\" }), name: \"totalanswers\" }, valid_fields: [Column { relation: Some(Bare { table: \"ps\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"totalusers\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"totalreputation\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"avgreputation\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"activeusers\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"recentusers\" }, Column { relation: Some(Bare { table: \"cs\" }), name: \"totalcomments\" }, Column { relation: Some(Bare { table: \"cs\" }), name: \"avgcommentlength\" }, Column { relation: Some(Bare { table: \"cs\" }), name: \"positivecomments\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'totalviews' not found in 'ps'\", span: None, notes: [DiagnosticNote { message: \"possible column us.totalusers\", span: None }, DiagnosticNote { message: \"possible column cs.totalcomments\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"ps\" }), name: \"totalviews\" }, valid_fields: [Column { relation: Some(Bare { table: \"ps\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"totalusers\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"totalreputation\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"avgreputation\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"activeusers\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"recentusers\" }, Column { relation: Some(Bare { table: \"cs\" }), name: \"totalcomments\" }, Column { relation: Some(Bare { table: \"cs\" }), name: \"avgcommentlength\" }, Column { relation: Some(Bare { table: \"cs\" }), name: \"positivecomments\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'avgscore' not found in 'ps'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"ps\" }), name: \"avgscore\" }, valid_fields: [Column { relation: Some(Bare { table: \"ps\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"totalusers\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"totalreputation\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"avgreputation\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"activeusers\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"recentusers\" }, Column { relation: Some(Bare { table: \"cs\" }), name: \"totalcomments\" }, Column { relation: Some(Bare { table: \"cs\" }), name: \"avgcommentlength\" }, Column { relation: Some(Bare { table: \"cs\" }), name: \"positivecomments\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'avganswersperquestion' not found in 'ps'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"ps\" }), name: \"avganswersperquestion\" }, valid_fields: [Column { relation: Some(Bare { table: \"ps\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"totalusers\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"totalreputation\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"avgreputation\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"activeusers\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"recentusers\" }, Column { relation: Some(Bare { table: \"cs\" }), name: \"totalcomments\" }, Column { relation: Some(Bare { table: \"cs\" }), name: \"avgcommentlength\" }, Column { relation: Some(Bare { table: \"cs\" }), name: \"positivecomments\" }] }, Some(\"\")))])\n", "engine_mem_mb": 500000}
{"query_id": "11008.sql", "original_sql": "WITH PostStats AS (\n    SELECT \n        pt.Name AS PostType,\n        COUNT(p.Id) AS PostCount,\n        AVG(p.Score) AS AverageScore\n    FROM \n        Posts p\n    INNER JOIN \n        PostTypes pt ON p.PostTypeId = pt.Id\n    GROUP BY \n        pt.Name\n),\n\nBadgeStats AS (\n    SELECT \n        COUNT(DISTINCT b.UserId) AS UniqueUsersWithBadges\n    FROM \n        Badges b\n)\n\nSELECT \n    ps.PostType,\n    ps.PostCount,\n    ps.AverageScore,\n    bs.UniqueUsersWithBadges\nFROM \n    PostStats ps,\n    BadgeStats bs\nORDER BY \n    ps.PostType;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT pt.Name AS PostType,\n       COUNT(p.Id) AS PostCount,\n       AVG(p.Score) AS AverageScore\nFROM Posts p\nJOIN PostTypes pt ON p.PostTypeId = pt.Id\nGROUP BY pt.Name;", "sql2": "SELECT ps.PostType,\n       ps.PostCount,\n       ps.AverageScore,\n       bs.UniqueUsersWithBadges\nFROM s1 ps\nCROSS JOIN (\n    SELECT COUNT(DISTINCT b.UserId) AS UniqueUsersWithBadges\n    FROM Badges b\n) bs\nORDER BY ps.PostType;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11026.sql", "original_sql": "SELECT \n    P.Id AS PostId,\n    P.Title,\n    P.CreationDate,\n    P.ViewCount,\n    PT.Name AS PostType,\n    U.DisplayName AS OwnerDisplayName,\n    COALESCE(V.UpVotesCount, 0) AS UpVotesCount,\n    COALESCE(V.DownVotesCount, 0) AS DownVotesCount,\n    COALESCE(B.BadgeCount, 0) AS BadgeCount\nFROM \n    Posts P\nJOIN \n    PostTypes PT ON P.PostTypeId = PT.Id\nLEFT JOIN \n    Users U ON P.OwnerUserId = U.Id\nLEFT JOIN \n    (SELECT \n         PostId, \n         SUM(CASE WHEN VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotesCount,\n         SUM(CASE WHEN VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotesCount\n     FROM \n         Votes\n     GROUP BY \n         PostId) V ON P.Id = V.PostId\nLEFT JOIN \n    (SELECT \n         UserId, \n         COUNT(*) AS BadgeCount\n     FROM \n         Badges\n     GROUP BY \n         UserId) B ON U.Id = B.UserId\nORDER BY \n    P.CreationDate DESC\nLIMIT 100;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT PostId,\n       SUM(CASE WHEN VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotesCount,\n       SUM(CASE WHEN VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotesCount\nFROM Votes\nGROUP BY PostId;", "sql2": "SELECT \n    P.Id AS PostId,\n    P.Title,\n    P.CreationDate,\n    P.ViewCount,\n    PT.Name AS PostType,\n    U.DisplayName AS OwnerDisplayName,\n    COALESCE(s1.UpVotesCount, 0) AS UpVotesCount,\n    COALESCE(s1.DownVotesCount, 0) AS DownVotesCount,\n    COALESCE(B.BadgeCount, 0) AS BadgeCount\nFROM Posts P\nJOIN PostTypes PT ON P.PostTypeId = PT.Id\nLEFT JOIN Users U ON P.OwnerUserId = U.Id\nLEFT JOIN (\n    SELECT UserId, COUNT(*) AS BadgeCount\n    FROM Badges\n    GROUP BY UserId\n) B ON U.Id = B.UserId\nLEFT JOIN s1 ON P.Id = s1.PostId\nORDER BY P.CreationDate DESC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11068.sql", "original_sql": "\nWITH PostStats AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        p.ViewCount,\n        p.Score,\n        COUNT(c.Id) AS CommentCount,\n        COUNT(DISTINCT v.Id) AS VoteCount,\n        COUNT(DISTINCT bh.Id) AS BadgeCount\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON c.PostId = p.Id\n    LEFT JOIN \n        Votes v ON v.PostId = p.Id\n    LEFT JOIN \n        Badges bh ON bh.UserId = p.OwnerUserId\n    WHERE \n        p.CreationDate >= TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '1 year'  \n    GROUP BY \n        p.Id, p.Title, p.CreationDate, p.ViewCount, p.Score\n),\nUserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(DISTINCT p.Id) AS PostsCount,\n        SUM(u.UpVotes) AS TotalUpVotes,\n        SUM(u.DownVotes) AS TotalDownVotes,\n        SUM(u.Views) AS TotalViews\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON p.OwnerUserId = u.Id\n    WHERE \n        u.CreationDate >= TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '1 year'  \n    GROUP BY \n        u.Id, u.DisplayName\n)\nSELECT \n    ps.PostId,\n    ps.Title,\n    ps.CreationDate,\n    ps.ViewCount,\n    ps.Score,\n    ps.CommentCount,\n    ps.VoteCount,\n    us.UserId,\n    us.DisplayName,\n    us.PostsCount,\n    us.TotalUpVotes,\n    us.TotalDownVotes,\n    us.TotalViews\nFROM \n    PostStats ps\nJOIN \n    UserStats us ON ps.PostId = us.UserId\nORDER BY \n    ps.ViewCount DESC, ps.Score DESC  \nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.ViewCount,\n    p.Score,\n    COUNT(c.Id) AS CommentCount,\n    COUNT(DISTINCT v.Id) AS VoteCount,\n    COUNT(DISTINCT bh.Id) AS BadgeCount\nFROM Posts p\nLEFT JOIN Comments c ON c.PostId = p.Id\nLEFT JOIN Votes v ON v.PostId = p.Id\nLEFT JOIN Badges bh ON bh.UserId = p.OwnerUserId\nWHERE p.CreationDate >= TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '1 year'\nGROUP BY p.Id, p.Title, p.CreationDate, p.ViewCount, p.Score", "sql2": "WITH UserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(DISTINCT p.Id) AS PostsCount,\n        SUM(u.UpVotes) AS TotalUpVotes,\n        SUM(u.DownVotes) AS TotalDownVotes,\n        SUM(u.Views) AS TotalViews\n    FROM Users u\n    LEFT JOIN Posts p ON p.OwnerUserId = u.Id\n    WHERE u.CreationDate >= TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '1 year'\n    GROUP BY u.Id, u.DisplayName\n)\nSELECT \n    s1.PostId,\n    s1.Title,\n    s1.CreationDate,\n    s1.ViewCount,\n    s1.Score,\n    s1.CommentCount,\n    s1.VoteCount,\n    us.UserId,\n    us.DisplayName,\n    us.PostsCount,\n    us.TotalUpVotes,\n    us.TotalDownVotes,\n    us.TotalViews\nFROM s1\nJOIN UserStats us ON s1.PostId = us.UserId\nORDER BY s1.ViewCount DESC, s1.Score DESC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11090.sql", "original_sql": "\nWITH PostStatistics AS (\n    SELECT \n        P.Id AS PostId,\n        P.Title,\n        P.CreationDate AS PostCreationDate,\n        P.Score,\n        P.ViewCount,\n        P.AnswerCount,\n        P.CommentCount,\n        U.Id AS OwnerUserId,\n        U.DisplayName AS OwnerDisplayName,\n        COUNT(C.Id) AS TotalComments,\n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUpVotes,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalDownVotes\n    FROM \n        Posts P\n    LEFT JOIN \n        Users U ON P.OwnerUserId = U.Id\n    LEFT JOIN \n        Comments C ON C.PostId = P.Id\n    LEFT JOIN \n        Votes V ON V.PostId = P.Id\n    WHERE \n        P.PostTypeId = 1 \n    GROUP BY \n        P.Id, P.Title, P.CreationDate, P.Score, P.ViewCount, P.AnswerCount, P.CommentCount, U.Id, U.DisplayName\n),\nUserStatistics AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(P.Id) AS TotalPosts,\n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUserUpVotes,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalUserDownVotes\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON P.OwnerUserId = U.Id\n    LEFT JOIN \n        Votes V ON V.UserId = U.Id\n    GROUP BY \n        U.Id, U.DisplayName\n)\n\nSELECT \n    PS.PostId,\n    PS.Title,\n    PS.PostCreationDate,\n    PS.Score,\n    PS.ViewCount,\n    PS.AnswerCount,\n    PS.CommentCount,\n    PS.TotalComments,\n    PS.TotalUpVotes,\n    PS.TotalDownVotes,\n    US.UserId AS OwnerUserId,\n    US.DisplayName AS OwnerDisplayName,\n    US.TotalPosts AS UserTotalPosts,\n    US.TotalUserUpVotes,\n    US.TotalUserDownVotes\nFROM \n    PostStatistics PS\nJOIN \n    UserStatistics US ON PS.OwnerUserId = US.UserId\nORDER BY \n    PS.Score DESC, PS.ViewCount DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH PostStatistics AS (\n    SELECT \n        P.Id AS PostId,\n        P.Title,\n        P.CreationDate AS PostCreationDate,\n        P.Score,\n        P.ViewCount,\n        P.AnswerCount,\n        P.CommentCount,\n        U.Id AS OwnerUserId,\n        U.DisplayName AS OwnerDisplayName,\n        COUNT(C.Id) AS TotalComments,\n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUpVotes,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalDownVotes\n    FROM Posts P\n    LEFT JOIN Users U ON P.OwnerUserId = U.Id\n    LEFT JOIN Comments C ON C.PostId = P.Id\n    LEFT JOIN Votes V ON V.PostId = P.Id\n    WHERE P.PostTypeId = 1\n    GROUP BY P.Id, P.Title, P.CreationDate, P.Score, P.ViewCount, P.AnswerCount, P.CommentCount, U.Id, U.DisplayName\n)\nSELECT * FROM PostStatistics;", "sql2": "WITH UserStatistics AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(P.Id) AS TotalPosts,\n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUserUpVotes,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalUserDownVotes\n    FROM Users U\n    LEFT JOIN Posts P ON P.OwnerUserId = U.Id\n    LEFT JOIN Votes V ON V.UserId = U.Id\n    GROUP BY U.Id, U.DisplayName\n)\nSELECT \n    PS.PostId,\n    PS.Title,\n    PS.PostCreationDate,\n    PS.Score,\n    PS.ViewCount,\n    PS.AnswerCount,\n    PS.CommentCount,\n    PS.TotalComments,\n    PS.TotalUpVotes,\n    PS.TotalDownVotes,\n    US.UserId AS OwnerUserId,\n    US.DisplayName AS OwnerDisplayName,\n    US.TotalPosts AS UserTotalPosts,\n    US.TotalUserUpVotes,\n    US.TotalUserDownVotes\nFROM s1 PS\nJOIN UserStatistics US ON PS.OwnerUserId = US.UserId\nORDER BY PS.Score DESC, PS.ViewCount DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11096.sql", "original_sql": "WITH UserPosts AS (\n    SELECT \n        u.Id AS UserId,\n        COUNT(p.Id) AS PostCount,\n        SUM(CASE WHEN p.Score IS NOT NULL THEN p.Score ELSE 0 END) AS TotalScore,\n        SUM(CASE WHEN p.ViewCount IS NOT NULL THEN p.ViewCount ELSE 0 END) AS TotalViews,\n        AVG(CASE WHEN p.ViewCount IS NOT NULL THEN p.ViewCount ELSE 0 END) AS AvgViewsPerPost\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    GROUP BY \n        u.Id\n),\nPostHistoryAggregates AS (\n    SELECT \n        ph.PostId,\n        COUNT(*) AS HistoryCount,\n        MAX(ph.CreationDate) AS LastModified\n    FROM \n        PostHistory ph\n    GROUP BY \n        ph.PostId\n),\nPostsWithHistory AS (\n    SELECT \n        p.*, \n        pha.HistoryCount, \n        pha.LastModified\n    FROM \n        Posts p\n    LEFT JOIN \n        PostHistoryAggregates pha ON p.Id = pha.PostId\n)\n\nSELECT \n    u.DisplayName,\n    up.PostCount,\n    up.TotalScore,\n    up.TotalViews,\n    up.AvgViewsPerPost,\n    p.Title,\n    p.HistoryCount,\n    p.LastModified,\n    p.CreationDate AS PostCreationDate\nFROM \n    UserPosts up\nJOIN \n    Users u ON up.UserId = u.Id\nJOIN \n    PostsWithHistory p ON u.Id = p.OwnerUserId\nORDER BY \n    up.TotalScore DESC, \n    up.PostCount DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT u.Id AS UserId,\n       COUNT(p.Id) AS PostCount,\n       SUM(COALESCE(p.Score,0)) AS TotalScore,\n       SUM(COALESCE(p.ViewCount,0)) AS TotalViews,\n       AVG(COALESCE(p.ViewCount,0)) AS AvgViewsPerPost\nFROM Users u\nLEFT JOIN Posts p ON u.Id = p.OwnerUserId\nGROUP BY u.Id;", "sql2": "WITH PostHistoryAggregates AS (\n    SELECT ph.PostId,\n           COUNT(*) AS HistoryCount,\n           MAX(ph.CreationDate) AS LastModified\n    FROM PostHistory ph\n    GROUP BY ph.PostId\n),\nPostsWithHistory AS (\n    SELECT p.*, \n           pha.HistoryCount,\n           pha.LastModified\n    FROM Posts p\n    LEFT JOIN PostHistoryAggregates pha ON p.Id = pha.PostId\n)\nSELECT u.DisplayName,\n       s1.PostCount,\n       s1.TotalScore,\n       s1.TotalViews,\n       s1.AvgViewsPerPost,\n       pwh.Title,\n       pwh.HistoryCount,\n       pwh.LastModified,\n       pwh.CreationDate AS PostCreationDate\nFROM s1\nJOIN Users u ON s1.UserId = u.Id\nJOIN PostsWithHistory pwh ON u.Id = pwh.OwnerUserId\nORDER BY s1.TotalScore DESC, s1.PostCount DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11105.sql", "original_sql": "\nSELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.Score,\n    p.ViewCount,\n    u.DisplayName AS OwnerDisplayName,\n    COUNT(c.Id) AS CommentCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n    AVG(CASE WHEN bh.PostHistoryTypeId = 10 THEN 1 ELSE 0 END) AS CloseRate,\n    AVG(CASE WHEN bh.PostHistoryTypeId = 11 THEN 1 ELSE 0 END) AS ReopenRate\nFROM \n    Posts p\nLEFT JOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nLEFT JOIN \n    PostHistory bh ON p.Id = bh.PostId\nWHERE \n    p.PostTypeId = 1  \nGROUP BY \n    p.Id, p.Title, p.CreationDate, p.Score, p.ViewCount, u.DisplayName\nORDER BY \n    p.CreationDate DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    p.Id AS PostId,\n    COUNT(DISTINCT c.Id) AS CommentCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n    AVG(CASE WHEN bh.PostHistoryTypeId = 10 THEN 1.0 ELSE 0 END) AS CloseRate,\n    AVG(CASE WHEN bh.PostHistoryTypeId = 11 THEN 1.0 ELSE 0 END) AS ReopenRate\nFROM Posts p\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Votes v ON p.Id = v.PostId\nLEFT JOIN PostHistory bh ON p.Id = bh.PostId\nWHERE p.PostTypeId = 1\nGROUP BY p.Id;", "sql2": "SELECT\n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.Score,\n    p.ViewCount,\n    u.DisplayName AS OwnerDisplayName,\n    s.CommentCount,\n    s.UpVotes,\n    s.DownVotes,\n    s.CloseRate,\n    s.ReopenRate\nFROM Posts p\nLEFT JOIN Users u ON p.OwnerUserId = u.Id\nJOIN s1 s ON p.Id = s.PostId\nWHERE p.PostTypeId = 1\nORDER BY p.CreationDate DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "11122.sql", "original_sql": "\nWITH PostStats AS (\n    SELECT \n        P.Id AS PostId,\n        P.Title,\n        P.CreationDate,\n        (SELECT COUNT(*) FROM Comments C WHERE C.PostId = P.Id) AS CommentCount,\n        (SELECT COUNT(*) FROM Votes V WHERE V.PostId = P.Id) AS VoteCount,\n        (SELECT COUNT(*) FROM Posts A WHERE A.ParentId = P.Id) AS AnswerCount,\n        P.OwnerUserId\n    FROM \n        Posts P\n    WHERE \n        P.PostTypeId = 1 \n),\nUserStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(B.Id) AS BadgeCount\n    FROM \n        Users U\n    LEFT JOIN \n        Badges B ON U.Id = B.UserId\n    GROUP BY \n        U.Id, U.DisplayName\n)\nSELECT \n    PS.PostId,\n    PS.Title,\n    PS.CreationDate,\n    PS.CommentCount,\n    PS.VoteCount,\n    PS.AnswerCount,\n    US.UserId,\n    US.DisplayName,\n    US.BadgeCount\nFROM \n    PostStats PS\nJOIN \n    Users U ON PS.OwnerUserId = U.Id\nJOIN \n    UserStats US ON US.UserId = U.Id\nORDER BY \n    PS.CreationDate DESC\nLIMIT 100;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "11166.sql", "original_sql": "\nWITH UserPostActivity AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(DISTINCT p.Id) AS TotalPosts,\n        COUNT(DISTINCT c.Id) AS TotalComments,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers,\n        SUM(p.Score) AS TotalScore,\n        SUM(p.ViewCount) AS TotalViews,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    GROUP BY \n        u.Id, u.DisplayName\n),\nPostPerformance AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        p.Score,\n        p.ViewCount,\n        COUNT(DISTINCT c.Id) AS CommentCount,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    GROUP BY \n        p.Id, p.Title, p.CreationDate, p.Score, p.ViewCount\n)\nSELECT \n    ua.UserId,\n    ua.DisplayName,\n    ua.TotalPosts,\n    ua.TotalQuestions,\n    ua.TotalAnswers,\n    ua.TotalScore,\n    ua.TotalViews,\n    pp.PostId,\n    pp.Title,\n    pp.CreationDate,\n    pp.Score,\n    pp.ViewCount,\n    pp.CommentCount,\n    pp.UpVotes AS PostUpVotes,\n    pp.DownVotes AS PostDownVotes\nFROM \n    UserPostActivity ua\nJOIN \n    PostPerformance pp ON ua.UserId = pp.PostId\nORDER BY \n    ua.TotalScore DESC, pp.Score DESC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT\n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.Score,\n    p.ViewCount,\n    COUNT(DISTINCT c.Id) AS CommentCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\nFROM Posts p\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Votes v ON p.Id = v.PostId\nGROUP BY p.Id, p.Title, p.CreationDate, p.Score, p.ViewCount;", "sql2": "SELECT\n    ua.UserId,\n    ua.DisplayName,\n    ua.TotalPosts,\n    ua.TotalQuestions,\n    ua.TotalAnswers,\n    ua.TotalScore,\n    ua.TotalViews,\n    s1.PostId,\n    s1.Title,\n    s1.CreationDate,\n    s1.Score,\n    s1.ViewCount,\n    s1.CommentCount,\n    s1.UpVotes AS PostUpVotes,\n    s1.DownVotes AS PostDownVotes\nFROM (\n    SELECT\n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(DISTINCT p.Id) AS TotalPosts,\n        COUNT(DISTINCT c.Id) AS TotalComments,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers,\n        SUM(p.Score) AS TotalScore,\n        SUM(p.ViewCount) AS TotalViews,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM Users u\n    LEFT JOIN Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN Comments c ON p.Id = c.PostId\n    LEFT JOIN Votes v ON p.Id = v.PostId\n    GROUP BY u.Id, u.DisplayName\n) ua\nJOIN s1 ON ua.UserId = s1.PostId\nORDER BY ua.TotalScore DESC, s1.Score DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11181.sql", "original_sql": "SELECT \n    u.Id AS UserId,\n    u.Reputation,\n    u.DisplayName,\n    COUNT(p.Id) AS PostCount,\n    SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n    SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n    COALESCE(SUM(c.CommentCount), 0) AS TotalComments,\n    COALESCE(SUM(v.VoteCount), 0) AS TotalVotes\nFROM \n    Users u\nLEFT JOIN \n    Posts p ON u.Id = p.OwnerUserId\nLEFT JOIN \n    (SELECT PostId, COUNT(*) AS CommentCount FROM Comments GROUP BY PostId) c ON p.Id = c.PostId\nLEFT JOIN \n    (SELECT PostId, COUNT(*) AS VoteCount FROM Votes GROUP BY PostId) v ON p.Id = v.PostId\nGROUP BY \n    u.Id, u.Reputation, u.DisplayName\nORDER BY \n    u.Reputation DESC;", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT p.Id AS PostId,\n       p.OwnerUserId,\n       p.PostTypeId,\n       COALESCE(c.CommentCount, 0) AS CommentCount,\n       COALESCE(v.VoteCount, 0) AS VoteCount\nFROM Posts p\nLEFT JOIN (\n    SELECT PostId, COUNT(*) AS CommentCount\n    FROM Comments\n    GROUP BY PostId\n) c ON p.Id = c.PostId\nLEFT JOIN (\n    SELECT PostId, COUNT(*) AS VoteCount\n    FROM Votes\n    GROUP BY PostId\n) v ON p.Id = v.PostId;", "sql2": "SELECT u.Id AS UserId,\n       u.Reputation,\n       u.DisplayName,\n       COUNT(s1.PostId) AS PostCount,\n       SUM(CASE WHEN s1.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n       SUM(CASE WHEN s1.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n       COALESCE(SUM(s1.CommentCount), 0) AS TotalComments,\n       COALESCE(SUM(s1.VoteCount), 0) AS TotalVotes\nFROM Users u\nLEFT JOIN s1 ON u.Id = s1.OwnerUserId\nGROUP BY u.Id, u.Reputation, u.DisplayName\nORDER BY u.Reputation DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11186.sql", "original_sql": "SELECT \n    pt.Name AS PostType,\n    COUNT(p.Id) AS TotalPosts,\n    AVG(p.Score) AS AverageScore,\n    AVG(p.ViewCount) AS AverageViewCount,\n    COUNT(DISTINCT p.OwnerUserId) AS UniqueContributors\nFROM \n    Posts p\nJOIN \n    PostTypes pt ON p.PostTypeId = pt.Id   \nGROUP BY \n    pt.Name\nORDER BY \n    TotalPosts DESC;", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "11240.sql", "original_sql": "WITH PostEngagement AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(p.Id) AS TotalPosts,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers,\n        SUM(COALESCE(c.CommentCount, 0)) AS TotalComments,\n        SUM(COALESCE(v.VoteCount, 0)) AS TotalVotes\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN \n        (SELECT \n            PostId, \n            COUNT(*) AS CommentCount \n        FROM \n            Comments \n        GROUP BY \n            PostId) c ON p.Id = c.PostId\n    LEFT JOIN \n        (SELECT \n            PostId, \n            COUNT(*) AS VoteCount \n        FROM \n            Votes \n        GROUP BY \n            PostId) v ON p.Id = v.PostId\n    GROUP BY \n        u.Id, u.DisplayName\n)\nSELECT \n    UserId,\n    DisplayName,\n    TotalPosts,\n    TotalQuestions,\n    TotalAnswers,\n    TotalComments,\n    TotalVotes,\n    (TotalPosts + TotalComments + TotalVotes) AS EngagementScore\nFROM \n    PostEngagement\nORDER BY \n    EngagementScore DESC\nLIMIT 10;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT p.OwnerUserId AS UserId,\n       p.PostTypeId,\n       COALESCE(c.CommentCount, 0) AS CommentCount,\n       COALESCE(v.VoteCount, 0) AS VoteCount\nFROM Posts p\nLEFT JOIN (\n    SELECT PostId, COUNT(*) AS CommentCount\n    FROM Comments\n    GROUP BY PostId\n) c ON p.Id = c.PostId\nLEFT JOIN (\n    SELECT PostId, COUNT(*) AS VoteCount\n    FROM Votes\n    GROUP BY PostId\n) v ON p.Id = v.PostId\nWHERE p.OwnerUserId IS NOT NULL;", "sql2": "SELECT u.Id AS UserId,\n       u.DisplayName,\n       COUNT(s1.UserId) AS TotalPosts,\n       SUM(CASE WHEN s1.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n       SUM(CASE WHEN s1.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers,\n       SUM(s1.CommentCount) AS TotalComments,\n       SUM(s1.VoteCount) AS TotalVotes,\n       (COUNT(s1.UserId) + SUM(s1.CommentCount) + SUM(s1.VoteCount)) AS EngagementScore\nFROM Users u\nLEFT JOIN s1 ON u.Id = s1.UserId\nGROUP BY u.Id, u.DisplayName\nORDER BY EngagementScore DESC\nLIMIT 10;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "11267.sql", "original_sql": "SELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate AS PostCreationDate,\n    p.Score,\n    p.ViewCount,\n    COALESCE(a.AcceptedAnswerCount, 0) AS AcceptedAnswerCount,\n    COALESCE(c.CommentCount, 0) AS CommentCount,\n    COALESCE(v.VoteCount, 0) AS VoteCount,\n    u.Reputation AS UserReputation,\n    u.Location AS UserLocation,\n    u.CreationDate AS UserCreationDate\nFROM \n    Posts p\nLEFT JOIN \n    (SELECT \n         ParentId, \n         COUNT(*) AS AcceptedAnswerCount \n     FROM Posts \n     WHERE PostTypeId = 2 AND AcceptedAnswerId IS NOT NULL \n     GROUP BY ParentId) a ON p.Id = a.ParentId\nLEFT JOIN \n    (SELECT \n         PostId, \n         COUNT(*) AS CommentCount \n     FROM Comments \n     GROUP BY PostId) c ON p.Id = c.PostId\nLEFT JOIN \n    (SELECT \n         PostId, \n         COUNT(*) AS VoteCount \n     FROM Votes \n     GROUP BY PostId) v ON p.Id = v.PostId\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nWHERE \n    p.CreationDate >= '2023-01-01' \nORDER BY \n    p.CreationDate DESC \nLIMIT 100;", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT \n    PostId,\n    SUM(CASE WHEN src = 'a' THEN cnt ELSE 0 END) AS AcceptedAnswerCount,\n    SUM(CASE WHEN src = 'c' THEN cnt ELSE 0 END) AS CommentCount,\n    SUM(CASE WHEN src = 'v' THEN cnt ELSE 0 END) AS VoteCount\nFROM (\n    SELECT ParentId AS PostId, COUNT(*) AS cnt, 'a' AS src\n    FROM Posts\n    WHERE PostTypeId = 2 AND AcceptedAnswerId IS NOT NULL\n    GROUP BY ParentId\n    UNION ALL\n    SELECT PostId, COUNT(*) AS cnt, 'c' AS src\n    FROM Comments\n    GROUP BY PostId\n    UNION ALL\n    SELECT PostId, COUNT(*) AS cnt, 'v' AS src\n    FROM Votes\n    GROUP BY PostId\n) t\nGROUP BY PostId;", "sql2": "SELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate AS PostCreationDate,\n    p.Score,\n    p.ViewCount,\n    COALESCE(s1.AcceptedAnswerCount, 0) AS AcceptedAnswerCount,\n    COALESCE(s1.CommentCount, 0) AS CommentCount,\n    COALESCE(s1.VoteCount, 0) AS VoteCount,\n    u.Reputation AS UserReputation,\n    u.Location AS UserLocation,\n    u.CreationDate AS UserCreationDate\nFROM Posts p\nLEFT JOIN s1 ON p.Id = s1.PostId\nJOIN Users u ON p.OwnerUserId = u.Id\nWHERE p.CreationDate >= '2023-01-01'\nORDER BY p.CreationDate DESC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11269.sql", "original_sql": "\nSELECT \n    p.Title AS PostTitle,\n    p.CreationDate AS PostCreationDate,\n    p.ViewCount AS PostViews,\n    p.Score AS PostScore,\n    u.DisplayName AS OwnerDisplayName,\n    COUNT(c.Id) AS CommentCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVoteCount,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVoteCount,\n    AVG(CASE WHEN ph.PostHistoryTypeId IN (4, 5) THEN 1 ELSE NULL END) AS AverageEdits\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nLEFT JOIN \n    PostHistory ph ON p.Id = ph.PostId\nWHERE \n    p.PostTypeId = 1 \nGROUP BY \n    p.Title, \n    p.CreationDate, \n    p.ViewCount, \n    p.Score, \n    u.DisplayName, \n    p.Id\nORDER BY \n    p.CreationDate DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT p.Id AS PostId,\n       p.Title AS PostTitle,\n       p.CreationDate AS PostCreationDate,\n       p.ViewCount AS PostViews,\n       p.Score AS PostScore,\n       u.DisplayName AS OwnerDisplayName,\n       COUNT(DISTINCT c.Id) AS CommentCount,\n       SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVoteCount,\n       SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVoteCount,\n       AVG(CASE WHEN ph.PostHistoryTypeId IN (4,5) THEN 1 ELSE NULL END) AS AverageEdits\nFROM Posts p\nJOIN Users u ON p.OwnerUserId = u.Id\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Votes v ON p.Id = v.PostId\nLEFT JOIN PostHistory ph ON p.Id = ph.PostId\nWHERE p.PostTypeId = 1\nGROUP BY p.Id, p.Title, p.CreationDate, p.ViewCount, p.Score, u.DisplayName;", "sql2": "SELECT PostTitle,\n       PostCreationDate,\n       PostViews,\n       PostScore,\n       OwnerDisplayName,\n       CommentCount,\n       UpVoteCount,\n       DownVoteCount,\n       AverageEdits\nFROM s1\nORDER BY PostCreationDate DESC\nLIMIT 100;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "11274.sql", "original_sql": "\nSELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.ViewCount,\n    p.Score,\n    COUNT(c.Id) AS CommentCount,\n    COUNT(v.Id) AS VoteCount,\n    ARRAY_AGG(DISTINCT t.TagName) AS Tags,\n    u.DisplayName AS OwnerDisplayName,\n    u.Reputation AS OwnerReputation\nFROM \n    Posts p\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nLEFT JOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    Tags t ON t.WikiPostId = p.Id OR t.ExcerptPostId = p.Id\nWHERE \n    p.PostTypeId = 1  \nGROUP BY \n    p.Id, p.Title, p.CreationDate, p.ViewCount, p.Score, u.Id, u.DisplayName, u.Reputation\nORDER BY \n    p.CreationDate DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.ViewCount,\n    p.Score,\n    COUNT(c.Id) AS CommentCount,\n    COUNT(v.Id) AS VoteCount,\n    u.DisplayName AS OwnerDisplayName,\n    u.Reputation AS OwnerReputation\nFROM Posts p\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Votes v ON p.Id = v.PostId\nLEFT JOIN Users u ON p.OwnerUserId = u.Id\nWHERE p.PostTypeId = 1\nGROUP BY p.Id, p.Title, p.CreationDate, p.ViewCount, p.Score, u.DisplayName, u.Reputation;", "sql2": "WITH tags_per_post AS (\n    SELECT t.WikiPostId AS PostId, t.TagName FROM Tags t WHERE t.WikiPostId IS NOT NULL\n    UNION ALL\n    SELECT t.ExcerptPostId AS PostId, t.TagName FROM Tags t WHERE t.ExcerptPostId IS NOT NULL\n)\nSELECT \n    s1.PostId,\n    s1.Title,\n    s1.CreationDate,\n    s1.ViewCount,\n    s1.Score,\n    s1.CommentCount,\n    s1.VoteCount,\n    ARRAY_AGG(DISTINCT tp.TagName) AS Tags,\n    s1.OwnerDisplayName,\n    s1.OwnerReputation\nFROM s1\nLEFT JOIN tags_per_post tp ON tp.PostId = s1.PostId\nGROUP BY s1.PostId, s1.Title, s1.CreationDate, s1.ViewCount, s1.Score, s1.CommentCount, s1.VoteCount, s1.OwnerDisplayName, s1.OwnerReputation\nORDER BY s1.CreationDate DESC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11315.sql", "original_sql": "WITH PostStats AS (\n    SELECT\n        pt.Name AS PostType,\n        COUNT(p.Id) AS TotalPosts,\n        COALESCE(SUM(p.Score), 0) AS TotalScore,\n        COALESCE(SUM(p.ViewCount), 0) AS TotalViews,\n        COALESCE(SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END), 0) AS TotalUpvotes,\n        COALESCE(SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END), 0) AS TotalDownvotes\n    FROM Posts p\n    JOIN PostTypes pt ON p.PostTypeId = pt.Id\n    LEFT JOIN Votes v ON p.Id = v.PostId\n    GROUP BY pt.Name\n)\n\nSELECT \n    ps.PostType,\n    ps.TotalPosts,\n    ps.TotalScore,\n    ps.TotalViews,\n    ps.TotalUpvotes,\n    ps.TotalDownvotes,\n    ROUND(ps.TotalScore * 1.0 / NULLIF(ps.TotalPosts, 0), 2) AS AvgScorePerPost,\n    ROUND(ps.TotalViews * 1.0 / NULLIF(ps.TotalPosts, 0), 2) AS AvgViewsPerPost\nFROM PostStats ps\nORDER BY ps.TotalPosts DESC;", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "11357.sql", "original_sql": "SELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.Score,\n    p.ViewCount,\n    u.DisplayName AS OwnerDisplayName,\n    u.Reputation AS OwnerReputation,\n    p.AnswerCount,\n    COALESCE(c.CommentCount, 0) AS CommentCount,\n    COALESCE(pl.LinksCount, 0) AS LinksCount,\n    COALESCE(ph.HistoryCount, 0) AS HistoryCount\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    (SELECT PostId, COUNT(*) AS CommentCount FROM Comments GROUP BY PostId) c ON p.Id = c.PostId\nLEFT JOIN \n    (SELECT PostId, COUNT(*) AS LinksCount FROM PostLinks GROUP BY PostId) pl ON p.Id = pl.PostId\nLEFT JOIN \n    (SELECT PostId, COUNT(*) AS HistoryCount FROM PostHistory GROUP BY PostId) ph ON p.Id = ph.PostId\nWHERE \n    p.CreationDate >= cast('2024-10-01' as date) - INTERVAL '1 year' \nORDER BY \n    p.Score DESC, \n    p.CreationDate DESC\nLIMIT 100;", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.Score,\n    p.ViewCount,\n    u.DisplayName AS OwnerDisplayName,\n    u.Reputation AS OwnerReputation,\n    p.AnswerCount\nFROM Posts p\nJOIN Users u ON p.OwnerUserId = u.Id\nWHERE p.CreationDate >= CAST('2024-10-01' AS DATE) - INTERVAL '1' YEAR\nORDER BY p.Score DESC, p.CreationDate DESC\nLIMIT 100;", "sql2": "SELECT \n    s1.PostId,\n    s1.Title,\n    s1.CreationDate,\n    s1.Score,\n    s1.ViewCount,\n    s1.OwnerDisplayName,\n    s1.OwnerReputation,\n    s1.AnswerCount,\n    COALESCE(c.CommentCount, 0) AS CommentCount,\n    COALESCE(pl.LinksCount, 0) AS LinksCount,\n    COALESCE(ph.HistoryCount, 0) AS HistoryCount\nFROM s1\nLEFT JOIN (\n    SELECT PostId, COUNT(*) AS CommentCount\n    FROM Comments\n    WHERE PostId IN (SELECT PostId FROM s1)\n    GROUP BY PostId\n) c ON s1.PostId = c.PostId\nLEFT JOIN (\n    SELECT PostId, COUNT(*) AS LinksCount\n    FROM PostLinks\n    WHERE PostId IN (SELECT PostId FROM s1)\n    GROUP BY PostId\n) pl ON s1.PostId = pl.PostId\nLEFT JOIN (\n    SELECT PostId, COUNT(*) AS HistoryCount\n    FROM PostHistory\n    WHERE PostId IN (SELECT PostId FROM s1)\n    GROUP BY PostId\n) ph ON s1.PostId = ph.PostId\nORDER BY s1.Score DESC, s1.CreationDate DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11363.sql", "original_sql": "\nWITH UserVoteStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(DISTINCT v.Id) AS TotalVotes,\n        SUM(CASE WHEN vt.Name = 'UpMod' THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN vt.Name = 'DownMod' THEN 1 ELSE 0 END) AS DownVotes\n    FROM Users u\n    LEFT JOIN Votes v ON u.Id = v.UserId\n    LEFT JOIN VoteTypes vt ON v.VoteTypeId = vt.Id\n    GROUP BY u.Id, u.DisplayName\n),\nPostActivityStats AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        COUNT(DISTINCT c.Id) AS TotalComments,\n        COUNT(DISTINCT v.Id) AS TotalVotes,\n        SUM(CASE WHEN vt.Name = 'UpMod' THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN vt.Name = 'DownMod' THEN 1 ELSE 0 END) AS DownVotes\n    FROM Posts p\n    LEFT JOIN Comments c ON p.Id = c.PostId\n    LEFT JOIN Votes v ON p.Id = v.PostId\n    LEFT JOIN VoteTypes vt ON v.VoteTypeId = vt.Id\n    GROUP BY p.Id, p.Title\n),\nFinalStats AS (\n    SELECT \n        u.UserId,\n        u.DisplayName,\n        p.PostId,\n        p.Title,\n        us.TotalVotes AS UserTotalVotes,\n        ps.TotalVotes AS PostTotalVotes,\n        ps.TotalComments,\n        ps.UpVotes AS PostUpVotes,\n        ps.DownVotes AS PostDownVotes\n    FROM UserVoteStats u\n    JOIN PostActivityStats p ON u.UserId = p.PostId\n    JOIN UserVoteStats us ON u.UserId = us.UserId\n    JOIN PostActivityStats ps ON p.PostId = ps.PostId\n)\nSELECT \n    fs.DisplayName,\n    fs.Title,\n    fs.UserTotalVotes,\n    fs.PostTotalVotes,\n    fs.TotalComments,\n    fs.PostUpVotes,\n    fs.PostDownVotes\nFROM FinalStats fs\nORDER BY fs.UserTotalVotes DESC, fs.PostTotalVotes DESC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 's1'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"pas\" }), name: \"postid\" }, Column { relation: Some(Bare { table: \"pas\" }), name: \"title\" }, Column { relation: Some(Bare { table: \"pas\" }), name: \"totalcomments\" }, Column { relation: Some(Bare { table: \"pas\" }), name: \"totalvotes\" }, Column { relation: Some(Bare { table: \"pas\" }), name: \"postupvotes\" }, Column { relation: Some(Bare { table: \"pas\" }), name: \"postdownvotes\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "11364.sql", "original_sql": "WITH PostStats AS (\n    SELECT \n        pt.Name AS PostType,\n        COUNT(p.Id) AS PostCount,\n        AVG(p.Score) AS AvgScore,\n        SUM(p.ViewCount) AS TotalViews\n    FROM \n        Posts p\n    JOIN \n        PostTypes pt ON p.PostTypeId = pt.Id\n    GROUP BY \n        pt.Name\n),\nTopUsers AS (\n    SELECT \n        u.DisplayName,\n        u.Reputation,\n        COUNT(b.Id) AS BadgeCount\n    FROM \n        Users u\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    GROUP BY \n        u.DisplayName, u.Reputation\n    ORDER BY \n        u.Reputation DESC\n    LIMIT 10\n)\n\nSELECT \n    ps.PostType,\n    ps.PostCount,\n    ps.AvgScore,\n    ps.TotalViews,\n    tu.DisplayName AS TopUser,\n    tu.Reputation,\n    tu.BadgeCount\nFROM \n    PostStats ps\nCROSS JOIN \n    TopUsers tu\nORDER BY \n    ps.PostType;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH PostStats AS (\n    SELECT \n        pt.Name AS PostType,\n        COUNT(p.Id) AS PostCount,\n        AVG(p.Score) AS AvgScore,\n        SUM(p.ViewCount) AS TotalViews\n    FROM \n        Posts p\n    JOIN \n        PostTypes pt ON p.PostTypeId = pt.Id\n    GROUP BY \n        pt.Name\n)\nSELECT * FROM PostStats;", "sql2": "WITH TopUsers AS (\n    SELECT \n        u.DisplayName,\n        u.Reputation,\n        COUNT(b.Id) AS BadgeCount\n    FROM \n        Users u\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    GROUP BY \n        u.DisplayName, u.Reputation\n    ORDER BY \n        u.Reputation DESC\n    LIMIT 10\n)\nSELECT \n    ps.PostType,\n    ps.PostCount,\n    ps.AvgScore,\n    ps.TotalViews,\n    tu.DisplayName AS TopUser,\n    tu.Reputation,\n    tu.BadgeCount\nFROM \n    s1 ps\nCROSS JOIN \n    TopUsers tu\nORDER BY \n    ps.PostType;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11449.sql", "original_sql": "\nWITH UserPostStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(P.Id) AS TotalPosts,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS Answers,\n        SUM(CASE WHEN P.Score > 0 THEN 1 ELSE 0 END) AS UpvotedPosts\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    GROUP BY \n        U.Id, U.DisplayName\n), \nPostInteractionStats AS (\n    SELECT \n        P.Id AS PostId,\n        P.Title,\n        COUNT(C.Id) AS CommentCount,\n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM \n        Posts P\n    LEFT JOIN \n        Comments C ON P.Id = C.PostId\n    LEFT JOIN \n        Votes V ON P.Id = V.PostId\n    GROUP BY \n        P.Id, P.Title\n) \nSELECT \n    UPS.DisplayName,\n    UPS.TotalPosts,\n    UPS.Questions,\n    UPS.Answers,\n    UPS.UpvotedPosts,\n    PIS.PostId,\n    PIS.Title,\n    PIS.CommentCount,\n    PIS.UpVotes,\n    PIS.DownVotes\nFROM \n    UserPostStats UPS\nJOIN \n    PostInteractionStats PIS ON UPS.UserId = PIS.PostId\nWHERE \n    UPS.TotalPosts > 0\nORDER BY \n    UPS.TotalPosts DESC, PIS.UpVotes DESC\nFETCH FIRST 50 ROWS ONLY;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT \n    P.Id AS PostId,\n    P.Title,\n    COUNT(C.Id) AS CommentCount,\n    SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n    SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\nFROM Posts P\nLEFT JOIN Comments C ON P.Id = C.PostId\nLEFT JOIN Votes V ON P.Id = V.PostId\nGROUP BY P.Id, P.Title", "sql2": "WITH UserPostStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(P.Id) AS TotalPosts,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS Answers,\n        SUM(CASE WHEN P.Score > 0 THEN 1 ELSE 0 END) AS UpvotedPosts\n    FROM Users U\n    LEFT JOIN Posts P ON U.Id = P.OwnerUserId\n    GROUP BY U.Id, U.DisplayName\n)\nSELECT \n    UPS.DisplayName,\n    UPS.TotalPosts,\n    UPS.Questions,\n    UPS.Answers,\n    UPS.UpvotedPosts,\n    s1.PostId,\n    s1.Title,\n    s1.CommentCount,\n    s1.UpVotes,\n    s1.DownVotes\nFROM UserPostStats UPS\nJOIN s1 ON UPS.UserId = s1.PostId\nWHERE UPS.TotalPosts > 0\nORDER BY UPS.TotalPosts DESC, s1.UpVotes DESC\nLIMIT 50;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11477.sql", "original_sql": "WITH PostStatistics AS (\n    SELECT \n        P.Id AS PostId,\n        P.PostTypeId,\n        P.CreationDate,\n        P.Score,\n        P.ViewCount,\n        COUNT(CASE WHEN C.PostId IS NOT NULL THEN 1 END) AS CommentCount,\n        COUNT(CASE WHEN V.PostId IS NOT NULL THEN 1 END) AS VoteCount\n    FROM \n        Posts P\n    LEFT JOIN \n        Comments C ON P.Id = C.PostId\n    LEFT JOIN \n        Votes V ON P.Id = V.PostId\n    GROUP BY \n        P.Id, P.PostTypeId, P.CreationDate, P.Score, P.ViewCount\n),\nUserStatistics AS (\n    SELECT \n        U.Id AS UserId,\n        U.Reputation,\n        COUNT(DISTINCT B.Id) AS BadgeCount,\n        SUM(P.ViewCount) AS UserPostViewCount\n    FROM \n        Users U\n    LEFT JOIN \n        Badges B ON U.Id = B.UserId\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    GROUP BY \n        U.Id, U.Reputation\n)\nSELECT \n    PS.PostId,\n    PS.PostTypeId,\n    PS.CreationDate,\n    PS.Score,\n    PS.ViewCount,\n    PS.CommentCount,\n    PS.VoteCount,\n    US.UserId,\n    US.Reputation,\n    US.BadgeCount,\n    US.UserPostViewCount\nFROM \n    PostStatistics PS\nJOIN \n    Users U ON PS.PostTypeId = U.Id\nJOIN \n    UserStatistics US ON U.Id = US.UserId\nORDER BY \n    PS.ViewCount DESC, PS.Score DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT P.Id AS PostId,\n       P.PostTypeId,\n       P.CreationDate,\n       P.Score,\n       P.ViewCount,\n       COUNT(CASE WHEN C.PostId IS NOT NULL THEN 1 END) AS CommentCount,\n       COUNT(CASE WHEN V.PostId IS NOT NULL THEN 1 END) AS VoteCount\nFROM Posts P\nLEFT JOIN Comments C ON P.Id = C.PostId\nLEFT JOIN Votes V ON P.Id = V.PostId\nGROUP BY P.Id, P.PostTypeId, P.CreationDate, P.Score, P.ViewCount;", "sql2": "WITH UserStatistics AS (\n    SELECT U.Id AS UserId,\n           U.Reputation,\n           COUNT(DISTINCT B.Id) AS BadgeCount,\n           SUM(P.ViewCount) AS UserPostViewCount\n    FROM Users U\n    LEFT JOIN Badges B ON U.Id = B.UserId\n    LEFT JOIN Posts P ON U.Id = P.OwnerUserId\n    GROUP BY U.Id, U.Reputation\n)\nSELECT s1.PostId,\n       s1.PostTypeId,\n       s1.CreationDate,\n       s1.Score,\n       s1.ViewCount,\n       s1.CommentCount,\n       s1.VoteCount,\n       US.UserId,\n       US.Reputation,\n       US.BadgeCount,\n       US.UserPostViewCount\nFROM s1\nJOIN Users U ON s1.PostTypeId = U.Id\nJOIN UserStatistics US ON U.Id = US.UserId\nORDER BY s1.ViewCount DESC, s1.Score DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11507.sql", "original_sql": "\nSELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    u.DisplayName AS OwnerDisplayName,\n    COUNT(c.Id) AS CommentCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n    COUNT(DISTINCT b.Id) AS BadgeCount\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nLEFT JOIN \n    Badges b ON u.Id = b.UserId\nWHERE \n    p.PostTypeId = 1  \nGROUP BY \n    p.Id, p.Title, p.CreationDate, u.DisplayName\nORDER BY \n    p.CreationDate DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT\n    p.Id AS PostId,\n    p.OwnerUserId,\n    COUNT(c.Id) AS CommentCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n    COUNT(DISTINCT b.Id) AS BadgeCount\nFROM Posts p\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Votes v ON p.Id = v.PostId\nLEFT JOIN Badges b ON p.OwnerUserId = b.UserId\nWHERE p.PostTypeId = 1\nGROUP BY p.Id, p.OwnerUserId", "sql2": "SELECT\n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    u.DisplayName AS OwnerDisplayName,\n    s.CommentCount,\n    s.UpVotes,\n    s.DownVotes,\n    s.BadgeCount\nFROM s1 s\nJOIN Posts p ON s.PostId = p.Id\nJOIN Users u ON s.OwnerUserId = u.Id\nORDER BY p.CreationDate DESC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11508.sql", "original_sql": "\nSELECT \n    u.DisplayName AS UserDisplayName,\n    p.Title AS PostTitle,\n    p.CreationDate AS PostCreationDate,\n    p.Score AS PostScore,\n    COUNT(c.Id) AS CommentCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVoteCount,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVoteCount,\n    STRING_AGG(t.TagName, ',') AS Tags\nFROM \n    Users u\nJOIN \n    Posts p ON u.Id = p.OwnerUserId\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nLEFT JOIN \n    PostLinks pl ON pl.PostId = p.Id\nLEFT JOIN \n    Tags t ON t.Id = pl.RelatedPostId\nWHERE \n    p.CreationDate >= '2020-01-01'\nGROUP BY \n    u.DisplayName, p.Title, p.CreationDate, p.Score\nORDER BY \n    p.Score DESC, p.CreationDate DESC;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "11510.sql", "original_sql": "WITH PostDetails AS (\n    SELECT \n        pt.Name AS PostTypeName,\n        COUNT(p.Id) AS PostCount,\n        AVG(p.Score) AS AvgScore,\n        COUNT(DISTINCT v.UserId) AS UserCount\n    FROM \n        Posts p\n    JOIN \n        PostTypes pt ON p.PostTypeId = pt.Id\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    GROUP BY \n        pt.Name\n), \nVoteDetails AS (\n    SELECT \n        vt.Name AS VoteTypeName,\n        COUNT(v.Id) AS VoteCount\n    FROM \n        Votes v\n    JOIN \n        VoteTypes vt ON v.VoteTypeId = vt.Id\n    GROUP BY \n        vt.Name\n)\n\nSELECT \n    pd.PostTypeName,\n    pd.PostCount,\n    pd.AvgScore,\n    pd.UserCount,\n    vd.VoteTypeName,\n    vd.VoteCount\nFROM \n    PostDetails pd\nCROSS JOIN \n    VoteDetails vd\nORDER BY \n    pd.PostTypeName, vd.VoteTypeName;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT pt.Name AS PostTypeName,\n       COUNT(p.Id) AS PostCount,\n       AVG(p.Score) AS AvgScore,\n       COUNT(DISTINCT v.UserId) AS UserCount\nFROM Posts p\nJOIN PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN Votes v ON p.Id = v.PostId\nGROUP BY pt.Name;", "sql2": "SELECT s1.PostTypeName,\n       s1.PostCount,\n       s1.AvgScore,\n       s1.UserCount,\n       vd.VoteTypeName,\n       vd.VoteCount\nFROM s1\nCROSS JOIN (\n    SELECT vt.Name AS VoteTypeName,\n           COUNT(v.Id) AS VoteCount\n    FROM Votes v\n    JOIN VoteTypes vt ON v.VoteTypeId = vt.Id\n    GROUP BY vt.Name\n) vd\nORDER BY s1.PostTypeName, vd.VoteTypeName;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11593.sql", "original_sql": "WITH PostStats AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.Score,\n        p.ViewCount,\n        p.AnswerCount,\n        p.CommentCount,\n        p.CreationDate,\n        COUNT(c.Id) AS TotalComments,\n        COUNT(v.Id) AS TotalVotes\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    GROUP BY \n        p.Id, p.Title, p.Score, p.ViewCount, p.AnswerCount, p.CommentCount, p.CreationDate\n),\nUserActivity AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(p.Id) AS TotalPosts,\n        SUM(COALESCE(p.Score, 0)) AS TotalScore,\n        SUM(COALESCE(c.Id, 0)) AS TotalComments,\n        SUM(COALESCE(v.Id, 0)) AS TotalVotes\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    GROUP BY \n        u.Id, u.DisplayName\n)\nSELECT \n    PS.PostId,\n    PS.Title,\n    PS.Score,\n    PS.ViewCount,\n    PS.AnswerCount,\n    PS.CommentCount,\n    PS.TotalComments,\n    PS.TotalVotes,\n    UA.UserId,\n    UA.DisplayName,\n    UA.TotalPosts,\n    UA.TotalScore,\n    UA.TotalComments AS UserTotalComments,\n    UA.TotalVotes AS UserTotalVotes\nFROM \n    PostStats PS\nJOIN \n    UserActivity UA ON PS.PostId = UA.TotalPosts\nORDER BY \n    PS.Score DESC, PS.ViewCount DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    p.Id AS PostId,\n    p.Title,\n    p.Score,\n    p.ViewCount,\n    p.AnswerCount,\n    p.CommentCount,\n    p.CreationDate,\n    COUNT(c.Id) AS TotalComments,\n    COUNT(v.Id) AS TotalVotes\nFROM Posts p\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Votes v ON p.Id = v.PostId\nGROUP BY p.Id, p.Title, p.Score, p.ViewCount, p.AnswerCount, p.CommentCount, p.CreationDate", "sql2": "WITH UserActivity AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(p.Id) AS TotalPosts,\n        SUM(COALESCE(p.Score, 0)) AS TotalScore,\n        SUM(COALESCE(c.Id, 0)) AS TotalComments,\n        SUM(COALESCE(v.Id, 0)) AS TotalVotes\n    FROM Users u\n    LEFT JOIN Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN Comments c ON p.Id = c.PostId\n    LEFT JOIN Votes v ON p.Id = v.PostId\n    GROUP BY u.Id, u.DisplayName\n)\nSELECT \n    s1.PostId,\n    s1.Title,\n    s1.Score,\n    s1.ViewCount,\n    s1.AnswerCount,\n    s1.CommentCount,\n    s1.TotalComments,\n    s1.TotalVotes,\n    ua.UserId,\n    ua.DisplayName,\n    ua.TotalPosts,\n    ua.TotalScore,\n    ua.TotalComments AS UserTotalComments,\n    ua.TotalVotes AS UserTotalVotes\nFROM s1\nJOIN UserActivity ua ON s1.PostId = ua.TotalPosts\nORDER BY s1.Score DESC, s1.ViewCount DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "11605.sql", "original_sql": "\nSELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.Score,\n    p.ViewCount,\n    u.DisplayName AS OwnerDisplayName,\n    COUNT(c.Id) AS CommentCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n    COUNT(b.Id) AS BadgeCount\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nLEFT JOIN \n    Badges b ON u.Id = b.UserId\nWHERE \n    p.CreationDate >= '2021-01-01' \nGROUP BY \n    p.Id, p.Title, p.CreationDate, p.Score, p.ViewCount, u.DisplayName\nORDER BY \n    p.Score DESC, p.CreationDate DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT p.Id AS PostId,\n       COUNT(c.Id) AS CommentCount,\n       SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n       SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\nFROM Posts p\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Votes v ON p.Id = v.PostId\nWHERE p.CreationDate >= '2021-01-01'\nGROUP BY p.Id;", "sql2": "SELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.Score,\n    p.ViewCount,\n    u.DisplayName AS OwnerDisplayName,\n    COALESCE(s1.CommentCount,0) AS CommentCount,\n    COALESCE(s1.UpVotes,0) AS UpVotes,\n    COALESCE(s1.DownVotes,0) AS DownVotes,\n    COALESCE(bc.BadgeCount,0) AS BadgeCount\nFROM Posts p\nJOIN Users u ON p.OwnerUserId = u.Id\nLEFT JOIN s1 ON p.Id = s1.PostId\nLEFT JOIN (\n    SELECT UserId, COUNT(Id) AS BadgeCount\n    FROM Badges\n    GROUP BY UserId\n) bc ON u.Id = bc.UserId\nWHERE p.CreationDate >= '2021-01-01'\nORDER BY p.Score DESC, p.CreationDate DESC\nLIMIT 100;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "11621.sql", "original_sql": "\nWITH UserActivity AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(DISTINCT p.Id) AS TotalPosts,\n        COUNT(DISTINCT c.Id) AS TotalComments,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalDownVotes,\n        MAX(p.CreationDate) AS LastPostDate\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId AND v.UserId = u.Id\n    GROUP BY \n        u.Id, u.DisplayName\n), PostStatistics AS (\n    SELECT \n        pt.Name AS PostType,\n        COUNT(p.Id) AS TotalPosts,\n        AVG(p.Score) AS AverageScore,\n        AVG(p.ViewCount) AS AverageViewCount,\n        SUM(p.AnswerCount) AS TotalAnswers,\n        SUM(p.CommentCount) AS TotalComments\n    FROM \n        Posts p\n    JOIN \n        PostTypes pt ON p.PostTypeId = pt.Id\n    GROUP BY \n        pt.Name\n)\nSELECT \n    ua.UserId,\n    ua.DisplayName,\n    ua.TotalPosts,\n    ua.TotalComments,\n    ua.TotalUpVotes,\n    ua.TotalDownVotes,\n    ua.LastPostDate,\n    ps.PostType,\n    ps.TotalPosts AS posts_per_type,\n    ps.AverageScore,\n    ps.AverageViewCount,\n    ps.TotalAnswers,\n    ps.TotalComments AS comments_per_type\nFROM \n    UserActivity ua\nCROSS JOIN \n    PostStatistics ps\nORDER BY \n    ua.TotalPosts DESC, ua.TotalUpVotes DESC;\n", "status": "timeout", "exitcode": -15, "signal": 15, "engine_mem_mb": 500000}
{"query_id": "11648.sql", "original_sql": "WITH UserPostStats AS (\n    SELECT\n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(P.Id) AS TotalPosts,\n        COALESCE(AVG(P.Score), 0) AS AverageScore,\n        COALESCE(SUM(V.Id), 0) AS TotalVotes\n    FROM\n        Users U\n    LEFT JOIN\n        Posts P ON U.Id = P.OwnerUserId\n    LEFT JOIN\n        Votes V ON P.Id = V.PostId\n    GROUP BY\n        U.Id, U.DisplayName\n)\n\nSELECT\n    UserId,\n    DisplayName,\n    TotalPosts,\n    AverageScore,\n    TotalVotes\nFROM\n    UserPostStats\nORDER BY\n    TotalPosts DESC, AverageScore DESC;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 231, in run\n    self._register_downstream_aliases(nid, tbl, id_to_node, adj)\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 169, in _register_downstream_aliases\n    self._register_input_duckdb(alias, tbl)\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 81, in _register_input_duckdb\n    self.con.register(name, obj)\nduckdb.duckdb.InvalidInputException: Invalid Input Error: Provided table/dataframe must have at least one column\n", "engine_mem_mb": 500000}
{"query_id": "11661.sql", "original_sql": "\nWITH PostStats AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.PostTypeId,\n        COUNT(c.Id) AS CommentCount,\n        COALESCE(SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END), 0) AS UpVoteCount,\n        COALESCE(SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END), 0) AS DownVoteCount,\n        COUNT(b.Id) AS BadgeCount\n    FROM \n        Posts p\n        LEFT JOIN Comments c ON p.Id = c.PostId\n        LEFT JOIN Votes v ON p.Id = v.PostId\n        LEFT JOIN Badges b ON p.OwnerUserId = b.UserId\n    GROUP BY \n        p.Id, p.Title, p.PostTypeId\n),\nUserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(DISTINCT p.Id) AS PostedCount,\n        SUM(COALESCE(p.ViewCount, 0)) AS TotalViews,\n        SUM(COALESCE(p.Score, 0)) AS TotalScore\n    FROM \n        Users u\n        LEFT JOIN Posts p ON u.Id = p.OwnerUserId\n    GROUP BY \n        u.Id, u.DisplayName\n)\nSELECT \n    ps.PostId,\n    ps.Title,\n    ps.PostTypeId,\n    ps.CommentCount,\n    ps.UpVoteCount,\n    ps.DownVoteCount,\n    us.UserId,\n    us.DisplayName,\n    us.PostedCount,\n    us.TotalViews,\n    us.TotalScore\nFROM \n    PostStats ps\nJOIN \n    UserStats us ON ps.PostTypeId = 1 AND us.UserId = ps.PostId \nORDER BY \n    ps.UpVoteCount DESC, ps.CommentCount DESC, us.TotalScore DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    p.Id AS PostId,\n    p.Title,\n    p.PostTypeId,\n    COUNT(c.Id) AS CommentCount,\n    COALESCE(SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END), 0) AS UpVoteCount,\n    COALESCE(SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END), 0) AS DownVoteCount,\n    COUNT(b.Id) AS BadgeCount\nFROM Posts p\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Votes v ON p.Id = v.PostId\nLEFT JOIN Badges b ON p.OwnerUserId = b.UserId\nGROUP BY p.Id, p.Title, p.PostTypeId;", "sql2": "WITH UserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(DISTINCT p.Id) AS PostedCount,\n        SUM(COALESCE(p.ViewCount, 0)) AS TotalViews,\n        SUM(COALESCE(p.Score, 0)) AS TotalScore\n    FROM Users u\n    LEFT JOIN Posts p ON u.Id = p.OwnerUserId\n    GROUP BY u.Id, u.DisplayName\n)\nSELECT \n    s1.PostId,\n    s1.Title,\n    s1.PostTypeId,\n    s1.CommentCount,\n    s1.UpVoteCount,\n    s1.DownVoteCount,\n    us.UserId,\n    us.DisplayName,\n    us.PostedCount,\n    us.TotalViews,\n    us.TotalScore\nFROM s1\nJOIN UserStats us ON s1.PostTypeId = 1 AND us.UserId = s1.PostId\nORDER BY s1.UpVoteCount DESC, s1.CommentCount DESC, us.TotalScore DESC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "11727.sql", "original_sql": "\nWITH UserPostStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(P.Id) AS PostCount,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        SUM(P.ViewCount) AS TotalViews,\n        SUM(P.Score) AS TotalScore,\n        AVG(EXTRACT(EPOCH FROM P.CreationDate)) AS AvgPostAge\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    GROUP BY \n        U.Id, U.DisplayName\n),\nPostFeatureStats AS (\n    SELECT \n        P.Id AS PostId,\n        P.Title,\n        P.CreationDate,\n        P.ViewCount,\n        P.Score,\n        C.CommentCount,\n        PH.RevisionCount,\n        P.OwnerUserId\n    FROM \n        Posts P\n    LEFT JOIN \n        (SELECT PostId, COUNT(*) AS CommentCount FROM Comments GROUP BY PostId) C ON P.Id = C.PostId\n    LEFT JOIN \n        (SELECT PostId, COUNT(*) AS RevisionCount FROM PostHistory GROUP BY PostId) PH ON P.Id = PH.PostId\n)\nSELECT \n    U.UserId,\n    U.DisplayName,\n    U.PostCount,\n    U.QuestionCount,\n    U.AnswerCount,\n    U.TotalViews,\n    U.TotalScore,\n    U.AvgPostAge,\n    PFS.PostId,\n    PFS.Title,\n    PFS.CreationDate,\n    PFS.ViewCount,\n    PFS.Score,\n    PFS.CommentCount,\n    PFS.RevisionCount\nFROM \n    UserPostStats U\nJOIN \n    PostFeatureStats PFS ON U.UserId = PFS.OwnerUserId\nORDER BY \n    U.PostCount DESC, U.TotalScore DESC;\n", "status": "split_timeout", "engine_mem_mb": 500000}
{"query_id": "11911.sql", "original_sql": "SELECT \n    pt.Name AS PostTypeName,\n    COUNT(p.Id) AS TotalPosts,\n    AVG(p.Score) AS AverageScore,\n    COUNT(DISTINCT p.OwnerUserId) AS UniqueUsers\nFROM \n    Posts p\nJOIN \n    PostTypes pt ON p.PostTypeId = pt.Id\nGROUP BY \n    pt.Name\nORDER BY \n    TotalPosts DESC;", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "11929.sql", "original_sql": "\nSELECT \n    pt.Name AS PostType, \n    COUNT(p.Id) AS TotalPosts, \n    COALESCE(AVG(p.ViewCount), 0) AS AvgViewCount, \n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUpVotes, \n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalDownVotes \nFROM \n    Posts p\nJOIN \n    PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nGROUP BY \n    pt.Name\nORDER BY \n    TotalPosts DESC;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "12000.sql", "original_sql": "WITH UserPostStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(P.Id) AS PostCount,\n        SUM(COALESCE(P.Score, 0)) AS TotalScore,\n        SUM(COALESCE(P.ViewCount, 0)) AS TotalViews,\n        SUM(COALESCE(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END, 0)) AS QuestionCount,\n        SUM(COALESCE(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END, 0)) AS AnswerCount\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    GROUP BY \n        U.Id, U.DisplayName\n),\nPostHistoryStats AS (\n    SELECT \n        PH.PostId,\n        COUNT(PH.Id) AS EditCount,\n        SUM(CASE WHEN PHT.Name = 'Edit Body' THEN 1 ELSE 0 END) AS BodyEdits,\n        SUM(CASE WHEN PHT.Name = 'Edit Title' THEN 1 ELSE 0 END) AS TitleEdits\n    FROM \n        PostHistory PH\n    JOIN \n        PostHistoryTypes PHT ON PH.PostHistoryTypeId = PHT.Id\n    GROUP BY \n        PH.PostId\n)\nSELECT \n    UPS.UserId,\n    UPS.DisplayName,\n    UPS.PostCount,\n    UPS.TotalScore,\n    UPS.TotalViews,\n    UPS.QuestionCount,\n    UPS.AnswerCount,\n    PHS.EditCount,\n    PHS.BodyEdits,\n    PHS.TitleEdits\nFROM \n    UserPostStats UPS\nLEFT JOIN \n    PostHistoryStats PHS ON UPS.UserId = PHS.PostId\nORDER BY \n    UPS.TotalScore DESC\nLIMIT 100;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 's1'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"phs\" }), name: \"postid\" }, Column { relation: Some(Bare { table: \"phs\" }), name: \"editcount\" }, Column { relation: Some(Bare { table: \"phs\" }), name: \"bodyedits\" }, Column { relation: Some(Bare { table: \"phs\" }), name: \"titleedits\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "12020.sql", "original_sql": "\nWITH PostStatistics AS (\n    SELECT\n        P.PostTypeId,\n        COUNT(P.Id) AS PostCount,\n        AVG(P.Score) AS AvgScore,\n        SUM(P.ViewCount) AS TotalViews,\n        SUM(P.AnswerCount) AS TotalAnswers,\n        SUM(P.CommentCount) AS TotalComments,\n        SUM(P.FavoriteCount) AS TotalFavorites,\n        MAX(P.CreationDate) AS LastPostDate\n    FROM\n        Posts P\n    WHERE\n        P.CreationDate >= TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '1 year'  \n    GROUP BY\n        P.PostTypeId\n),\nUserEngagement AS (\n    SELECT\n        U.Id AS UserId,\n        U.Reputation,\n        COUNT(DISTINCT P.Id) AS TotalPosts,\n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUpVotes,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalDownVotes\n    FROM\n        Users U\n    LEFT JOIN Posts P ON U.Id = P.OwnerUserId\n    LEFT JOIN Votes V ON P.Id = V.PostId\n    GROUP BY \n        U.Id, U.Reputation\n)\n\nSELECT\n    PST.PostTypeId,\n    PST.PostCount,\n    PST.AvgScore,\n    PST.TotalViews,\n    PST.TotalAnswers,\n    PST.TotalComments,\n    PST.TotalFavorites,\n    PST.LastPostDate,\n    SUM(UE.TotalPosts) AS TotalUserPosts,\n    AVG(UE.Reputation) AS AvgUserReputation,\n    SUM(UE.TotalUpVotes) AS TotalUserUpVotes,\n    SUM(UE.TotalDownVotes) AS TotalUserDownVotes\nFROM\n    PostStatistics PST\nJOIN\n    UserEngagement UE ON PST.PostCount > 0  \nGROUP BY\n    PST.PostTypeId, PST.PostCount, PST.AvgScore, PST.TotalViews,\n    PST.TotalAnswers, PST.TotalComments, PST.TotalFavorites, PST.LastPostDate\nORDER BY\n    PST.PostTypeId;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    P.PostTypeId,\n    COUNT(P.Id) AS PostCount,\n    AVG(P.Score) AS AvgScore,\n    SUM(P.ViewCount) AS TotalViews,\n    SUM(P.AnswerCount) AS TotalAnswers,\n    SUM(P.CommentCount) AS TotalComments,\n    SUM(P.FavoriteCount) AS TotalFavorites,\n    MAX(P.CreationDate) AS LastPostDate\nFROM Posts P\nWHERE P.CreationDate >= TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '1 year'\nGROUP BY P.PostTypeId;", "sql2": "SELECT\n    s1.PostTypeId,\n    s1.PostCount,\n    s1.AvgScore,\n    s1.TotalViews,\n    s1.TotalAnswers,\n    s1.TotalComments,\n    s1.TotalFavorites,\n    s1.LastPostDate,\n    ue_totals.TotalUserPosts,\n    ue_totals.AvgUserReputation,\n    ue_totals.TotalUserUpVotes,\n    ue_totals.TotalUserDownVotes\nFROM s1\nCROSS JOIN (\n    SELECT\n        SUM(u.TotalPosts) AS TotalUserPosts,\n        AVG(u.Reputation) AS AvgUserReputation,\n        SUM(u.TotalUpVotes) AS TotalUserUpVotes,\n        SUM(u.TotalDownVotes) AS TotalUserDownVotes\n    FROM (\n        SELECT\n            U.Id AS UserId,\n            U.Reputation,\n            COUNT(DISTINCT P.Id) AS TotalPosts,\n            SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUpVotes,\n            SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalDownVotes\n        FROM Users U\n        LEFT JOIN Posts P ON U.Id = P.OwnerUserId\n        LEFT JOIN Votes V ON P.Id = V.PostId\n        GROUP BY U.Id, U.Reputation\n    ) AS u\n) AS ue_totals\nORDER BY s1.PostTypeId;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "12149.sql", "original_sql": "\nSELECT \n    U.Id AS UserId,\n    U.DisplayName,\n    U.Reputation,\n    COUNT(DISTINCT P.Id) AS TotalPosts,\n    COUNT(DISTINCT C.Id) AS TotalComments,\n    SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUpVotes,\n    SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalDownVotes,\n    SUM(CASE WHEN B.Id IS NOT NULL THEN 1 ELSE 0 END) AS TotalBadges\nFROM \n    Users U\nLEFT JOIN \n    Posts P ON U.Id = P.OwnerUserId\nLEFT JOIN \n    Comments C ON P.Id = C.PostId\nLEFT JOIN \n    Votes V ON P.Id = V.PostId\nLEFT JOIN \n    Badges B ON U.Id = B.UserId\nWHERE \n    U.Reputation > 0 \nGROUP BY \n    U.Id, U.DisplayName, U.Reputation\nORDER BY \n    TotalPosts DESC, U.Reputation DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH posts_agg AS (\n    SELECT OwnerUserId AS UserId, COUNT(*) AS TotalPosts\n    FROM Posts\n    WHERE OwnerUserId IS NOT NULL\n    GROUP BY OwnerUserId\n),\ncomments_agg AS (\n    SELECT P.OwnerUserId AS UserId, COUNT(*) AS TotalComments\n    FROM Posts P\n    JOIN Comments C ON P.Id = C.PostId\n    GROUP BY P.OwnerUserId\n),\nvotes_agg AS (\n    SELECT P.OwnerUserId AS UserId,\n           SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUpVotes,\n           SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalDownVotes\n    FROM Posts P\n    JOIN Votes V ON P.Id = V.PostId\n    GROUP BY P.OwnerUserId\n),\nbadges_agg AS (\n    SELECT UserId, COUNT(*) AS TotalBadges\n    FROM Badges\n    GROUP BY UserId\n)\nSELECT\n    U.Id AS UserId,\n    U.DisplayName,\n    U.Reputation,\n    COALESCE(p.TotalPosts, 0) AS TotalPosts,\n    COALESCE(c.TotalComments, 0) AS TotalComments,\n    COALESCE(v.TotalUpVotes, 0) AS TotalUpVotes,\n    COALESCE(v.TotalDownVotes, 0) AS TotalDownVotes,\n    COALESCE(b.TotalBadges, 0) AS TotalBadges\nFROM Users U\nLEFT JOIN posts_agg p ON U.Id = p.UserId\nLEFT JOIN comments_agg c ON U.Id = c.UserId\nLEFT JOIN votes_agg v ON U.Id = v.UserId\nLEFT JOIN badges_agg b ON U.Id = b.UserId\nWHERE U.Reputation > 0;", "sql2": "SELECT *\nFROM s1\nORDER BY TotalPosts DESC, Reputation DESC\nLIMIT 100;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "12170.sql", "original_sql": "SELECT \n    pt.Name AS PostType,\n    COUNT(p.Id) AS TotalPosts,\n    AVG(p.Score) AS AverageScore,\n    SUM(p.ViewCount) AS TotalViews,\n    AVG(p.AnswerCount) AS AverageAnswerCount,\n    AVG(p.CommentCount) AS AverageCommentCount,\n    AVG(p.FavoriteCount) AS AverageFavoriteCount,\n    COUNT(DISTINCT p.OwnerUserId) AS UniqueUsers\nFROM \n    Posts p\nJOIN \n    PostTypes pt ON p.PostTypeId = pt.Id\nGROUP BY \n    pt.Name\nORDER BY \n    TotalPosts DESC;", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "12171.sql", "original_sql": "WITH PostAggregates AS (\n    SELECT \n        p.Id AS PostId,\n        p.PostTypeId,\n        COUNT(c.Id) AS TotalComments,\n        COUNT(v.Id) AS TotalVotes,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n        SUM(CASE WHEN v.VoteTypeId = 10 THEN 1 ELSE 0 END) AS DeletionVotes\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    WHERE \n        p.CreationDate >= cast('2024-10-01 12:34:56' as timestamp) - INTERVAL '1 year'  \n    GROUP BY \n        p.Id, p.PostTypeId\n),\nUserEngagement AS (\n    SELECT \n        u.Id AS UserId,\n        SUM(p.ViewCount) AS TotalPostViews,\n        COUNT(DISTINCT p.Id) AS PostsCreated\n    FROM \n        Users u\n    JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    WHERE \n        u.CreationDate >= cast('2024-10-01 12:34:56' as timestamp) - INTERVAL '1 year'  \n    GROUP BY \n        u.Id\n)\n\nSELECT \n    pa.PostId,\n    pa.PostTypeId,\n    pa.TotalComments,\n    pa.TotalVotes,\n    pa.UpVotes,\n    pa.DownVotes,\n    pa.DeletionVotes,\n    ueng.UserId,\n    ueng.TotalPostViews,\n    ueng.PostsCreated\nFROM \n    PostAggregates pa\nJOIN \n    UserEngagement ueng ON pa.PostId = ueng.UserId  \nORDER BY \n    pa.TotalVotes DESC, pa.TotalComments DESC;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'postid' not found in 's1'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"postid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"ue\" }), name: \"userid\" }, Column { relation: Some(Bare { table: \"ue\" }), name: \"totalpostviews\" }, Column { relation: Some(Bare { table: \"ue\" }), name: \"postscreated\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "12174.sql", "original_sql": "\nSELECT \n    P.Id AS PostId,\n    P.Title,\n    P.CreationDate,\n    P.Score,\n    P.ViewCount,\n    P.AnswerCount,\n    P.CommentCount,\n    U.DisplayName AS OwnerDisplayName,\n    U.Reputation AS OwnerReputation,\n    PH.PostHistoryTypeId,\n    PH.CreationDate AS PostHistoryDate,\n    COUNT(V.Id) AS VoteCount,\n    SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n    SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n    SUM(CASE WHEN B.Id IS NOT NULL THEN 1 ELSE 0 END) AS BadgeCount\nFROM \n    Posts P\nJOIN \n    Users U ON P.OwnerUserId = U.Id\nLEFT JOIN \n    PostHistory PH ON P.Id = PH.PostId\nLEFT JOIN \n    Votes V ON P.Id = V.PostId\nLEFT JOIN \n    Badges B ON U.Id = B.UserId\nWHERE \n    P.CreationDate >= DATE '2023-01-01'\nGROUP BY \n    P.Id, P.Title, P.CreationDate, P.Score, P.ViewCount, P.AnswerCount, P.CommentCount, \n    U.Id, U.DisplayName, U.Reputation, PH.PostHistoryTypeId, PH.CreationDate\nORDER BY \n    P.CreationDate DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH vote_agg AS (\n  SELECT P.Id AS PostId,\n         COUNT(V.Id) AS VoteCount,\n         SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n         SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n         P.OwnerUserId AS OwnerUserId\n  FROM Posts P\n  LEFT JOIN Votes V ON P.Id = V.PostId\n  GROUP BY P.Id, P.OwnerUserId\n),\nbadge_agg AS (\n  SELECT U.Id AS OwnerUserId,\n         COUNT(B.Id) AS BadgeCount\n  FROM Users U\n  LEFT JOIN Badges B ON U.Id = B.UserId\n  GROUP BY U.Id\n)\nSELECT v.PostId,\n       v.VoteCount,\n       v.UpVotes,\n       v.DownVotes,\n       v.OwnerUserId,\n       COALESCE(b.BadgeCount, 0) AS BadgeCount\nFROM vote_agg v\nLEFT JOIN badge_agg b ON v.OwnerUserId = b.OwnerUserId;", "sql2": "SELECT \n    P.Id AS PostId,\n    P.Title,\n    P.CreationDate,\n    P.Score,\n    P.ViewCount,\n    P.AnswerCount,\n    P.CommentCount,\n    U.DisplayName AS OwnerDisplayName,\n    U.Reputation AS OwnerReputation,\n    PH.PostHistoryTypeId,\n    PH.CreationDate AS PostHistoryDate,\n    s.VoteCount,\n    s.UpVotes,\n    s.DownVotes,\n    s.BadgeCount\nFROM Posts P\nJOIN Users U ON P.OwnerUserId = U.Id\nLEFT JOIN PostHistory PH ON P.Id = PH.PostId\nJOIN s1 s ON P.Id = s.PostId\nWHERE P.CreationDate >= DATE '2023-01-01'\nORDER BY P.CreationDate DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "12205.sql", "original_sql": "WITH UserPostStats AS (\n    SELECT \n        u.Id AS UserId,\n        COUNT(DISTINCT p.Id) AS PostCount,\n        COUNT(DISTINCT v.Id) AS VoteCount,\n        COUNT(DISTINCT c.Id) AS CommentCount\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    GROUP BY \n        u.Id\n)\n\nSELECT \n    u.DisplayName,\n    ups.PostCount,\n    ups.VoteCount,\n    ups.CommentCount\nFROM \n    UserPostStats ups\nJOIN \n    Users u ON ups.UserId = u.Id\nORDER BY \n    ups.PostCount DESC, \n    ups.VoteCount DESC,\n    ups.CommentCount DESC\nLIMIT 100;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT u.Id AS UserId,\n       COUNT(DISTINCT p.Id) AS PostCount,\n       COUNT(DISTINCT v.Id) AS VoteCount,\n       COUNT(DISTINCT c.Id) AS CommentCount\nFROM Users u\nLEFT JOIN Posts p ON u.Id = p.OwnerUserId\nLEFT JOIN Votes v ON p.Id = v.PostId\nLEFT JOIN Comments c ON p.Id = c.PostId\nGROUP BY u.Id;", "sql2": "SELECT u.DisplayName,\n       s1.PostCount,\n       s1.VoteCount,\n       s1.CommentCount\nFROM s1\nJOIN Users u ON s1.UserId = u.Id\nORDER BY s1.PostCount DESC,\n         s1.VoteCount DESC,\n         s1.CommentCount DESC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "12246.sql", "original_sql": "WITH PostMetrics AS (\n    SELECT \n        pt.Name AS PostType,\n        COUNT(p.Id) AS PostCount,\n        AVG(p.ViewCount) AS AvgViewCount,\n        AVG(p.Score) AS AvgScore\n    FROM \n        Posts p\n    JOIN \n        PostTypes pt ON p.PostTypeId = pt.Id\n    GROUP BY \n        pt.Name\n),\nUserMetrics AS (\n    SELECT \n        u.Id AS UserId,\n        u.Reputation,\n        u.CreationDate,\n        COUNT(p.Id) AS PostsCount\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    GROUP BY \n        u.Id, u.Reputation, u.CreationDate\n)\nSELECT \n    pm.PostType,\n    pm.PostCount,\n    pm.AvgViewCount,\n    pm.AvgScore,\n    um.UserId,\n    um.Reputation,\n    um.CreationDate,\n    um.PostsCount\nFROM \n    PostMetrics pm\nJOIN \n    UserMetrics um ON um.PostsCount > 0\nORDER BY \n    pm.PostType;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT pt.Name AS PostType,\n       COUNT(p.Id) AS PostCount,\n       AVG(p.ViewCount) AS AvgViewCount,\n       AVG(p.Score) AS AvgScore\nFROM Posts p\nJOIN PostTypes pt ON p.PostTypeId = pt.Id\nGROUP BY pt.Name;", "sql2": "SELECT s1.PostType,\n       s1.PostCount,\n       s1.AvgViewCount,\n       s1.AvgScore,\n       um.UserId,\n       um.Reputation,\n       um.CreationDate,\n       um.PostsCount\nFROM s1\nJOIN (\n    SELECT u.Id AS UserId,\n           u.Reputation,\n           u.CreationDate,\n           COUNT(p.Id) AS PostsCount\n    FROM Users u\n    LEFT JOIN Posts p ON u.Id = p.OwnerUserId\n    GROUP BY u.Id, u.Reputation, u.CreationDate\n) um ON um.PostsCount > 0\nORDER BY s1.PostType;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "12285.sql", "original_sql": "SELECT \n    u.Id AS UserId,\n    u.DisplayName,\n    COUNT(p.Id) AS TotalPosts,\n    AVG(COALESCE(p.Score, 0)) AS AverageScore,\n    COUNT(c.Id) AS TotalComments\nFROM \n    Users u\nLEFT JOIN \n    Posts p ON u.Id = p.OwnerUserId\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nGROUP BY \n    u.Id, u.DisplayName\nORDER BY \n    TotalPosts DESC, AverageScore DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT u.Id AS UserId,\n       u.DisplayName,\n       COUNT(p.Id) AS TotalPosts,\n       SUM(COALESCE(p.Score,0)) AS SumScore\nFROM Users u\nLEFT JOIN Posts p ON u.Id = p.OwnerUserId\nGROUP BY u.Id, u.DisplayName;", "sql2": "SELECT s1.UserId,\n       s1.DisplayName,\n       s1.TotalPosts,\n       CASE WHEN s1.TotalPosts > 0 THEN CAST(s1.SumScore AS DOUBLE) / s1.TotalPosts ELSE NULL END AS AverageScore,\n       COALESCE(cagg.TotalComments,0) AS TotalComments\nFROM s1\nLEFT JOIN (\n    SELECT u.Id AS UserId,\n           COUNT(c.Id) AS TotalComments\n    FROM Users u\n    LEFT JOIN Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN Comments c ON p.Id = c.PostId\n    GROUP BY u.Id\n) AS cagg ON s1.UserId = cagg.UserId\nORDER BY s1.TotalPosts DESC, AverageScore DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "12311.sql", "original_sql": "\nWITH UserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.Reputation,\n        u.CreationDate,\n        COUNT(DISTINCT p.Id) AS PostCount,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        SUM(p.ViewCount) AS TotalViews,\n        SUM(p.Score) AS TotalScore\n    FROM Users u\n    LEFT JOIN Posts p ON u.Id = p.OwnerUserId\n    GROUP BY u.Id, u.Reputation, u.CreationDate\n),\nBadgeStats AS (\n    SELECT \n        b.UserId,\n        COUNT(*) AS BadgeCount,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Badges b\n    GROUP BY b.UserId\n),\nCombinedStats AS (\n    SELECT \n        u.UserId,\n        u.Reputation,\n        u.CreationDate,\n        u.PostCount,\n        u.QuestionCount,\n        u.AnswerCount,\n        u.TotalViews,\n        u.TotalScore,\n        COALESCE(b.BadgeCount, 0) AS BadgeCount,\n        COALESCE(b.GoldBadges, 0) AS GoldBadges,\n        COALESCE(b.SilverBadges, 0) AS SilverBadges,\n        COALESCE(b.BronzeBadges, 0) AS BronzeBadges\n    FROM UserStats u\n    LEFT JOIN BadgeStats b ON u.UserId = b.UserId\n)\nSELECT \n    UserId,\n    Reputation,\n    CreationDate,\n    PostCount,\n    QuestionCount,\n    AnswerCount,\n    TotalViews,\n    TotalScore,\n    BadgeCount,\n    GoldBadges,\n    SilverBadges,\n    BronzeBadges\nFROM CombinedStats\nORDER BY Reputation DESC\nFETCH FIRST 10 ROWS ONLY;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    u.Id AS UserId,\n    u.Reputation,\n    u.CreationDate,\n    COUNT(DISTINCT p.Id) AS PostCount,\n    SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n    SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n    SUM(p.ViewCount) AS TotalViews,\n    SUM(p.Score) AS TotalScore\nFROM Users u\nLEFT JOIN Posts p ON u.Id = p.OwnerUserId\nGROUP BY u.Id, u.Reputation, u.CreationDate", "sql2": "SELECT \n    s1.UserId,\n    s1.Reputation,\n    s1.CreationDate,\n    s1.PostCount,\n    s1.QuestionCount,\n    s1.AnswerCount,\n    s1.TotalViews,\n    s1.TotalScore,\n    COALESCE(b.BadgeCount, 0) AS BadgeCount,\n    COALESCE(b.GoldBadges, 0) AS GoldBadges,\n    COALESCE(b.SilverBadges, 0) AS SilverBadges,\n    COALESCE(b.BronzeBadges, 0) AS BronzeBadges\nFROM s1\nLEFT JOIN (\n    SELECT \n        b.UserId,\n        COUNT(*) AS BadgeCount,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Badges b\n    GROUP BY b.UserId\n) b ON s1.UserId = b.UserId\nORDER BY s1.Reputation DESC\nLIMIT 10", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "12350.sql", "original_sql": "\nWITH PostAnalytics AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        p.ViewCount,\n        p.Score,\n        u.DisplayName AS OwnerDisplayName,\n        COUNT(c.Id) AS CommentCount,\n        COUNT(b.Id) AS BadgeCount,\n        MAX(ph.CreationDate) AS LastHistoryUpdate\n    FROM Posts p\n    LEFT JOIN Users u ON p.OwnerUserId = u.Id\n    LEFT JOIN Comments c ON p.Id = c.PostId\n    LEFT JOIN Badges b ON u.Id = b.UserId\n    LEFT JOIN PostHistory ph ON p.Id = ph.PostId\n    GROUP BY p.Id, p.Title, p.CreationDate, p.ViewCount, p.Score, u.DisplayName\n),\nVoteAnalytics AS (\n    SELECT \n        v.PostId,\n        COUNT(v.Id) AS VoteCount,\n        SUM(CASE WHEN vt.Name = 'UpMod' THEN 1 ELSE 0 END) AS Upvotes,\n        SUM(CASE WHEN vt.Name = 'DownMod' THEN 1 ELSE 0 END) AS Downvotes\n    FROM Votes v\n    INNER JOIN VoteTypes vt ON v.VoteTypeId = vt.Id\n    GROUP BY v.PostId\n)\n\nSELECT \n    pa.PostId,\n    pa.Title,\n    pa.CreationDate,\n    pa.ViewCount,\n    pa.Score,\n    pa.OwnerDisplayName,\n    pa.CommentCount,\n    pa.BadgeCount,\n    pa.LastHistoryUpdate,\n    COALESCE(va.VoteCount, 0) AS TotalVotes,\n    COALESCE(va.Upvotes, 0) AS Upvotes,\n    COALESCE(va.Downvotes, 0) AS Downvotes\nFROM PostAnalytics pa\nLEFT JOIN VoteAnalytics va ON pa.PostId = va.PostId\nORDER BY pa.CreationDate DESC\nLIMIT 100;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'postid' not found in 'pa'\", span: None, notes: [DiagnosticNote { message: \"possible column va.postid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"pa\" }), name: \"postid\" }, valid_fields: [Column { relation: Some(Bare { table: \"pa\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"va\" }), name: \"postid\" }, Column { relation: Some(Bare { table: \"va\" }), name: \"votecount\" }, Column { relation: Some(Bare { table: \"va\" }), name: \"upvotes\" }, Column { relation: Some(Bare { table: \"va\" }), name: \"downvotes\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "12360.sql", "original_sql": "\nSELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.ViewCount,\n    p.Score,\n    u.DisplayName AS OwnerDisplayName,\n    COUNT(c.Id) AS CommentCount,\n    COUNT(v.Id) AS VoteCount,\n    AVG(v.BountyAmount) AS AverageBountyAmount,\n    COUNT(b.Id) AS BadgeCount,\n    COUNT(ph.Id) AS PostHistoryCount\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nLEFT JOIN \n    Badges b ON u.Id = b.UserId\nLEFT JOIN \n    PostHistory ph ON p.Id = ph.PostId\nWHERE \n    p.PostTypeId = 1 \nGROUP BY \n    p.Id, p.Title, p.CreationDate, p.ViewCount, p.Score, u.DisplayName\nORDER BY \n    p.CreationDate DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT p.Id AS PostId,\n       p.OwnerUserId,\n       COUNT(DISTINCT c.Id) AS CommentCount,\n       COUNT(DISTINCT v.Id) AS VoteCount,\n       AVG(v.BountyAmount) AS AverageBountyAmount,\n       COUNT(DISTINCT ph.Id) AS PostHistoryCount,\n       COUNT(DISTINCT b.Id) AS BadgeCount\nFROM Posts p\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Votes v ON p.Id = v.PostId\nLEFT JOIN PostHistory ph ON p.Id = ph.PostId\nLEFT JOIN Badges b ON p.OwnerUserId = b.UserId\nWHERE p.PostTypeId = 1\nGROUP BY p.Id, p.OwnerUserId;", "sql2": "SELECT p.Id AS PostId,\n       p.Title,\n       p.CreationDate,\n       p.ViewCount,\n       p.Score,\n       u.DisplayName AS OwnerDisplayName,\n       s1.CommentCount,\n       s1.VoteCount,\n       s1.AverageBountyAmount,\n       s1.BadgeCount,\n       s1.PostHistoryCount\nFROM Posts p\nJOIN Users u ON p.OwnerUserId = u.Id\nJOIN s1 ON p.Id = s1.PostId\nWHERE p.PostTypeId = 1\nORDER BY p.CreationDate DESC\nLIMIT 100;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "12391.sql", "original_sql": "WITH UserPostStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(P.Id) AS PostCount,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        SUM(P.ViewCount) AS TotalViews,\n        AVG(P.Score) AS AverageScore\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    GROUP BY \n        U.Id, U.DisplayName\n),\nPostStatistics AS (\n    SELECT \n        PT.Name AS PostType,\n        COUNT(P.Id) AS TotalPosts,\n        AVG(P.ViewCount) AS AverageViews,\n        AVG(P.Score) AS AverageScore\n    FROM \n        Posts P\n    JOIN \n        PostTypes PT ON P.PostTypeId = PT.Id\n    GROUP BY \n        PT.Name\n)\nSELECT \n    U.UserId,\n    U.DisplayName,\n    U.PostCount,\n    U.QuestionCount,\n    U.AnswerCount,\n    U.TotalViews,\n    U.AverageScore,\n    PS.PostType,\n    PS.TotalPosts,\n    PS.AverageViews,\n    PS.AverageScore\nFROM \n    UserPostStats U\nJOIN \n    PostStatistics PS ON U.PostCount > 0\nORDER BY \n    U.TotalViews DESC, U.AverageScore DESC;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'postcount' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column s1.count\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"postcount\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"posttype\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"totalposts\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"averageviews\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"averagescore\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "12399.sql", "original_sql": "SELECT \n    pt.Name AS PostType,\n    COUNT(p.Id) AS TotalPosts,\n    AVG(p.Score) AS AverageScore,\n    COUNT(DISTINCT p.OwnerUserId) AS TotalUsers,\n    AVG(p.ViewCount) AS AverageViewCount\nFROM \n    Posts p\nJOIN \n    PostTypes pt ON p.PostTypeId = pt.Id\nGROUP BY \n    pt.Name\nORDER BY \n    TotalPosts DESC;", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "12489.sql", "original_sql": "\nSELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.Score,\n    p.ViewCount,\n    u.DisplayName AS OwnerDisplayName,\n    COUNT(v.Id) AS VoteCount,\n    COUNT(c.Id) AS CommentCount,\n    COALESCE(NULLIF(ROUND(AVG(CASE WHEN vt.Name = 'UpMod' THEN 1 ELSE 0 END), 2), 0), 0) AS UpVotes,\n    COALESCE(NULLIF(ROUND(AVG(CASE WHEN vt.Name = 'DownMod' THEN 1 ELSE 0 END), 2), 0), 0) AS DownVotes\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nLEFT JOIN \n    VoteTypes vt ON v.VoteTypeId = vt.Id\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nWHERE \n    p.CreationDate >= TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '30 days'  \nGROUP BY \n    p.Id, p.Title, p.CreationDate, p.Score, p.ViewCount, u.DisplayName\nORDER BY \n    p.CreationDate DESC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: SQL(ParserError(\"Expected: ), found: AS at Line: 9, Column: 92\"), None)\n", "engine_mem_mb": 500000}
{"query_id": "12491.sql", "original_sql": "WITH UserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.Reputation,\n        COUNT(DISTINCT p.Id) AS PostCount,\n        COUNT(DISTINCT b.Id) AS BadgeCount,\n        SUM(COALESCE(v.BountyAmount, 0)) AS TotalBounties,\n        SUM(COALESCE(p.ViewCount, 0)) AS TotalViews\n    FROM \n        Users u\n    LEFT JOIN Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN Badges b ON u.Id = b.UserId\n    LEFT JOIN Votes v ON u.Id = v.UserId\n    GROUP BY \n        u.Id, u.Reputation\n),\nPostStats AS (\n    SELECT \n        p.Id AS PostId,\n        p.PostTypeId,\n        p.AcceptedAnswerId,\n        COUNT(DISTINCT c.Id) AS CommentCount,\n        COUNT(DISTINCT v.Id) AS VoteCount\n    FROM \n        Posts p\n    LEFT JOIN Comments c ON p.Id = c.PostId\n    LEFT JOIN Votes v ON p.Id = v.PostId\n    GROUP BY \n        p.Id, p.PostTypeId, p.AcceptedAnswerId\n)\nSELECT \n    u.UserId,\n    u.Reputation,\n    u.PostCount,\n    u.BadgeCount,\n    u.TotalBounties,\n    u.TotalViews,\n    p.PostId,\n    p.PostTypeId,\n    p.AcceptedAnswerId,\n    p.CommentCount,\n    p.VoteCount\nFROM \n    UserStats u\nJOIN \n    PostStats p ON u.UserId = p.AcceptedAnswerId\nORDER BY \n    u.Reputation DESC, u.PostCount DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    u.Id AS UserId,\n    u.Reputation,\n    COUNT(DISTINCT p.Id) AS PostCount,\n    COUNT(DISTINCT b.Id) AS BadgeCount,\n    SUM(COALESCE(v.BountyAmount, 0)) AS TotalBounties,\n    SUM(COALESCE(p.ViewCount, 0)) AS TotalViews\nFROM Users u\nLEFT JOIN Posts p ON u.Id = p.OwnerUserId\nLEFT JOIN Badges b ON u.Id = b.UserId\nLEFT JOIN Votes v ON u.Id = v.UserId\nGROUP BY u.Id, u.Reputation;", "sql2": "SELECT \n    s1.UserId,\n    s1.Reputation,\n    s1.PostCount,\n    s1.BadgeCount,\n    s1.TotalBounties,\n    s1.TotalViews,\n    ps.PostId,\n    ps.PostTypeId,\n    ps.AcceptedAnswerId,\n    ps.CommentCount,\n    ps.VoteCount\nFROM s1\nJOIN (\n    SELECT \n        p.Id AS PostId,\n        p.PostTypeId,\n        p.AcceptedAnswerId,\n        COUNT(DISTINCT c.Id) AS CommentCount,\n        COUNT(DISTINCT v.Id) AS VoteCount\n    FROM Posts p\n    LEFT JOIN Comments c ON p.Id = c.PostId\n    LEFT JOIN Votes v ON p.Id = v.PostId\n    GROUP BY p.Id, p.PostTypeId, p.AcceptedAnswerId\n) ps ON s1.UserId = ps.AcceptedAnswerId\nORDER BY s1.Reputation DESC, s1.PostCount DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "12522.sql", "original_sql": "SELECT \n    u.Id AS UserId,\n    u.DisplayName,\n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate AS PostCreationDate,\n    ph.CreationDate AS PostHistoryDate,\n    ph.Comment AS PostHistoryComment,\n    v.CreationDate AS VoteCreationDate,\n    vt.Name AS VoteTypeName\nFROM \n    Users u\nJOIN \n    Posts p ON u.Id = p.OwnerUserId\nLEFT JOIN \n    PostHistory ph ON p.Id = ph.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nLEFT JOIN \n    VoteTypes vt ON v.VoteTypeId = vt.Id\nWHERE \n    u.Reputation > 1000 \nORDER BY \n    u.Id, p.Id, ph.CreationDate DESC;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'postid' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column ph.postid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"postid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"ph\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"ph\" }), name: \"posthistorytypeid\" }, Column { relation: Some(Bare { table: \"ph\" }), name: \"postid\" }, Column { relation: Some(Bare { table: \"ph\" }), name: \"revisionguid\" }, Column { relation: Some(Bare { table: \"ph\" }), name: \"creationdate\" }, Column { relation: Some(Bare { table: \"ph\" }), name: \"userid\" }, Column { relation: Some(Bare { table: \"ph\" }), name: \"userdisplayname\" }, Column { relation: Some(Bare { table: \"ph\" }), name: \"comment\" }, Column { relation: Some(Bare { table: \"ph\" }), name: \"text\" }, Column { relation: Some(Bare { table: \"ph\" }), name: \"contentlicense\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "12529.sql", "original_sql": "WITH PostStats AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        COUNT(c.Id) AS CommentCount,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVoteCount,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVoteCount,\n        COUNT(DISTINCT b.Id) AS BadgeCount,\n        MAX(ph.CreationDate) AS LastEditDate\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    LEFT JOIN \n        Badges b ON p.OwnerUserId = b.UserId\n    LEFT JOIN \n        PostHistory ph ON p.Id = ph.PostId\n    WHERE \n        p.CreationDate >= '2023-01-01'  \n    GROUP BY \n        p.Id, p.Title, p.CreationDate\n)\n\nSELECT \n    PS.PostId,\n    PS.Title,\n    PS.CreationDate,\n    PS.CommentCount,\n    PS.UpVoteCount,\n    PS.DownVoteCount,\n    PS.BadgeCount,\n    PS.LastEditDate\nFROM \n    PostStats PS\nORDER BY \n    PS.CreationDate DESC;", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT p.Id AS PostId,\n       p.Title,\n       p.CreationDate,\n       COUNT(c.Id) AS CommentCount,\n       SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVoteCount,\n       SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVoteCount,\n       COUNT(DISTINCT b.Id) AS BadgeCount,\n       MAX(ph.CreationDate) AS LastEditDate\nFROM Posts p\nLEFT JOIN Comments c      ON p.Id = c.PostId\nLEFT JOIN Votes v         ON p.Id = v.PostId\nLEFT JOIN Badges b        ON p.OwnerUserId = b.UserId\nLEFT JOIN PostHistory ph  ON p.Id = ph.PostId\nWHERE p.CreationDate >= DATE '2023-01-01'\nGROUP BY p.Id, p.Title, p.CreationDate;", "sql2": "SELECT PostId,\n       Title,\n       CreationDate,\n       CommentCount,\n       UpVoteCount,\n       DownVoteCount,\n       BadgeCount,\n       LastEditDate\nFROM s1\nORDER BY CreationDate DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "12552.sql", "original_sql": "\nWITH PostStats AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        p.ViewCount,\n        p.Score,\n        COUNT(c.Id) AS CommentCount,\n        COUNT(DISTINCT v.Id) AS VoteCount,\n        COALESCE(SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END), 0) AS UpVoteCount,\n        COALESCE(SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END), 0) AS DownVoteCount,\n        COUNT(DISTINCT b.Id) AS BadgeCount\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    LEFT JOIN \n        Badges b ON p.OwnerUserId = b.UserId\n    WHERE \n        p.CreationDate >= TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '1 year'\n    GROUP BY \n        p.Id, p.Title, p.CreationDate, p.ViewCount, p.Score\n),\nUserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(DISTINCT p.Id) AS PostCount,\n        SUM(u.UpVotes) AS TotalUpVotes,\n        SUM(u.DownVotes) AS TotalDownVotes,\n        AVG(u.Reputation) AS AverageReputation\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    GROUP BY \n        u.Id, u.DisplayName\n)\nSELECT \n    ps.Title,\n    ps.ViewCount,\n    ps.Score,\n    ps.CommentCount,\n    ps.VoteCount,\n    ps.UpVoteCount,\n    ps.DownVoteCount,\n    us.DisplayName AS OwnerDisplayName,\n    us.PostCount,\n    us.TotalUpVotes,\n    us.TotalDownVotes,\n    us.AverageReputation\nFROM \n    PostStats ps\nJOIN \n    UserStats us ON ps.PostId = us.UserId\nORDER BY \n    ps.ViewCount DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT p.Id AS PostId, p.Title, p.CreationDate, p.ViewCount, p.Score, COUNT(c.Id) AS CommentCount, COUNT(DISTINCT v.Id) AS VoteCount, COALESCE(SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END),0) AS UpVoteCount, COALESCE(SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END),0) AS DownVoteCount, COUNT(DISTINCT b.Id) AS BadgeCount FROM Posts p LEFT JOIN Comments c ON p.Id = c.PostId LEFT JOIN Votes v ON p.Id = v.PostId LEFT JOIN Badges b ON p.OwnerUserId = b.UserId WHERE p.CreationDate >= TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '1 year' GROUP BY p.Id, p.Title, p.CreationDate, p.ViewCount, p.Score", "sql2": "SELECT s1.Title, s1.ViewCount, s1.Score, s1.CommentCount, s1.VoteCount, s1.UpVoteCount, s1.DownVoteCount, us.DisplayName AS OwnerDisplayName, us.PostCount, us.TotalUpVotes, us.TotalDownVotes, us.AverageReputation FROM s1 JOIN (SELECT u.Id AS UserId, u.DisplayName, COUNT(DISTINCT p.Id) AS PostCount, SUM(u.UpVotes) AS TotalUpVotes, SUM(u.DownVotes) AS TotalDownVotes, AVG(u.Reputation) AS AverageReputation FROM Users u LEFT JOIN Posts p ON u.Id = p.OwnerUserId GROUP BY u.Id, u.DisplayName) us ON s1.PostId = us.UserId ORDER BY s1.ViewCount DESC LIMIT 100", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "12578.sql", "original_sql": "\nSELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.Score,\n    p.ViewCount,\n    u.DisplayName AS OwnerDisplayName,\n    COUNT(c.Id) AS CommentCount,\n    COUNT(v.Id) AS VoteCount,\n    MAX(ph.CreationDate) AS LastEdited,\n    MAX(CASE WHEN ph.PostHistoryTypeId = 10 THEN ph.CreationDate END) AS ClosedDate\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nLEFT JOIN \n    PostHistory ph ON p.Id = ph.PostId\nWHERE \n    p.PostTypeId IN (1, 2) \nGROUP BY \n    p.Id, p.Title, p.CreationDate, p.Score, p.ViewCount, u.DisplayName\nORDER BY \n    p.CreationDate DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT p.Id AS PostId,\n       p.Title,\n       p.CreationDate,\n       p.Score,\n       p.ViewCount,\n       u.DisplayName AS OwnerDisplayName\nFROM Posts p\nJOIN Users u ON p.OwnerUserId = u.Id\nWHERE p.PostTypeId IN (1, 2)\nORDER BY p.CreationDate DESC\nLIMIT 100;", "sql2": "SELECT s1.PostId,\n       s1.Title,\n       s1.CreationDate,\n       s1.Score,\n       s1.ViewCount,\n       s1.OwnerDisplayName,\n       COUNT(c.Id) AS CommentCount,\n       COUNT(v.Id) AS VoteCount,\n       MAX(ph.CreationDate) AS LastEdited,\n       MAX(CASE WHEN ph.PostHistoryTypeId = 10 THEN ph.CreationDate END) AS ClosedDate\nFROM s1\nLEFT JOIN Comments c ON s1.PostId = c.PostId\nLEFT JOIN Votes v ON s1.PostId = v.PostId\nLEFT JOIN PostHistory ph ON s1.PostId = ph.PostId\nGROUP BY s1.PostId, s1.Title, s1.CreationDate, s1.Score, s1.ViewCount, s1.OwnerDisplayName\nORDER BY s1.CreationDate DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "12600.sql", "original_sql": "WITH PostVoteCounts AS (\n    SELECT \n        p.Id AS PostId,\n        COUNT(v.Id) AS VoteCount,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM \n        Posts p\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    GROUP BY \n        p.Id\n),\nUserPostStats AS (\n    SELECT \n        u.Id AS UserId,\n        COUNT(p.Id) AS PostsCount,\n        SUM(COALESCE(ph.VoteCount, 0)) AS TotalVotes,\n        SUM(COALESCE(ph.UpVotes, 0)) AS TotalUpVotes,\n        SUM(COALESCE(ph.DownVotes, 0)) AS TotalDownVotes\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN \n        PostVoteCounts ph ON p.Id = ph.PostId\n    GROUP BY \n        u.Id\n)\nSELECT \n    u.DisplayName,\n    u.Reputation,\n    u.CreationDate,\n    u.LastAccessDate,\n    ups.PostsCount,\n    ups.TotalVotes,\n    ups.TotalUpVotes,\n    ups.TotalDownVotes\nFROM \n    Users u\nJOIN \n    UserPostStats ups ON u.Id = ups.UserId\nORDER BY \n    ups.TotalVotes DESC, ups.PostsCount DESC;", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT\n    p.Id AS PostId,\n    COUNT(v.Id) AS VoteCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\nFROM Posts p\nLEFT JOIN Votes v ON p.Id = v.PostId\nGROUP BY p.Id;", "sql2": "WITH UserPostStats AS (\n    SELECT \n        u.Id AS UserId,\n        COUNT(p.Id) AS PostsCount,\n        SUM(COALESCE(s1.VoteCount, 0)) AS TotalVotes,\n        SUM(COALESCE(s1.UpVotes, 0)) AS TotalUpVotes,\n        SUM(COALESCE(s1.DownVotes, 0)) AS TotalDownVotes\n    FROM Users u\n    LEFT JOIN Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN s1 ON p.Id = s1.PostId\n    GROUP BY u.Id\n)\nSELECT \n    u.DisplayName,\n    u.Reputation,\n    u.CreationDate,\n    u.LastAccessDate,\n    ups.PostsCount,\n    ups.TotalVotes,\n    ups.TotalUpVotes,\n    ups.TotalDownVotes\nFROM Users u\nJOIN UserPostStats ups ON u.Id = ups.UserId\nORDER BY ups.TotalVotes DESC, ups.PostsCount DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "12637.sql", "original_sql": "\nWITH UserPostStats AS (\n    SELECT\n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(p.Id) AS PostCount,\n        SUM(COALESCE(p.ViewCount, 0)) AS TotalViews,\n        SUM(COALESCE(p.Score, 0)) AS TotalScore,\n        SUM(COALESCE(c.CommentCount, 0)) AS TotalComments\n    FROM\n        Users u\n    LEFT JOIN\n        Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN (\n        SELECT \n            PostId,\n            COUNT(Id) AS CommentCount\n        FROM\n            Comments\n        GROUP BY PostId\n    ) c ON p.Id = c.PostId\n    WHERE\n        u.CreationDate >= '2020-01-01'\n    GROUP BY\n        u.Id, u.DisplayName\n),\nPostTypeStats AS (\n    SELECT\n        pt.Id AS PostTypeId,\n        pt.Name AS PostTypeName,\n        COUNT(p.Id) AS PostCount,\n        SUM(COALESCE(p.ViewCount, 0)) AS TotalViews,\n        SUM(COALESCE(p.Score, 0)) AS TotalScore\n    FROM\n        PostTypes pt\n    LEFT JOIN\n        Posts p ON pt.Id = p.PostTypeId\n    GROUP BY\n        pt.Id, pt.Name\n)\nSELECT \n    u.UserId,\n    u.DisplayName,\n    u.PostCount,\n    u.TotalViews,\n    u.TotalScore,\n    u.TotalComments,\n    p.PostTypeId,\n    p.PostTypeName,\n    p.PostCount AS TypePostCount,\n    p.TotalViews AS TypeTotalViews,\n    p.TotalScore AS TypeTotalScore\nFROM\n    UserPostStats u\nJOIN\n    PostTypeStats p ON u.PostCount > 0\nORDER BY\n    u.TotalScore DESC, p.TotalViews DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    u.Id AS UserId,\n    u.DisplayName,\n    COUNT(p.Id) AS PostCount,\n    SUM(COALESCE(p.ViewCount, 0)) AS TotalViews,\n    SUM(COALESCE(p.Score, 0)) AS TotalScore,\n    SUM(COALESCE(c.CommentCount, 0)) AS TotalComments\nFROM Users u\nLEFT JOIN Posts p ON u.Id = p.OwnerUserId\nLEFT JOIN (\n    SELECT PostId, COUNT(Id) AS CommentCount\n    FROM Comments\n    GROUP BY PostId\n) c ON p.Id = c.PostId\nWHERE u.CreationDate >= DATE '2020-01-01'\nGROUP BY u.Id, u.DisplayName;", "sql2": "WITH PostTypeStats AS (\n    SELECT\n        pt.Id AS PostTypeId,\n        pt.Name AS PostTypeName,\n        COUNT(p.Id) AS PostCount,\n        SUM(COALESCE(p.ViewCount, 0)) AS TotalViews,\n        SUM(COALESCE(p.Score, 0)) AS TotalScore\n    FROM PostTypes pt\n    LEFT JOIN Posts p ON pt.Id = p.PostTypeId\n    GROUP BY pt.Id, pt.Name\n)\nSELECT \n    u.UserId,\n    u.DisplayName,\n    u.PostCount,\n    u.TotalViews,\n    u.TotalScore,\n    u.TotalComments,\n    pts.PostTypeId,\n    pts.PostTypeName,\n    pts.PostCount AS TypePostCount,\n    pts.TotalViews AS TypeTotalViews,\n    pts.TotalScore AS TypeTotalScore\nFROM s1 u\nCROSS JOIN PostTypeStats pts\nWHERE u.PostCount > 0\nORDER BY u.TotalScore DESC, pts.TotalViews DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "12639.sql", "original_sql": "SELECT \n    p.PostTypeId,\n    pt.Name AS PostTypeName,\n    COUNT(p.Id) AS TotalPosts,\n    SUM(p.Score) AS TotalScore,\n    SUM(p.ViewCount) AS TotalViewCount,\n    AVG(p.ViewCount) AS AvgViewCount,\n    COALESCE(SUM(CASE WHEN p.PostTypeId = 1 THEN 1 END), 0) AS TotalQuestions,\n    COALESCE(SUM(CASE WHEN p.PostTypeId = 2 THEN 1 END), 0) AS TotalAnswers,\n    COALESCE(SUM(CASE WHEN p.PostTypeId = 3 THEN 1 END), 0) AS TotalWikis,\n    COUNT(DISTINCT p.OwnerUserId) AS UniqueUsers,\n    SUM(u.Reputation) AS TotalReputation,\n    COUNT(DISTINCT c.Id) AS TotalComments,\n    COUNT(DISTINCT v.Id) AS TotalVotes\nFROM \n    Posts p\nLEFT JOIN \n    PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nGROUP BY \n    p.PostTypeId, pt.Name\nORDER BY \n    p.PostTypeId;", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT p.PostTypeId,\n       COUNT(DISTINCT c.Id) AS TotalComments,\n       COUNT(DISTINCT v.Id) AS TotalVotes\nFROM Posts p\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Votes v ON p.Id = v.PostId\nGROUP BY p.PostTypeId;", "sql2": "SELECT p.PostTypeId,\n       pt.Name AS PostTypeName,\n       COUNT(p.Id) AS TotalPosts,\n       SUM(p.Score) AS TotalScore,\n       SUM(p.ViewCount) AS TotalViewCount,\n       AVG(p.ViewCount) AS AvgViewCount,\n       COALESCE(SUM(CASE WHEN p.PostTypeId = 1 THEN 1 END), 0) AS TotalQuestions,\n       COALESCE(SUM(CASE WHEN p.PostTypeId = 2 THEN 1 END), 0) AS TotalAnswers,\n       COALESCE(SUM(CASE WHEN p.PostTypeId = 3 THEN 1 END), 0) AS TotalWikis,\n       COUNT(DISTINCT p.OwnerUserId) AS UniqueUsers,\n       SUM(u.Reputation) AS TotalReputation,\n       s1.TotalComments,\n       s1.TotalVotes\nFROM Posts p\nLEFT JOIN PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN Users u ON p.OwnerUserId = u.Id\nLEFT JOIN s1 ON p.PostTypeId = s1.PostTypeId\nGROUP BY p.PostTypeId, pt.Name, s1.TotalComments, s1.TotalVotes\nORDER BY p.PostTypeId;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "12660.sql", "original_sql": "WITH UserVoteStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(v.Id) AS VoteCount,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM \n        Users u\n    LEFT JOIN \n        Votes v ON u.Id = v.UserId\n    GROUP BY \n        u.Id, u.DisplayName\n),\n\nPostStats AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.Score,\n        p.ViewCount,\n        p.CreationDate,\n        COUNT(c.Id) AS CommentCount,\n        COUNT(ps.Id) AS AnswerCount\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Posts ps ON p.Id = ps.ParentId AND ps.PostTypeId = 2\n    GROUP BY \n        p.Id, p.Title, p.Score, p.ViewCount, p.CreationDate\n)\n\nSELECT \n    u.DisplayName,\n    u.VoteCount,\n    u.UpVotes,\n    u.DownVotes,\n    p.PostId,\n    p.Title,\n    p.Score,\n    p.ViewCount,\n    p.CommentCount,\n    p.AnswerCount\nFROM \n    UserVoteStats u\nJOIN \n    PostStats p ON u.UserId = p.PostId\nORDER BY \n    u.VoteCount DESC, p.Score DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    u.Id AS UserId,\n    u.DisplayName,\n    COUNT(v.Id) AS VoteCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\nFROM Users u\nLEFT JOIN Votes v ON u.Id = v.UserId\nGROUP BY u.Id, u.DisplayName", "sql2": "SELECT \n    s1.DisplayName,\n    s1.VoteCount,\n    s1.UpVotes,\n    s1.DownVotes,\n    p.PostId,\n    p.Title,\n    p.Score,\n    p.ViewCount,\n    p.CommentCount,\n    p.AnswerCount\nFROM (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.Score,\n        p.ViewCount,\n        p.CreationDate,\n        COUNT(c.Id) AS CommentCount,\n        COUNT(ps.Id) AS AnswerCount\n    FROM Posts p\n    LEFT JOIN Comments c ON p.Id = c.PostId\n    LEFT JOIN Posts ps ON p.Id = ps.ParentId AND ps.PostTypeId = 2\n    GROUP BY p.Id, p.Title, p.Score, p.ViewCount, p.CreationDate\n) p\nJOIN s1 ON s1.UserId = p.PostId\nORDER BY s1.VoteCount DESC, p.Score DESC", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "12670.sql", "original_sql": "WITH PostStats AS (\n    SELECT \n        P.Id AS PostId,\n        P.Title,\n        P.CreationDate,\n        P.LastActivityDate,\n        P.Score,\n        P.AnswerCount,\n        P.ViewCount,\n        P.CommentCount,\n        U.DisplayName AS OwnerDisplayName,\n        T.TagName,\n        PH.CreationDate AS HistoryCreationDate,\n        PH.PostHistoryTypeId\n    FROM \n        Posts P\n    JOIN \n        Users U ON P.OwnerUserId = U.Id\n    JOIN \n        Tags T ON T.Id = P.Id\n    LEFT JOIN \n        PostHistory PH ON P.Id = PH.PostId\n)\n\nSELECT \n    PS.OwnerDisplayName,\n    PS.Title,\n    PS.CreationDate,\n    PS.LastActivityDate,\n    PS.Score,\n    PS.AnswerCount,\n    PS.ViewCount,\n    PS.CommentCount,\n    PS.TagName,\n    COUNT(PH.PostHistoryTypeId) AS HistoryCount\nFROM \n    PostStats PS\nLEFT JOIN \n    PostHistory PH ON PS.PostId = PH.PostId\nGROUP BY \n    PS.OwnerDisplayName, PS.Title, PS.CreationDate, PS.LastActivityDate, PS.Score, PS.AnswerCount, PS.ViewCount, PS.CommentCount, PS.TagName\nORDER BY \n    PS.LastActivityDate DESC\nLIMIT 100;", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT PostId, COUNT(*) AS HistoryCount\nFROM PostHistory\nGROUP BY PostId", "sql2": "SELECT \n    PS.OwnerDisplayName,\n    PS.Title,\n    PS.CreationDate,\n    PS.LastActivityDate,\n    PS.Score,\n    PS.AnswerCount,\n    PS.ViewCount,\n    PS.CommentCount,\n    PS.TagName,\n    COALESCE(H.HistoryCount, 0) AS HistoryCount\nFROM (\n    SELECT \n        P.Id AS PostId,\n        P.Title,\n        P.CreationDate,\n        P.LastActivityDate,\n        P.Score,\n        P.AnswerCount,\n        P.ViewCount,\n        P.CommentCount,\n        U.DisplayName AS OwnerDisplayName,\n        T.TagName\n    FROM Posts P\n    JOIN Users U ON P.OwnerUserId = U.Id\n    JOIN Tags T ON T.Id = P.Id\n) PS\nLEFT JOIN s1 H ON PS.PostId = H.PostId\nORDER BY PS.LastActivityDate DESC\nLIMIT 100;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "12704.sql", "original_sql": "SELECT \n    u.Id AS UserId,\n    u.DisplayName,\n    COUNT(p.Id) AS PostCount,\n    SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n    SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n    SUM(COALESCE(c.CommentCount, 0)) AS TotalComments,\n    SUM(COALESCE(v.VoteCount, 0)) AS TotalVotes,\n    MAX(p.CreationDate) AS LastPostDate\nFROM \n    Users u\nLEFT JOIN \n    Posts p ON u.Id = p.OwnerUserId\nLEFT JOIN \n    (SELECT PostId, COUNT(*) AS CommentCount \n     FROM Comments \n     GROUP BY PostId) c ON p.Id = c.PostId\nLEFT JOIN \n    (SELECT PostId, COUNT(*) AS VoteCount \n     FROM Votes \n     GROUP BY PostId) v ON p.Id = v.PostId\nGROUP BY \n    u.Id,\n    u.DisplayName\nORDER BY \n    PostCount DESC\nLIMIT 100;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"table 'post_interactions' not found\", span: Some(Span(Location(12,11)..Location(12,31))), notes: [], helps: [] }, Plan(\"table 'datafusion.public.post_interactions' not found\"))\n", "engine_mem_mb": 500000}
{"query_id": "12730.sql", "original_sql": "\nWITH UserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(DISTINCT p.Id) AS PostCount,\n        SUM(CASE WHEN pt.Name = 'Question' THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN pt.Name = 'Answer' THEN 1 ELSE 0 END) AS AnswerCount,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,  \n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes  \n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN \n        PostTypes pt ON p.PostTypeId = pt.Id\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    GROUP BY \n        u.Id, u.DisplayName\n),\nPostStats AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        p.Score,\n        p.ViewCount,\n        p.CommentCount,\n        p.AcceptedAnswerId,\n        COALESCE(u.DisplayName, 'Community') AS OwnerDisplayName,\n        p.OwnerUserId\n    FROM \n        Posts p\n    LEFT JOIN \n        Users u ON p.OwnerUserId = u.Id\n)\nSELECT \n    us.UserId,\n    us.DisplayName,\n    us.PostCount,\n    us.QuestionCount,\n    us.AnswerCount,\n    us.UpVotes,\n    us.DownVotes,\n    ps.PostId,\n    ps.Title,\n    ps.CreationDate,\n    ps.Score,\n    ps.ViewCount,\n    ps.CommentCount,\n    ps.OwnerDisplayName\nFROM \n    UserStats us\nLEFT JOIN \n    PostStats ps ON us.UserId = ps.OwnerUserId\nORDER BY \n    us.PostCount DESC, us.UpVotes DESC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 'us'\", span: None, notes: [DiagnosticNote { message: \"possible column p.owneruserid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"us\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"us\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"postid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"title\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"creationdate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"score\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"viewcount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"commentcount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"ownerdisplayname\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"owneruserid\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "12755.sql", "original_sql": "\nWITH PostStatistics AS (\n    SELECT\n        p.Id AS PostId,\n        p.PostTypeId,\n        COUNT(c.Id) AS CommentCount,\n        COUNT(v.Id) AS VoteCount,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n        SUM(CASE WHEN v.VoteTypeId = 4 THEN 1 ELSE 0 END) AS OffensiveVotes,\n        MAX(p.CreationDate) AS LastActivityDate\n    FROM Posts p\n    LEFT JOIN Comments c ON p.Id = c.PostId\n    LEFT JOIN Votes v ON p.Id = v.PostId\n    GROUP BY p.Id, p.PostTypeId\n),\nUserStatistics AS (\n    SELECT\n        u.Id AS UserId,\n        COUNT(b.Id) AS BadgeCount,\n        SUM(u.UpVotes) AS TotalUpVotes,\n        SUM(u.DownVotes) AS TotalDownVotes,\n        SUM(u.Views) AS TotalViews\n    FROM Users u\n    LEFT JOIN Badges b ON u.Id = b.UserId\n    GROUP BY u.Id\n)\nSELECT\n    ps.PostId,\n    ps.PostTypeId,\n    ps.CommentCount,\n    ps.VoteCount,\n    ps.UpVotes,\n    ps.DownVotes,\n    ps.OffensiveVotes,\n    ps.LastActivityDate,\n    us.UserId,\n    us.BadgeCount,\n    us.TotalUpVotes,\n    us.TotalDownVotes,\n    us.TotalViews\nFROM PostStatistics ps\nJOIN UserStatistics us ON ps.PostTypeId = us.UserId\nORDER BY ps.LastActivityDate DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    p.Id AS PostId,\n    p.PostTypeId,\n    COUNT(c.Id) AS CommentCount,\n    COUNT(v.Id) AS VoteCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n    SUM(CASE WHEN v.VoteTypeId = 4 THEN 1 ELSE 0 END) AS OffensiveVotes,\n    MAX(p.CreationDate) AS LastActivityDate\nFROM Posts p\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Votes v ON p.Id = v.PostId\nGROUP BY p.Id, p.PostTypeId;", "sql2": "WITH UserStatistics AS (\n    SELECT\n        u.Id AS UserId,\n        COUNT(b.Id) AS BadgeCount,\n        SUM(u.UpVotes) AS TotalUpVotes,\n        SUM(u.DownVotes) AS TotalDownVotes,\n        SUM(u.Views) AS TotalViews\n    FROM Users u\n    LEFT JOIN Badges b ON u.Id = b.UserId\n    GROUP BY u.Id\n)\nSELECT\n    s1.PostId,\n    s1.PostTypeId,\n    s1.CommentCount,\n    s1.VoteCount,\n    s1.UpVotes,\n    s1.DownVotes,\n    s1.OffensiveVotes,\n    s1.LastActivityDate,\n    us.UserId,\n    us.BadgeCount,\n    us.TotalUpVotes,\n    us.TotalDownVotes,\n    us.TotalViews\nFROM s1\nJOIN UserStatistics us ON s1.PostTypeId = us.UserId\nORDER BY s1.LastActivityDate DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "12777.sql", "original_sql": "SELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.ViewCount,\n    u.DisplayName AS OwnerDisplayName,\n    COUNT(DISTINCT v.Id) AS VoteCount,\n    COUNT(DISTINCT c.Id) AS CommentCount,\n    (SELECT COUNT(*) FROM Posts p2 WHERE p2.ParentId = p.Id) AS AnswerCount \nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nWHERE \n    p.CreationDate >= '2023-01-01' \nGROUP BY \n    p.Id, p.Title, p.CreationDate, p.ViewCount, u.DisplayName\nORDER BY \n    p.CreationDate DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH vc AS (\n    SELECT PostId, COUNT(*) AS VoteCount\n    FROM Votes\n    GROUP BY PostId\n),\ncc AS (\n    SELECT PostId, COUNT(*) AS CommentCount\n    FROM Comments\n    GROUP BY PostId\n),\nac AS (\n    SELECT ParentId AS PostId, COUNT(*) AS AnswerCount\n    FROM Posts\n    WHERE ParentId IS NOT NULL\n    GROUP BY ParentId\n)\nSELECT\n    p.Id AS PostId,\n    COALESCE(vc.VoteCount,0) AS VoteCount,\n    COALESCE(cc.CommentCount,0) AS CommentCount,\n    COALESCE(ac.AnswerCount,0) AS AnswerCount\nFROM Posts p\nLEFT JOIN vc ON p.Id = vc.PostId\nLEFT JOIN cc ON p.Id = cc.PostId\nLEFT JOIN ac ON p.Id = ac.PostId\nWHERE p.CreationDate >= '2023-01-01';", "sql2": "SELECT\n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.ViewCount,\n    u.DisplayName AS OwnerDisplayName,\n    s1.VoteCount,\n    s1.CommentCount,\n    s1.AnswerCount\nFROM s1\nJOIN Posts p ON s1.PostId = p.Id\nJOIN Users u ON p.OwnerUserId = u.Id\nORDER BY p.CreationDate DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "12781.sql", "original_sql": "WITH PostCounts AS (\n    SELECT \n        PostTypeId, \n        COUNT(*) AS TotalPosts,\n        SUM(CASE WHEN AcceptedAnswerId IS NOT NULL THEN 1 ELSE 0 END) AS AcceptedAnswers,\n        SUM(ViewCount) AS TotalViews,\n        AVG(Score) AS AvgScore\n    FROM \n        Posts\n    GROUP BY \n        PostTypeId\n),\nUserMetrics AS (\n    SELECT \n        u.Id AS UserId,\n        u.Reputation,\n        COUNT(b.Id) AS TotalBadges,\n        SUM(v.BountyAmount) AS TotalBounty\n    FROM \n        Users u\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    LEFT JOIN \n        Votes v ON u.Id = v.UserId\n    GROUP BY \n        u.Id, u.Reputation\n),\nPostHistoryTypesCount AS (\n    SELECT \n        pht.Name AS PostHistoryType,\n        COUNT(ph.Id) AS HistoryCount\n    FROM \n        PostHistory ph\n    JOIN \n        PostHistoryTypes pht ON ph.PostHistoryTypeId = pht.Id\n    GROUP BY \n        pht.Name\n)\nSELECT \n    pc.PostTypeId,\n    pc.TotalPosts,\n    pc.AcceptedAnswers,\n    pc.TotalViews,\n    pc.AvgScore,\n    um.TotalBadges,\n    um.TotalBounty,\n    phc.PostHistoryType,\n    phc.HistoryCount\nFROM \n    PostCounts pc\nJOIN \n    UserMetrics um ON um.UserId = (SELECT MIN(Id) FROM Users) \nCROSS JOIN \n    PostHistoryTypesCount phc\nORDER BY \n    pc.PostTypeId;", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "WITH \n    MinUser AS (\n        SELECT MIN(Id) AS MinId FROM Users\n    ),\n    PostCounts AS (\n        SELECT \n            PostTypeId, \n            COUNT(*) AS TotalPosts,\n            SUM(CASE WHEN AcceptedAnswerId IS NOT NULL THEN 1 ELSE 0 END) AS AcceptedAnswers,\n            SUM(ViewCount) AS TotalViews,\n            AVG(Score) AS AvgScore\n        FROM Posts\n        GROUP BY PostTypeId\n    ),\n    UserMetrics AS (\n        SELECT \n            u.Id AS UserId,\n            u.Reputation,\n            COUNT(b.Id) AS TotalBadges,\n            SUM(v.BountyAmount) AS TotalBounty\n        FROM Users u\n        LEFT JOIN Badges b ON u.Id = b.UserId\n        LEFT JOIN Votes v ON u.Id = v.UserId\n        GROUP BY u.Id, u.Reputation\n    ),\n    PostHistoryTypesCount AS (\n        SELECT \n            pht.Name AS PostHistoryType,\n            COUNT(ph.Id) AS HistoryCount\n        FROM PostHistory ph\n        JOIN PostHistoryTypes pht ON ph.PostHistoryTypeId = pht.Id\n        GROUP BY pht.Name\n    )\nSELECT \n    pc.PostTypeId,\n    pc.TotalPosts,\n    pc.AcceptedAnswers,\n    pc.TotalViews,\n    pc.AvgScore,\n    um.TotalBadges,\n    um.TotalBounty,\n    phc.PostHistoryType,\n    phc.HistoryCount\nFROM PostCounts pc\nJOIN (\n    SELECT um.TotalBadges, um.TotalBounty\n    FROM UserMetrics um\n    JOIN MinUser mu ON um.UserId = mu.MinId\n) um ON TRUE\nCROSS JOIN PostHistoryTypesCount phc;", "sql2": "SELECT * FROM s1 ORDER BY PostTypeId;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "12794.sql", "original_sql": "WITH UserBadges AS (\n    SELECT \n        U.Id AS UserId,\n        COUNT(B.Id) AS BadgeCount,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Users U\n    LEFT JOIN \n        Badges B ON U.Id = B.UserId\n    GROUP BY \n        U.Id\n),\n\nPostStats AS (\n    SELECT \n        P.OwnerUserId,\n        COUNT(P.Id) AS PostCount,\n        SUM(P.Score) AS TotalScore,\n        SUM(P.ViewCount) AS TotalViews,\n        AVG(P.Score) AS AvgScore\n    FROM \n        Posts P\n    GROUP BY \n        P.OwnerUserId\n)\n\nSELECT \n    U.Id AS UserId,\n    U.DisplayName,\n    U.Reputation,\n    COALESCE(UB.BadgeCount, 0) AS BadgeCount,\n    COALESCE(UB.GoldBadges, 0) AS GoldBadges,\n    COALESCE(UB.SilverBadges, 0) AS SilverBadges,\n    COALESCE(UB.BronzeBadges, 0) AS BronzeBadges,\n    COALESCE(PS.PostCount, 0) AS PostCount,\n    COALESCE(PS.TotalScore, 0) AS TotalScore,\n    COALESCE(PS.TotalViews, 0) AS TotalViews,\n    COALESCE(PS.AvgScore, 0) AS AvgScore\nFROM \n    Users U\nLEFT JOIN \n    UserBadges UB ON U.Id = UB.UserId\nLEFT JOIN \n    PostStats PS ON U.Id = PS.OwnerUserId\nORDER BY \n    U.Reputation DESC\nLIMIT 100;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH UserBadgesAgg AS (\n    SELECT U.Id AS UserId,\n           COUNT(B.Id) AS BadgeCount,\n           SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n           SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n           SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Users U\n    LEFT JOIN Badges B ON U.Id = B.UserId\n    GROUP BY U.Id\n),\nPostStatsAgg AS (\n    SELECT P.OwnerUserId AS UserId,\n           COUNT(P.Id) AS PostCount,\n           SUM(P.Score) AS TotalScore,\n           SUM(P.ViewCount) AS TotalViews,\n           AVG(P.Score) AS AvgScore\n    FROM Posts P\n    GROUP BY P.OwnerUserId\n)\nSELECT COALESCE(UB.UserId, PS.UserId) AS UserId,\n       COALESCE(UB.BadgeCount, 0) AS BadgeCount,\n       COALESCE(UB.GoldBadges, 0) AS GoldBadges,\n       COALESCE(UB.SilverBadges, 0) AS SilverBadges,\n       COALESCE(UB.BronzeBadges, 0) AS BronzeBadges,\n       COALESCE(PS.PostCount, 0) AS PostCount,\n       COALESCE(PS.TotalScore, 0) AS TotalScore,\n       COALESCE(PS.TotalViews, 0) AS TotalViews,\n       COALESCE(PS.AvgScore, 0) AS AvgScore\nFROM UserBadgesAgg UB\nFULL OUTER JOIN PostStatsAgg PS ON UB.UserId = PS.UserId;", "sql2": "SELECT U.Id AS UserId,\n       U.DisplayName,\n       U.Reputation,\n       COALESCE(s1.BadgeCount, 0) AS BadgeCount,\n       COALESCE(s1.GoldBadges, 0) AS GoldBadges,\n       COALESCE(s1.SilverBadges, 0) AS SilverBadges,\n       COALESCE(s1.BronzeBadges, 0) AS BronzeBadges,\n       COALESCE(s1.PostCount, 0) AS PostCount,\n       COALESCE(s1.TotalScore, 0) AS TotalScore,\n       COALESCE(s1.TotalViews, 0) AS TotalViews,\n       COALESCE(s1.AvgScore, 0) AS AvgScore\nFROM Users U\nLEFT JOIN s1 ON U.Id = s1.UserId\nORDER BY U.Reputation DESC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "12825.sql", "original_sql": "SELECT \n    pt.Name AS PostTypeName,\n    COUNT(p.Id) AS PostCount,\n    AVG(p.Score) AS AverageScore,\n    COUNT(DISTINCT p.OwnerUserId) AS UniqueUserCount\nFROM \n    Posts p\nJOIN \n    PostTypes pt ON p.PostTypeId = pt.Id\nWHERE \n    p.Score IS NOT NULL\nGROUP BY \n    pt.Name\nORDER BY \n    PostCount DESC;", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "12921.sql", "original_sql": "SELECT \n    pt.Name AS PostType,\n    COUNT(p.Id) AS TotalPosts,\n    SUM(p.Score) AS TotalScore,\n    SUM(p.ViewCount) AS TotalViews,\n    AVG(u.Reputation) AS AverageUserReputation,\n    COUNT(DISTINCT u.Id) AS TotalUsers\nFROM \n    Posts p\nJOIN \n    PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN \n    Users u ON p.OwnerUserId = u.Id\nGROUP BY \n    pt.Name\nORDER BY \n    TotalPosts DESC;", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "12950.sql", "original_sql": "\nWITH PostSummary AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        p.Score,\n        p.ViewCount,\n        COUNT(c.Id) AS CommentCount,\n        COUNT(DISTINCT v.UserId) AS VoteCount,\n        COUNT(DISTINCT CASE WHEN b.Id IS NOT NULL THEN b.Id END) AS BadgeCount,\n        ARRAY_AGG(DISTINCT t.TagName) AS Tags\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    LEFT JOIN \n        Badges b ON p.OwnerUserId = b.UserId\n    LEFT JOIN \n        Tags t ON t.ExcerptPostId = p.Id\n    GROUP BY \n        p.Id, p.Title, p.CreationDate, p.Score, p.ViewCount\n),\nPostHistorySummary AS (\n    SELECT \n        PostId,\n        COUNT(*) AS HistoryActionCount,\n        MAX(CreationDate) AS LastActivityDate\n    FROM \n        PostHistory\n    GROUP BY \n        PostId\n)\nSELECT \n    ps.PostId,\n    ps.Title,\n    ps.CreationDate AS PostCreationDate,\n    ps.Score,\n    ps.ViewCount,\n    ps.CommentCount,\n    ps.VoteCount,\n    ps.BadgeCount,\n    ps.Tags,\n    phs.HistoryActionCount,\n    phs.LastActivityDate\nFROM \n    PostSummary ps\nLEFT JOIN \n    PostHistorySummary phs ON ps.PostId = phs.PostId\nORDER BY \n    ps.CreationDate DESC\nFETCH FIRST 100 ROWS ONLY;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "13007.sql", "original_sql": "SELECT \n    pt.Name AS PostType,\n    COUNT(p.Id) AS TotalPosts,\n    AVG(p.Score) AS AverageScore,\n    SUM(p.ViewCount) AS TotalViews,\n    COUNT(DISTINCT p.OwnerUserId) AS UniqueUsers\nFROM \n    Posts p\nJOIN \n    PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN \n    Users u ON p.OwnerUserId = u.Id\nWHERE \n    p.CreationDate >= '2023-01-01' \nGROUP BY \n    pt.Name\nORDER BY \n    TotalPosts DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT p.PostTypeId,\n       COUNT(p.Id) AS TotalPosts,\n       AVG(p.Score) AS AverageScore,\n       SUM(p.ViewCount) AS TotalViews,\n       COUNT(DISTINCT p.OwnerUserId) AS UniqueUsers\nFROM Posts p\nWHERE p.CreationDate >= '2023-01-01'\nGROUP BY p.PostTypeId;", "sql2": "SELECT pt.Name AS PostType,\n       s1.TotalPosts,\n       s1.AverageScore,\n       s1.TotalViews,\n       s1.UniqueUsers\nFROM s1\nJOIN PostTypes pt ON s1.PostTypeId = pt.Id\nORDER BY s1.TotalPosts DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "13016.sql", "original_sql": "\nWITH PostStatistics AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        p.Score,\n        p.ViewCount,\n        COUNT(DISTINCT c.Id) AS CommentCount,\n        COUNT(DISTINCT v.Id) AS VoteCount,\n        (SELECT COUNT(a.Id) \n         FROM Posts a \n         WHERE a.ParentId = p.Id) AS AnswerCount\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    GROUP BY \n        p.Id, p.Title, p.CreationDate, p.Score, p.ViewCount\n),\nUserStatistics AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        SUM(u.Views) AS TotalViews,\n        SUM(u.UpVotes) AS TotalUpVotes,\n        SUM(u.DownVotes) AS TotalDownVotes,\n        COUNT(b.Id) AS BadgeCount\n    FROM \n        Users u\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    GROUP BY \n        u.Id, u.DisplayName\n)\n\nSELECT \n    ps.PostId,\n    ps.Title,\n    ps.CreationDate,\n    ps.Score,\n    ps.ViewCount,\n    ps.CommentCount,\n    ps.VoteCount,\n    ps.AnswerCount,\n    us.UserId,\n    us.DisplayName,\n    us.TotalViews,\n    us.TotalUpVotes,\n    us.TotalDownVotes,\n    us.BadgeCount\nFROM \n    PostStatistics ps\nJOIN \n    UserStatistics us ON ps.PostId = us.UserId\nORDER BY \n    ps.Score DESC, \n    ps.ViewCount DESC\nLIMIT 100;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'postid' not found in 's1'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"postid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"userid\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"totalviews\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"totalupvotes\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"totaldownvotes\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"badgecount\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "13067.sql", "original_sql": "WITH PostStats AS (\n    SELECT \n        P.Id AS PostId,\n        P.PostTypeId,\n        P.CreationDate,\n        COUNT(CASE WHEN C.Id IS NOT NULL THEN 1 END) AS CommentCount,\n        COUNT(V.Id) AS VoteCount,\n        AVG(U.Reputation) AS AvgUserReputation\n    FROM \n        Posts P\n    LEFT JOIN \n        Comments C ON P.Id = C.PostId\n    LEFT JOIN \n        Votes V ON P.Id = V.PostId\n    LEFT JOIN \n        Users U ON P.OwnerUserId = U.Id\n    GROUP BY \n        P.Id, P.PostTypeId, P.CreationDate\n)\n\nSELECT \n    PT.Name AS PostType,\n    COUNT(*) AS TotalPosts,\n    AVG(CommentCount) AS AvgComments,\n    AVG(VoteCount) AS AvgVotes,\n    AVG(AvgUserReputation) AS AvgOwnerReputation\nFROM \n    PostStats PS\nJOIN \n    PostTypes PT ON PS.PostTypeId = PT.Id\nGROUP BY \n    PT.Name\nORDER BY \n    TotalPosts DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    P.Id AS PostId,\n    P.PostTypeId,\n    P.CreationDate,\n    COUNT(C.Id) AS CommentCount,\n    COUNT(V.Id) AS VoteCount,\n    AVG(U.Reputation) AS AvgUserReputation\nFROM Posts P\nLEFT JOIN Comments C ON P.Id = C.PostId\nLEFT JOIN Votes V ON P.Id = V.PostId\nLEFT JOIN Users U ON P.OwnerUserId = U.Id\nGROUP BY P.Id, P.PostTypeId, P.CreationDate;", "sql2": "SELECT \n    PT.Name AS PostType,\n    COUNT(*) AS TotalPosts,\n    AVG(s1.CommentCount) AS AvgComments,\n    AVG(s1.VoteCount) AS AvgVotes,\n    AVG(s1.AvgUserReputation) AS AvgOwnerReputation\nFROM s1\nJOIN PostTypes PT ON s1.PostTypeId = PT.Id\nGROUP BY PT.Name\nORDER BY TotalPosts DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "13075.sql", "original_sql": "WITH UserStatistics AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(P.Id) AS TotalPosts,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS Answers,\n        SUM(CASE WHEN P.PostTypeId = 3 THEN 1 ELSE 0 END) AS Wikis,\n        SUM(P.Score) AS TotalScore,\n        SUM(COALESCE(P.ViewCount, 0)) AS TotalViews\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    GROUP BY \n        U.Id, U.DisplayName\n),\nPostTypesStats AS (\n    SELECT \n        PT.Name AS PostTypeName,\n        COUNT(P.Id) AS PostCount,\n        SUM(P.Score) AS TotalScore,\n        AVG(P.ViewCount) AS AverageViewCount\n    FROM \n        PostTypes PT\n    LEFT JOIN \n        Posts P ON PT.Id = P.PostTypeId\n    GROUP BY \n        PT.Name\n)\n\nSELECT \n    UStats.UserId,\n    UStats.DisplayName,\n    UStats.TotalPosts,\n    UStats.Questions,\n    UStats.Answers,\n    UStats.Wikis,\n    UStats.TotalScore,\n    UStats.TotalViews,\n    PTStats.PostTypeName,\n    PTStats.PostCount,\n    PTStats.TotalScore AS PostTypeTotalScore,\n    PTStats.AverageViewCount\nFROM \n    UserStatistics UStats\nJOIN \n    PostTypesStats PTStats ON UStats.TotalPosts > 0\nORDER BY \n    UStats.TotalScore DESC, \n    PTStats.PostTypeName;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 178, in _run_single_node\n    out_tbl = self._run_on_duckdb(node.sql)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 104, in _run_on_duckdb\n    return self.con.execute(sql).arrow()\n           ^^^^^^^^^^^^^^^^^^^^^\nduckdb.duckdb.InvalidInputException: Invalid Input Error: arrow_scan: get_next failed(): NotImplemented: Function 'array_filter' has no kernel matching input types (string_view, bool)\n", "engine_mem_mb": 500000}
{"query_id": "13098.sql", "original_sql": "\nSELECT \n    U.DisplayName AS UserDisplayName,\n    U.Reputation,\n    COUNT(P.Id) AS TotalPosts,\n    SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionsCount,\n    SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswersCount,\n    SUM(P.ViewCount) AS TotalViews,\n    SUM(P.Score) AS TotalScore,\n    AVG(COALESCE(LENGTH(P.Body), 0)) AS AveragePostLength,\n    COUNT(C.Id) AS TotalComments,\n    COUNT(B.Id) AS TotalBadges\nFROM \n    Users U\nLEFT JOIN \n    Posts P ON U.Id = P.OwnerUserId\nLEFT JOIN \n    Comments C ON P.Id = C.PostId\nLEFT JOIN \n    Badges B ON U.Id = B.UserId\nWHERE \n    U.CreationDate < TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '1 year'  \nGROUP BY \n    U.DisplayName, U.Reputation\nORDER BY \n    TotalPosts DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH filtered_users AS (\n    SELECT Id, DisplayName, Reputation\n    FROM Users\n    WHERE CreationDate < TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '1 year'\n),\npost_stats AS (\n    SELECT\n        p.OwnerUserId AS UserId,\n        COUNT(p.Id) AS TotalPosts,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionsCount,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswersCount,\n        SUM(p.ViewCount) AS TotalViews,\n        SUM(p.Score) AS TotalScore,\n        SUM(LENGTH(p.Body)) AS SumBodyLen,\n        COUNT(p.Id) AS PostCntForAvg\n    FROM Posts p\n    GROUP BY p.OwnerUserId\n),\ncomment_stats AS (\n    SELECT\n        p.OwnerUserId AS UserId,\n        COUNT(c.Id) AS TotalComments\n    FROM Posts p\n    JOIN Comments c ON p.Id = c.PostId\n    GROUP BY p.OwnerUserId\n)\nSELECT\n    u.Id AS UserId,\n    u.DisplayName AS UserDisplayName,\n    u.Reputation,\n    COALESCE(ps.TotalPosts,0) AS TotalPosts,\n    COALESCE(ps.QuestionsCount,0) AS QuestionsCount,\n    COALESCE(ps.AnswersCount,0) AS AnswersCount,\n    COALESCE(ps.TotalViews,0) AS TotalViews,\n    COALESCE(ps.TotalScore,0) AS TotalScore,\n    CASE WHEN COALESCE(ps.PostCntForAvg,0)=0 THEN 0\n         ELSE CAST(ps.SumBodyLen AS DOUBLE) / ps.PostCntForAvg END AS AveragePostLength,\n    COALESCE(cs.TotalComments,0) AS TotalComments\nFROM filtered_users u\nLEFT JOIN post_stats ps ON u.Id = ps.UserId\nLEFT JOIN comment_stats cs ON u.Id = cs.UserId;", "sql2": "SELECT\n    s1.UserDisplayName,\n    s1.Reputation,\n    s1.TotalPosts,\n    s1.QuestionsCount,\n    s1.AnswersCount,\n    s1.TotalViews,\n    s1.TotalScore,\n    s1.AveragePostLength,\n    s1.TotalComments,\n    COALESCE(b.TotalBadges,0) AS TotalBadges\nFROM s1\nLEFT JOIN (\n    SELECT UserId, COUNT(Id) AS TotalBadges\n    FROM Badges\n    GROUP BY UserId\n) b ON s1.UserId = b.UserId\nORDER BY s1.TotalPosts DESC\nLIMIT 100;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "13124.sql", "original_sql": "\nSELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.Score,\n    p.ViewCount,\n    u.DisplayName AS OwnerName,\n    COUNT(c.Id) AS CommentCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n    COUNT(DISTINCT ph.Id) AS EditCount,\n    MIN(ph.CreationDate) AS FirstEditDate,\n    MAX(ph.CreationDate) AS LastEditDate\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nLEFT JOIN \n    PostHistory ph ON p.Id = ph.PostId\nWHERE \n    p.PostTypeId = 1 \nGROUP BY \n    p.Id, p.Title, p.CreationDate, p.Score, p.ViewCount, u.DisplayName\nORDER BY \n    p.CreationDate DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    p.Id AS PostId,\n    COUNT(DISTINCT c.Id) AS CommentCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n    COUNT(DISTINCT ph.Id) AS EditCount,\n    MIN(ph.CreationDate) AS FirstEditDate,\n    MAX(ph.CreationDate) AS LastEditDate\nFROM Posts p\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Votes v ON p.Id = v.PostId\nLEFT JOIN PostHistory ph ON p.Id = ph.PostId\nWHERE p.PostTypeId = 1\nGROUP BY p.Id;", "sql2": "SELECT \n    s1.PostId,\n    p.Title,\n    p.CreationDate,\n    p.Score,\n    p.ViewCount,\n    u.DisplayName AS OwnerName,\n    s1.CommentCount,\n    s1.UpVotes,\n    s1.DownVotes,\n    s1.EditCount,\n    s1.FirstEditDate,\n    s1.LastEditDate\nFROM s1\nJOIN Posts p ON s1.PostId = p.Id\nJOIN Users u ON p.OwnerUserId = u.Id\nORDER BY p.CreationDate DESC\nLIMIT 100;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "13160.sql", "original_sql": "WITH PostStats AS (\n    SELECT \n        P.Id AS PostId,\n        P.PostTypeId,\n        P.CreationDate,\n        P.Score,\n        P.ViewCount,\n        COALESCE(COUNT(CASE WHEN C.Id IS NOT NULL THEN 1 END), 0) AS CommentCount,\n        COALESCE(COUNT(DISTINCT V.Id), 0) AS VoteCount\n    FROM \n        Posts P\n    LEFT JOIN \n        Comments C ON P.Id = C.PostId\n    LEFT JOIN \n        Votes V ON P.Id = V.PostId\n    GROUP BY \n        P.Id, P.PostTypeId, P.CreationDate, P.Score, P.ViewCount\n),\nUserStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.Reputation,\n        COUNT(DISTINCT B.Id) AS BadgeCount,\n        COUNT(DISTINCT P.Id) AS TotalPosts\n    FROM \n        Users U\n    LEFT JOIN \n        Badges B ON U.Id = B.UserId\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    GROUP BY \n        U.Id, U.Reputation\n)\nSELECT \n    PS.PostId,\n    PS.PostTypeId,\n    PS.CreationDate,\n    PS.Score,\n    PS.ViewCount,\n    PS.CommentCount,\n    PS.VoteCount,\n    US.UserId,\n    US.Reputation,\n    US.BadgeCount,\n    US.TotalPosts\nFROM \n    PostStats PS\nJOIN \n    Users U ON PS.PostTypeId = U.Id\nJOIN \n    UserStats US ON U.Id = US.UserId\nORDER BY \n    PS.Score DESC, PS.ViewCount DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    P.Id AS PostId,\n    P.PostTypeId,\n    P.CreationDate,\n    P.Score,\n    P.ViewCount,\n    COALESCE(COUNT(CASE WHEN C.Id IS NOT NULL THEN 1 END), 0) AS CommentCount,\n    COALESCE(COUNT(DISTINCT V.Id), 0) AS VoteCount\nFROM Posts P\nLEFT JOIN Comments C ON P.Id = C.PostId\nLEFT JOIN Votes V ON P.Id = V.PostId\nGROUP BY P.Id, P.PostTypeId, P.CreationDate, P.Score, P.ViewCount;", "sql2": "WITH UserStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.Reputation,\n        COUNT(DISTINCT B.Id) AS BadgeCount,\n        COUNT(DISTINCT P.Id) AS TotalPosts\n    FROM Users U\n    LEFT JOIN Badges B ON U.Id = B.UserId\n    LEFT JOIN Posts P ON U.Id = P.OwnerUserId\n    GROUP BY U.Id, U.Reputation\n)\nSELECT \n    s1.PostId,\n    s1.PostTypeId,\n    s1.CreationDate,\n    s1.Score,\n    s1.ViewCount,\n    s1.CommentCount,\n    s1.VoteCount,\n    US.UserId,\n    US.Reputation,\n    US.BadgeCount,\n    US.TotalPosts\nFROM s1\nJOIN Users U ON s1.PostTypeId = U.Id\nJOIN UserStats US ON U.Id = US.UserId\nORDER BY s1.Score DESC, s1.ViewCount DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "13165.sql", "original_sql": "WITH UserPostStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(p.Id) AS PostCount,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        SUM(CASE WHEN p.Score > 0 THEN 1 ELSE 0 END) AS PositiveScorePosts,\n        AVG(p.ViewCount) AS AvgViewCount,\n        AVG(p.Score) AS AvgScore\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    GROUP BY \n        u.Id, u.DisplayName\n),\nPostHistoryStats AS (\n    SELECT\n        ph.UserId,\n        COUNT(ph.Id) AS EditCount,\n        COUNT(DISTINCT ph.PostId) AS PostsEdited\n    FROM\n        PostHistory ph\n    WHERE\n        ph.PostHistoryTypeId IN (4, 5, 6, 24)  \n    GROUP BY\n        ph.UserId\n),\nCombinedStats AS (\n    SELECT\n        ups.UserId,\n        ups.DisplayName,\n        ups.PostCount,\n        ups.QuestionCount,\n        ups.AnswerCount,\n        ups.PositiveScorePosts,\n        ups.AvgViewCount,\n        ups.AvgScore,\n        COALESCE(phe.EditCount, 0) AS EditCount,\n        COALESCE(phe.PostsEdited, 0) AS PostsEdited\n    FROM\n        UserPostStats ups\n    LEFT JOIN\n        PostHistoryStats phe ON ups.UserId = phe.UserId\n)\nSELECT \n    UserId,\n    DisplayName,\n    PostCount,\n    QuestionCount,\n    AnswerCount,\n    PositiveScorePosts,\n    AvgViewCount,\n    AvgScore,\n    EditCount,\n    PostsEdited\nFROM \n    CombinedStats\nORDER BY \n    PostCount DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT u.Id AS UserId,\n       u.DisplayName,\n       COUNT(p.Id) AS PostCount,\n       SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n       SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n       SUM(CASE WHEN p.Score > 0 THEN 1 ELSE 0 END) AS PositiveScorePosts,\n       AVG(p.ViewCount) AS AvgViewCount,\n       AVG(p.Score) AS AvgScore\nFROM Users u\nLEFT JOIN Posts p ON u.Id = p.OwnerUserId\nGROUP BY u.Id, u.DisplayName;", "sql2": "WITH PostHistoryStats AS (\n    SELECT ph.UserId,\n           COUNT(ph.Id) AS EditCount,\n           COUNT(DISTINCT ph.PostId) AS PostsEdited\n    FROM PostHistory ph\n    WHERE ph.PostHistoryTypeId IN (4, 5, 6, 24)\n    GROUP BY ph.UserId\n)\nSELECT s1.UserId,\n       s1.DisplayName,\n       s1.PostCount,\n       s1.QuestionCount,\n       s1.AnswerCount,\n       s1.PositiveScorePosts,\n       s1.AvgViewCount,\n       s1.AvgScore,\n       COALESCE(phs.EditCount, 0) AS EditCount,\n       COALESCE(phs.PostsEdited, 0) AS PostsEdited\nFROM s1\nLEFT JOIN PostHistoryStats phs ON s1.UserId = phs.UserId\nORDER BY s1.PostCount DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "13200.sql", "original_sql": "WITH PostStats AS (\n    SELECT \n        p.Id AS PostId,\n        p.PostTypeId,\n        COUNT(c.Id) AS CommentCount,\n        COUNT(v.Id) AS VoteCount,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVoteCount,  \n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVoteCount \n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    WHERE \n        p.CreationDate >= cast('2024-10-01 12:34:56' as timestamp) - INTERVAL '1 month' \n    GROUP BY \n        p.Id, p.PostTypeId\n),\nUserStats AS (\n    SELECT \n        u.Id AS UserId,\n        COUNT(DISTINCT p.Id) AS PostCount,\n        SUM(u.UpVotes) AS TotalUpVotes,\n        SUM(u.DownVotes) AS TotalDownVotes\n    FROM \n        Users u\n    JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    GROUP BY \n        u.Id\n)\nSELECT \n    u.UserId,\n    u.PostCount,\n    u.TotalUpVotes,\n    u.TotalDownVotes,\n    ps.PostId,\n    ps.PostTypeId,\n    ps.CommentCount,\n    ps.VoteCount,\n    ps.UpVoteCount,\n    ps.DownVoteCount\nFROM \n    UserStats u\nJOIN \n    PostStats ps ON u.UserId = ps.PostId\nORDER BY \n    u.PostCount DESC, ps.VoteCount DESC\nLIMIT 100;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'postid' not found in 'ps'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"ps\" }), name: \"postid\" }, valid_fields: [Column { relation: Some(Bare { table: \"u\" }), name: \"userid\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"postcount\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"totalupvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"totaldownvotes\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"count\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "13201.sql", "original_sql": "WITH PostStats AS (\n    SELECT \n        pt.Name AS PostType,\n        COUNT(p.Id) AS PostCount,\n        AVG(p.Score) AS AvgScore,\n        SUM(p.ViewCount) AS TotalViews,\n        AVG(p.AnswerCount) AS AvgAnswerCount,\n        AVG(p.CommentCount) AS AvgCommentCount\n    FROM \n        Posts p\n    JOIN \n        PostTypes pt ON p.PostTypeId = pt.Id\n    GROUP BY \n        pt.Name\n),\nUserStats AS (\n    SELECT \n        u.DisplayName,\n        COUNT(b.Id) AS BadgeCount,\n        MAX(u.Reputation) AS MaxReputation,\n        AVG(u.Reputation) AS AvgReputation\n    FROM \n        Users u\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    GROUP BY \n        u.DisplayName\n)\nSELECT \n    ps.PostType,\n    ps.PostCount,\n    ps.AvgScore,\n    ps.TotalViews,\n    ps.AvgAnswerCount,\n    ps.AvgCommentCount,\n    us.DisplayName AS UserWithMostBadges,\n    us.BadgeCount,\n    us.MaxReputation,\n    us.AvgReputation\nFROM \n    PostStats ps\nCROSS JOIN \n    (SELECT \n        DisplayName, \n        BadgeCount, \n        MaxReputation, \n        AvgReputation\n     FROM \n        UserStats \n     ORDER BY \n        BadgeCount DESC \n     LIMIT 1) us\nORDER BY \n    ps.PostCount DESC;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Collection([Diagnostic(Diagnostic { kind: Error, message: \"column 'posttype' not found in 's1'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"posttype\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"badgecount\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"maxreputation\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"avgreputation\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'postcount' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column s1.count\", span: None }, DiagnosticNote { message: \"possible column tu.badgecount\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"postcount\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"badgecount\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"maxreputation\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"avgreputation\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'avgscore' not found in 's1'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"avgscore\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"badgecount\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"maxreputation\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"avgreputation\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'totalviews' not found in 's1'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"totalviews\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"badgecount\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"maxreputation\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"avgreputation\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'avganswercount' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column tu.badgecount\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"avganswercount\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"badgecount\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"maxreputation\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"avgreputation\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'avgcommentcount' not found in 's1'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"avgcommentcount\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"badgecount\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"maxreputation\" }, Column { relation: Some(Bare { table: \"tu\" }), name: \"avgreputation\" }] }, Some(\"\")))])\n", "engine_mem_mb": 500000}
{"query_id": "13232.sql", "original_sql": "SELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    u.DisplayName AS OwnerDisplayName,\n    COUNT(DISTINCT c.Id) AS CommentCount,\n    COUNT(DISTINCT v.Id) AS VoteCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n    SUM(CASE WHEN b.UserId IS NOT NULL THEN 1 ELSE 0 END) AS BadgeCount\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nLEFT JOIN \n    Badges b ON u.Id = b.UserId\nWHERE \n    p.CreationDate >= '2023-01-01' \nGROUP BY \n    p.Id, p.Title, p.CreationDate, u.DisplayName\nORDER BY \n    p.CreationDate DESC\nLIMIT 100;", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "WITH comment_agg AS (\n    SELECT PostId, COUNT(*) AS CommentCount\n    FROM Comments\n    GROUP BY PostId\n),\nvote_agg AS (\n    SELECT \n        PostId,\n        COUNT(*) AS VoteCount,\n        SUM(CASE WHEN VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM Votes\n    GROUP BY PostId\n),\nbadge_agg AS (\n    SELECT UserId, COUNT(*) AS BadgeCount\n    FROM Badges\n    GROUP BY UserId\n)\nSELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    u.DisplayName AS OwnerDisplayName,\n    COALESCE(ca.CommentCount,0) AS CommentCount,\n    COALESCE(va.VoteCount,0) AS VoteCount,\n    COALESCE(va.UpVotes,0) AS UpVotes,\n    COALESCE(va.DownVotes,0) AS DownVotes,\n    COALESCE(ba.BadgeCount,0) AS BadgeCount\nFROM Posts p\nJOIN Users u ON p.OwnerUserId = u.Id\nLEFT JOIN comment_agg ca ON p.Id = ca.PostId\nLEFT JOIN vote_agg va ON p.Id = va.PostId\nLEFT JOIN badge_agg ba ON p.OwnerUserId = ba.UserId\nWHERE p.CreationDate >= '2023-01-01';", "sql2": "SELECT *\nFROM s1\nORDER BY CreationDate DESC\nLIMIT 100;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "13281.sql", "original_sql": "SELECT \n    u.Id AS UserId,\n    u.DisplayName,\n    COUNT(DISTINCT p.Id) AS TotalPosts,\n    SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions,\n    SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS Answers,\n    AVG(COALESCE(p.Score, 0)) AS AvgPostScore,\n    AVG(COALESCE(p.ViewCount, 0)) AS AvgViewCount,\n    COUNT(DISTINCT c.Id) AS TotalComments,\n    COUNT(DISTINCT b.Id) AS TotalBadges\nFROM \n    Users u\nLEFT JOIN \n    Posts p ON u.Id = p.OwnerUserId\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Badges b ON u.Id = b.UserId\nWHERE \n    u.Reputation > 1000\nGROUP BY \n    u.Id, u.DisplayName\nORDER BY \n    TotalPosts DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT u.Id AS UserId,\n       u.DisplayName,\n       COUNT(p.Id) AS TotalPosts,\n       SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions,\n       SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS Answers,\n       AVG(COALESCE(p.Score,0)) AS AvgPostScore,\n       AVG(COALESCE(p.ViewCount,0)) AS AvgViewCount\nFROM Users u\nLEFT JOIN Posts p ON u.Id = p.OwnerUserId\nWHERE u.Reputation > 1000\nGROUP BY u.Id, u.DisplayName", "sql2": "WITH comment_agg AS (\n    SELECT p.OwnerUserId AS UserId,\n           COUNT(DISTINCT c.Id) AS TotalComments\n    FROM Comments c\n    JOIN Posts p ON c.PostId = p.Id\n    GROUP BY p.OwnerUserId\n),\nbadge_agg AS (\n    SELECT b.UserId,\n           COUNT(DISTINCT b.Id) AS TotalBadges\n    FROM Badges b\n    GROUP BY b.UserId\n)\nSELECT s1.UserId,\n       s1.DisplayName,\n       s1.TotalPosts,\n       s1.Questions,\n       s1.Answers,\n       s1.AvgPostScore,\n       s1.AvgViewCount,\n       COALESCE(ca.TotalComments,0) AS TotalComments,\n       COALESCE(ba.TotalBadges,0) AS TotalBadges\nFROM s1\nLEFT JOIN comment_agg ca ON s1.UserId = ca.UserId\nLEFT JOIN badge_agg ba ON s1.UserId = ba.UserId\nORDER BY s1.TotalPosts DESC\nLIMIT 100;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "13287.sql", "original_sql": "WITH PostStats AS (\n    SELECT \n        pt.Name AS PostType,\n        COUNT(p.Id) AS TotalPosts,\n        AVG(p.Score) AS AverageScore,\n        SUM(COALESCE(c.CommentCount, 0)) AS TotalComments\n    FROM \n        Posts p\n    JOIN \n        PostTypes pt ON p.PostTypeId = pt.Id\n    LEFT JOIN (\n        SELECT \n            PostId, \n            COUNT(Id) AS CommentCount \n        FROM \n            Comments \n        GROUP BY \n            PostId\n    ) c ON p.Id = c.PostId\n    GROUP BY \n        pt.Name\n)\n\nSELECT \n    PostType, \n    TotalPosts, \n    AverageScore, \n    TotalComments \nFROM \n    PostStats\nORDER BY \n    TotalPosts DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT pt.Name AS PostType,\n       SUM(com.CommentCount) AS TotalComments\nFROM (\n    SELECT PostId, COUNT(*) AS CommentCount\n    FROM Comments\n    GROUP BY PostId\n) com\nJOIN Posts p ON com.PostId = p.Id\nJOIN PostTypes pt ON p.PostTypeId = pt.Id\nGROUP BY pt.Name;", "sql2": "SELECT pt.Name AS PostType,\n       COUNT(p.Id) AS TotalPosts,\n       AVG(p.Score) AS AverageScore,\n       COALESCE(s1.TotalComments, 0) AS TotalComments\nFROM Posts p\nJOIN PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN s1 ON pt.Name = s1.PostType\nGROUP BY pt.Name, s1.TotalComments\nORDER BY TotalPosts DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "13352.sql", "original_sql": "SELECT \n    pt.Name AS PostType,\n    COUNT(p.Id) AS PostCount,\n    COUNT(DISTINCT u.Id) AS UserCount,\n    COUNT(v.Id) AS VoteCount,\n    COUNT(c.Id) AS CommentCount,\n    AVG(p.Score) AS AvgScore,\n    AVG(p.ViewCount) AS AvgViewCount\nFROM \n    Posts p\nLEFT JOIN \n    PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nGROUP BY \n    pt.Name\nORDER BY \n    PostCount DESC;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 231, in run\n    self._register_downstream_aliases(nid, tbl, id_to_node, adj)\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 169, in _register_downstream_aliases\n    self._register_input_duckdb(alias, tbl)\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 81, in _register_input_duckdb\n    self.con.register(name, obj)\nduckdb.duckdb.InvalidInputException: Invalid Input Error: Provided table/dataframe must have at least one column\n", "engine_mem_mb": 500000}
{"query_id": "13386.sql", "original_sql": "\nSELECT \n    U.Reputation AS UserReputation,\n    COUNT(P.Id) AS TotalPosts,\n    SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n    SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers,\n    SUM(CASE WHEN V.CreationDate IS NOT NULL THEN 1 ELSE 0 END) AS TotalVotes,\n    AVG(P.Score) AS AveragePostScore,\n    MAX(P.CreationDate) AS MostRecentPost,\n    COUNT(DISTINCT V.UserId) AS UniqueVoters\nFROM \n    Users U\nLEFT JOIN \n    Posts P ON U.Id = P.OwnerUserId\nLEFT JOIN \n    Votes V ON P.Id = V.PostId\nGROUP BY \n    U.Id, U.Reputation\nORDER BY \n    UserReputation DESC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column vagg.userid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"vagg\" }), name: \"userid\" }, Column { relation: Some(Bare { table: \"vagg\" }), name: \"totalvotes\" }, Column { relation: Some(Bare { table: \"vagg\" }), name: \"uniquevoters\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "13419.sql", "original_sql": "\nSELECT \n    p.Title AS PostTitle,\n    p.CreationDate AS PostCreationDate,\n    u.DisplayName AS AuthorDisplayName,\n    COUNT(c.Id) AS CommentCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n    p.ViewCount,\n    p.Score,\n    pt.Name AS PostTypeName\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nJOIN \n    PostTypes pt ON p.PostTypeId = pt.Id\nWHERE \n    p.CreationDate >= '2022-01-01' \nGROUP BY \n    p.Title, p.CreationDate, u.DisplayName, p.ViewCount, p.Score, pt.Name\nORDER BY \n    p.CreationDate DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH comment_agg AS (\n    SELECT PostId, COUNT(*) AS CommentCount\n    FROM Comments\n    GROUP BY PostId\n),\nvote_agg AS (\n    SELECT PostId,\n           SUM(CASE WHEN VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n           SUM(CASE WHEN VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM Votes\n    GROUP BY PostId\n)\nSELECT\n    COALESCE(comment_agg.PostId, vote_agg.PostId) AS PostId,\n    comment_agg.CommentCount,\n    vote_agg.UpVotes,\n    vote_agg.DownVotes\nFROM comment_agg\nFULL OUTER JOIN vote_agg USING (PostId);", "sql2": "SELECT\n    p.Title AS PostTitle,\n    p.CreationDate AS PostCreationDate,\n    u.DisplayName AS AuthorDisplayName,\n    COALESCE(s1.CommentCount, 0) AS CommentCount,\n    COALESCE(s1.UpVotes, 0) AS UpVotes,\n    COALESCE(s1.DownVotes, 0) AS DownVotes,\n    p.ViewCount,\n    p.Score,\n    pt.Name AS PostTypeName\nFROM Posts p\nJOIN Users u ON p.OwnerUserId = u.Id\nJOIN PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN s1 ON p.Id = s1.PostId\nWHERE p.CreationDate >= TIMESTAMP '2022-01-01'\nORDER BY p.CreationDate DESC\nLIMIT 100;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "13423.sql", "original_sql": "WITH UserPostCounts AS (\n    SELECT \n        u.Id AS UserId,\n        COUNT(p.Id) AS PostCount,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    GROUP BY \n        u.Id\n),\nUserVoteCounts AS (\n    SELECT \n        v.UserId,\n        COUNT(v.Id) AS VoteCount,\n        SUM(CASE WHEN vt.Name = 'UpMod' THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN vt.Name = 'DownMod' THEN 1 ELSE 0 END) AS DownVotes\n    FROM \n        Votes v\n    INNER JOIN \n        VoteTypes vt ON v.VoteTypeId = vt.Id\n    GROUP BY \n        v.UserId\n)\nSELECT \n    u.Id AS UserId,\n    u.DisplayName,\n    COALESCE(upc.PostCount, 0) AS PostCount,\n    COALESCE(upc.QuestionCount, 0) AS QuestionCount,\n    COALESCE(upc.AnswerCount, 0) AS AnswerCount,\n    COALESCE(uvc.VoteCount, 0) AS VoteCount,\n    COALESCE(uvc.UpVotes, 0) AS UpVotes,\n    COALESCE(uvc.DownVotes, 0) AS DownVotes\nFROM \n    Users u\nLEFT JOIN \n    UserPostCounts upc ON u.Id = upc.UserId\nLEFT JOIN \n    UserVoteCounts uvc ON u.Id = uvc.UserId\nORDER BY \n    u.Reputation DESC\nLIMIT 100;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 's1'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"u\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"reputation\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"creationdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"lastaccessdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"websiteurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"location\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"aboutme\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"views\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"upvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"downvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"profileimageurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"accountid\" }, Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "13448.sql", "original_sql": "\nWITH PostStats AS (\n    SELECT \n        Posts.Id AS PostId,\n        Posts.PostTypeId,\n        Posts.CreationDate,\n        COUNT(Comments.Id) AS CommentCount,\n        SUM(CASE WHEN Votes.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVoteCount,  \n        SUM(CASE WHEN Votes.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVoteCount  \n    FROM \n        Posts\n    LEFT JOIN \n        Comments ON Comments.PostId = Posts.Id\n    LEFT JOIN \n        Votes ON Votes.PostId = Posts.Id\n    GROUP BY \n        Posts.Id, Posts.PostTypeId, Posts.CreationDate\n),\nUserStats AS (\n    SELECT \n        Users.Id AS UserId,\n        Users.Reputation,\n        COUNT(DISTINCT Posts.Id) AS PostCount,\n        COUNT(DISTINCT Badges.Id) AS BadgeCount\n    FROM \n        Users\n    LEFT JOIN \n        Posts ON Posts.OwnerUserId = Users.Id\n    LEFT JOIN \n        Badges ON Badges.UserId = Users.Id\n    GROUP BY \n        Users.Id, Users.Reputation\n)\nSELECT \n    p.PostId,\n    p.PostTypeId,\n    p.CreationDate,\n    p.CommentCount,\n    p.UpVoteCount,\n    p.DownVoteCount,\n    u.UserId,\n    u.Reputation,\n    u.PostCount,\n    u.BadgeCount\nFROM \n    PostStats p\nJOIN \n    UserStats u ON p.PostTypeId = u.UserId  \nORDER BY \n    p.CreationDate DESC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "WITH UserStats AS (\n    SELECT \n        Users.Id AS UserId,\n        Users.Reputation,\n        COUNT(DISTINCT Posts.Id) AS PostCount,\n        COUNT(DISTINCT Badges.Id) AS BadgeCount\n    FROM Users\n    LEFT JOIN Posts ON Posts.OwnerUserId = Users.Id\n    LEFT JOIN Badges ON Badges.UserId = Users.Id\n    GROUP BY Users.Id, Users.Reputation\n)\nSELECT UserId, Reputation, PostCount, BadgeCount\nFROM UserStats;", "sql2": "WITH PostStats AS (\n    SELECT \n        Posts.Id AS PostId,\n        Posts.PostTypeId,\n        Posts.CreationDate,\n        COUNT(Comments.Id) AS CommentCount,\n        SUM(CASE WHEN Votes.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVoteCount,\n        SUM(CASE WHEN Votes.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVoteCount\n    FROM Posts\n    LEFT JOIN Comments ON Comments.PostId = Posts.Id\n    LEFT JOIN Votes ON Votes.PostId = Posts.Id\n    GROUP BY Posts.Id, Posts.PostTypeId, Posts.CreationDate\n)\nSELECT \n    p.PostId,\n    p.PostTypeId,\n    p.CreationDate,\n    p.CommentCount,\n    p.UpVoteCount,\n    p.DownVoteCount,\n    u.UserId,\n    u.Reputation,\n    u.PostCount,\n    u.BadgeCount\nFROM PostStats p\nJOIN s1 u ON p.PostTypeId = u.UserId\nORDER BY p.CreationDate DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "13475.sql", "original_sql": "\nWITH PostCounts AS (\n    SELECT \n        pt.Name AS PostType,\n        COUNT(p.Id) AS TotalPosts,\n        COUNT(DISTINCT v.UserId) AS TotalVotes,\n        COUNT(DISTINCT u.Id) AS TotalUsers\n    FROM \n        Posts p\n    JOIN \n        PostTypes pt ON p.PostTypeId = pt.Id\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    LEFT JOIN \n        Users u ON p.OwnerUserId = u.Id\n    GROUP BY \n        pt.Name\n)\n\nSELECT \n    PostType,\n    TotalPosts,\n    TotalVotes,\n    TotalUsers,\n    TotalVotes * 1.0 / NULLIF(TotalPosts, 0) AS VotesPerPost,\n    TotalUsers * 1.0 / NULLIF(TotalPosts, 0) AS UsersPerPost\nFROM \n    PostCounts\nORDER BY \n    TotalPosts DESC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT \n    pt.Name AS PostType,\n    COUNT(p.Id) AS TotalPosts,\n    COUNT(DISTINCT v.UserId) AS TotalVotes,\n    COUNT(DISTINCT u.Id) AS TotalUsers\nFROM Posts p\nJOIN PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN Votes v ON p.Id = v.PostId\nLEFT JOIN Users u ON p.OwnerUserId = u.Id\nGROUP BY pt.Name;", "sql2": "SELECT \n    PostType,\n    TotalPosts,\n    TotalVotes,\n    TotalUsers,\n    TotalVotes * 1.0 / NULLIF(TotalPosts, 0) AS VotesPerPost,\n    TotalUsers * 1.0 / NULLIF(TotalPosts, 0) AS UsersPerPost\nFROM s1\nORDER BY TotalPosts DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "13494.sql", "original_sql": "WITH UserPostStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.Reputation,\n        COUNT(P.Id) AS TotalPosts,\n        COUNT(CASE WHEN P.PostTypeId = 1 THEN 1 END) AS Questions,\n        COUNT(CASE WHEN P.PostTypeId = 2 THEN 1 END) AS Answers,\n        SUM(P.Score) AS TotalScore,\n        SUM(COALESCE(P.ViewCount, 0)) AS TotalViews,\n        AVG(P.ViewCount) AS AvgViewsPerPost,\n        COUNT(COALESCE(C.Id, NULL)) AS TotalComments\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    LEFT JOIN \n        Comments C ON P.Id = C.PostId\n    GROUP BY \n        U.Id, U.Reputation\n)\nSELECT \n    UserId,\n    Reputation,\n    TotalPosts,\n    Questions,\n    Answers,\n    TotalScore,\n    TotalViews,\n    AvgViewsPerPost,\n    TotalComments\nFROM \n    UserPostStats\nORDER BY \n    Reputation DESC, TotalPosts DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    U.Id AS UserId,\n    U.Reputation,\n    COUNT(P.Id) AS TotalPosts,\n    COUNT(CASE WHEN P.PostTypeId = 1 THEN 1 END) AS Questions,\n    COUNT(CASE WHEN P.PostTypeId = 2 THEN 1 END) AS Answers,\n    COALESCE(SUM(P.Score),0) AS TotalScore,\n    COALESCE(SUM(P.ViewCount),0) AS TotalViews,\n    CASE WHEN COUNT(P.Id) = 0 THEN 0 ELSE SUM(P.ViewCount)::DOUBLE / COUNT(P.Id) END AS AvgViewsPerPost\nFROM Users U\nLEFT JOIN Posts P ON U.Id = P.OwnerUserId\nGROUP BY U.Id, U.Reputation", "sql2": "SELECT \n    s1.UserId,\n    s1.Reputation,\n    s1.TotalPosts,\n    s1.Questions,\n    s1.Answers,\n    s1.TotalScore,\n    s1.TotalViews,\n    s1.AvgViewsPerPost,\n    COALESCE(c.CommentCount,0) AS TotalComments\nFROM s1\nLEFT JOIN (\n    SELECT \n        P.OwnerUserId AS UserId,\n        COUNT(C.Id) AS CommentCount\n    FROM Comments C\n    JOIN Posts P ON C.PostId = P.Id\n    GROUP BY P.OwnerUserId\n) c ON s1.UserId = c.UserId\nORDER BY s1.Reputation DESC, s1.TotalPosts DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "13500.sql", "original_sql": "\nSELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.ViewCount,\n    p.Score,\n    COUNT(c.Id) AS CommentCount,\n    COUNT(DISTINCT v.Id) AS VoteCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVoteCount,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVoteCount,\n    u.DisplayName AS OwnerDisplayName,\n    pt.Name AS PostTypeName\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nJOIN \n    PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nWHERE \n    p.CreationDate >= TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '1 year'  \nGROUP BY \n    p.Id, p.Title, p.CreationDate, p.ViewCount, p.Score, u.DisplayName, pt.Name\nORDER BY \n    p.CreationDate DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    p.Id AS PostId,\n    COUNT(c.Id) AS CommentCount,\n    COUNT(DISTINCT v.Id) AS VoteCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVoteCount,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVoteCount\nFROM \n    Posts p\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nWHERE \n    p.CreationDate >= TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '1 year'\nGROUP BY \n    p.Id;", "sql2": "SELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.ViewCount,\n    p.Score,\n    s1.CommentCount,\n    s1.VoteCount,\n    s1.UpVoteCount,\n    s1.DownVoteCount,\n    u.DisplayName AS OwnerDisplayName,\n    pt.Name AS PostTypeName\nFROM \n    Posts p\nJOIN \n    s1 ON p.Id = s1.PostId\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nJOIN \n    PostTypes pt ON p.PostTypeId = pt.Id\nWHERE \n    p.CreationDate >= TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '1 year'\nORDER BY \n    p.CreationDate DESC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "13504.sql", "original_sql": "\nWITH PostStats AS (\n    SELECT \n        p.Id AS PostId,\n        p.PostTypeId,\n        COUNT(c.Id) AS CommentCount,\n        COUNT(DISTINCT v.Id) AS VoteCount,\n        MAX(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVote,\n        MAX(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVote,\n        MAX(p.CreationDate) AS LastActivityDate\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    GROUP BY \n        p.Id, p.PostTypeId\n),\nUserStats AS (\n    SELECT \n        u.Id AS UserId,\n        COUNT(b.Id) AS BadgeCount,\n        SUM(u.Views) AS TotalViews,\n        SUM(u.UpVotes) AS TotalUpVotes,\n        SUM(u.DownVotes) AS TotalDownVotes\n    FROM \n        Users u\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    GROUP BY \n        u.Id\n),\nPostTypeBreakdown AS (\n    SELECT \n        pt.Name AS PostType,\n        COUNT(p.Id) AS TotalPosts,\n        SUM(ps.CommentCount) AS TotalComments,\n        SUM(ps.VoteCount) AS TotalVotes\n    FROM \n        PostTypes pt\n    LEFT JOIN \n        Posts p ON pt.Id = p.PostTypeId\n    LEFT JOIN \n        PostStats ps ON p.Id = ps.PostId\n    GROUP BY \n        pt.Name\n)\nSELECT \n    u.UserId,\n    u.BadgeCount,\n    u.TotalViews,\n    u.TotalUpVotes,\n    u.TotalDownVotes,\n    pt.PostType,\n    pt.TotalPosts,\n    pt.TotalComments,\n    pt.TotalVotes\nFROM \n    UserStats u\nJOIN \n    PostTypeBreakdown pt ON u.UserId = pt.TotalPosts\nORDER BY \n    u.TotalViews DESC, \n    pt.TotalPosts DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    p.Id AS PostId,\n    p.PostTypeId,\n    COUNT(c.Id) AS CommentCount,\n    COUNT(DISTINCT v.Id) AS VoteCount,\n    MAX(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVote,\n    MAX(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVote,\n    MAX(p.CreationDate) AS LastActivityDate\nFROM Posts p\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Votes v ON p.Id = v.PostId\nGROUP BY p.Id, p.PostTypeId;", "sql2": "WITH UserStats AS (\n    SELECT \n        u.Id AS UserId,\n        COUNT(b.Id) AS BadgeCount,\n        SUM(u.Views) AS TotalViews,\n        SUM(u.UpVotes) AS TotalUpVotes,\n        SUM(u.DownVotes) AS TotalDownVotes\n    FROM Users u\n    LEFT JOIN Badges b ON u.Id = b.UserId\n    GROUP BY u.Id\n),\nPostTypeBreakdown AS (\n    SELECT \n        pt.Name AS PostType,\n        COUNT(p.Id) AS TotalPosts,\n        SUM(s.CommentCount) AS TotalComments,\n        SUM(s.VoteCount) AS TotalVotes\n    FROM PostTypes pt\n    LEFT JOIN Posts p ON pt.Id = p.PostTypeId\n    LEFT JOIN s1 s ON p.Id = s.PostId\n    GROUP BY pt.Name\n)\nSELECT \n    u.UserId,\n    u.BadgeCount,\n    u.TotalViews,\n    u.TotalUpVotes,\n    u.TotalDownVotes,\n    pt.PostType,\n    pt.TotalPosts,\n    pt.TotalComments,\n    pt.TotalVotes\nFROM UserStats u\nJOIN PostTypeBreakdown pt ON u.UserId = pt.TotalPosts\nORDER BY u.TotalViews DESC, pt.TotalPosts DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "13511.sql", "original_sql": "\nSELECT \n    p.Id AS PostId,\n    p.Title,\n    p.ViewCount,\n    p.CreationDate,\n    u.DisplayName AS OwnerDisplayName,\n    COUNT(DISTINCT c.Id) AS CommentCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVoteCount,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVoteCount,\n    COUNT(DISTINCT b.Id) AS BadgeCount\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nLEFT JOIN \n    Badges b ON u.Id = b.UserId\nGROUP BY \n    p.Id, p.Title, p.ViewCount, p.CreationDate, u.DisplayName\nORDER BY \n    p.CreationDate DESC\nLIMIT 100;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "13531.sql", "original_sql": "\nSELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    u.DisplayName AS OwnerDisplayName,\n    COUNT(c.Id) AS CommentCount,\n    COUNT(DISTINCT v.Id) AS VoteCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVoteCount,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVoteCount,\n    p.ViewCount,\n    p.Score,\n    pt.Name AS PostTypeName\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nJOIN \n    PostTypes pt ON p.PostTypeId = pt.Id\nWHERE \n    p.CreationDate >= CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '1 year'  \nGROUP BY \n    p.Id, p.Title, p.CreationDate, u.DisplayName, p.ViewCount, p.Score, pt.Name\nORDER BY \n    p.CreationDate DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT p.Id AS PostId,\n       COALESCE(cc.CommentCount,0) AS CommentCount,\n       COALESCE(vc.VoteCount,0) AS VoteCount,\n       COALESCE(vc.UpVoteCount,0) AS UpVoteCount,\n       COALESCE(vc.DownVoteCount,0) AS DownVoteCount\nFROM Posts p\nLEFT JOIN (\n    SELECT PostId, COUNT(*) AS CommentCount\n    FROM Comments\n    GROUP BY PostId\n) cc ON p.Id = cc.PostId\nLEFT JOIN (\n    SELECT PostId,\n           COUNT(*) AS VoteCount,\n           SUM(CASE WHEN VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVoteCount,\n           SUM(CASE WHEN VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVoteCount\n    FROM Votes\n    GROUP BY PostId\n) vc ON p.Id = vc.PostId\nWHERE p.CreationDate >= CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '1 year';", "sql2": "SELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    u.DisplayName AS OwnerDisplayName,\n    s1.CommentCount,\n    s1.VoteCount,\n    s1.UpVoteCount,\n    s1.DownVoteCount,\n    p.ViewCount,\n    p.Score,\n    pt.Name AS PostTypeName\nFROM Posts p\nJOIN Users u ON p.OwnerUserId = u.Id\nJOIN PostTypes pt ON p.PostTypeId = pt.Id\nJOIN s1 ON p.Id = s1.PostId\nWHERE p.CreationDate >= CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '1 year'\nORDER BY p.CreationDate DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "13544.sql", "original_sql": "SELECT \n    pt.Name AS PostType,\n    COUNT(DISTINCT p.Id) AS TotalPosts,\n    COUNT(DISTINCT u.Id) AS TotalUsers,\n    COUNT(DISTINCT c.Id) AS TotalComments,\n    COUNT(DISTINCT v.Id) AS TotalVotes\nFROM \n    PostTypes pt\nLEFT JOIN \n    Posts p ON p.PostTypeId = pt.Id\nLEFT JOIN \n    Users u ON u.Id = p.OwnerUserId\nLEFT JOIN \n    Comments c ON c.PostId = p.Id\nLEFT JOIN \n    Votes v ON v.PostId = p.Id\nGROUP BY \n    pt.Id, pt.Name\nORDER BY \n    pt.Id;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT pt.Id AS PostTypeId,\n       pt.Name AS PostType,\n       COUNT(DISTINCT p.Id) AS TotalPosts,\n       COUNT(DISTINCT u.Id) AS TotalUsers\nFROM PostTypes pt\nLEFT JOIN Posts p ON p.PostTypeId = pt.Id\nLEFT JOIN Users u ON u.Id = p.OwnerUserId\nGROUP BY pt.Id, pt.Name", "sql2": "SELECT s1.PostType,\n       s1.TotalPosts,\n       s1.TotalUsers,\n       COALESCE(c.CommentCount, 0) AS TotalComments,\n       COALESCE(v.VoteCount, 0) AS TotalVotes\nFROM s1\nLEFT JOIN (\n    SELECT p.PostTypeId, COUNT(DISTINCT c.Id) AS CommentCount\n    FROM Posts p\n    JOIN Comments c ON c.PostId = p.Id\n    GROUP BY p.PostTypeId\n) c ON c.PostTypeId = s1.PostTypeId\nLEFT JOIN (\n    SELECT p.PostTypeId, COUNT(DISTINCT v.Id) AS VoteCount\n    FROM Posts p\n    JOIN Votes v ON v.PostId = p.Id\n    GROUP BY p.PostTypeId\n) v ON v.PostTypeId = s1.PostTypeId\nORDER BY s1.PostTypeId;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "13555.sql", "original_sql": "SELECT \n    P.Id AS PostId,\n    P.Title,\n    P.CreationDate,\n    P.ViewCount,\n    P.Score,\n    U.DisplayName AS OwnerDisplayName,\n    COUNT(CASE WHEN C.Id IS NOT NULL THEN 1 END) AS CommentCount,\n    COUNT(DISTINCT A.Id) AS AnswerCount,\n    COUNT(DISTINCT V.Id) AS VoteCount\nFROM \n    Posts P\nLEFT JOIN \n    Users U ON P.OwnerUserId = U.Id\nLEFT JOIN \n    Comments C ON P.Id = C.PostId\nLEFT JOIN \n    Posts A ON P.Id = A.ParentId\nLEFT JOIN \n    Votes V ON P.Id = V.PostId\nWHERE \n    P.PostTypeId = 1 \nGROUP BY \n    P.Id, P.Title, P.CreationDate, P.ViewCount, P.Score, U.DisplayName\nORDER BY \n    P.CreationDate DESC;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'postid' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column p.posttypeid\", span: None }, DiagnosticNote { message: \"possible column p.parentid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"postid\" }, valid_fields: [Column { relation: Some(Bare { table: \"p\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"posttypeid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"acceptedanswerid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"parentid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"creationdate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"score\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"viewcount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"body\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"owneruserid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"ownerdisplayname\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lasteditoruserid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lasteditordisplayname\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lasteditdate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lastactivitydate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"title\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"tags\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"answercount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"commentcount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"favoritecount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"closeddate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"communityowneddate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"contentlicense\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"reputation\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"creationdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"lastaccessdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"websiteurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"location\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"aboutme\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"views\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"upvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"downvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"profileimageurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"accountid\" }, Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "13557.sql", "original_sql": "SELECT \n    U.Id AS UserId,\n    U.DisplayName,\n    COUNT(P.Id) AS NumberOfPosts,\n    AVG(U.Reputation) AS AverageReputation,\n    SUM(V.TotalVotes) AS TotalVotes\nFROM \n    Users U\nLEFT JOIN \n    Posts P ON U.Id = P.OwnerUserId\nLEFT JOIN \n    (SELECT \n         PostId,\n         COUNT(*) AS TotalVotes\n     FROM \n         Votes\n     GROUP BY \n         PostId) V ON P.Id = V.PostId\nGROUP BY \n    U.Id, U.DisplayName\nORDER BY \n    NumberOfPosts DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT PostId, COUNT(*) AS TotalVotes FROM Votes GROUP BY PostId;", "sql2": "SELECT U.Id AS UserId,\n       U.DisplayName,\n       COUNT(P.Id) AS NumberOfPosts,\n       AVG(U.Reputation) AS AverageReputation,\n       SUM(COALESCE(s1.TotalVotes, 0)) AS TotalVotes\nFROM Users U\nLEFT JOIN Posts P ON U.Id = P.OwnerUserId\nLEFT JOIN s1 ON P.Id = s1.PostId\nGROUP BY U.Id, U.DisplayName\nORDER BY NumberOfPosts DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "13586.sql", "original_sql": "\nWITH PostStats AS (\n    SELECT \n        P.Id AS PostId,\n        P.PostTypeId,\n        P.CreationDate,\n        P.Score,\n        P.ViewCount,\n        COUNT(CASE WHEN C.Id IS NOT NULL THEN 1 END) AS CommentCount,\n        COUNT(CASE WHEN A.Id IS NOT NULL THEN 1 END) AS AnswerCount,\n        COUNT(DISTINCT V.Id) AS VoteCount\n    FROM \n        Posts P\n    LEFT JOIN \n        Comments C ON P.Id = C.PostId\n    LEFT JOIN \n        Posts A ON P.Id = A.ParentId\n    LEFT JOIN \n        Votes V ON P.Id = V.PostId\n    GROUP BY \n        P.Id, P.PostTypeId, P.CreationDate, P.Score, P.ViewCount\n),\nUserStats AS (\n    SELECT \n        U.Id AS UserId,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges,\n        AVG(U.Reputation) AS AvgReputation\n    FROM \n        Users U\n    LEFT JOIN \n        Badges B ON U.Id = B.UserId\n    GROUP BY \n        U.Id\n)\n\nSELECT \n    PS.PostId,\n    PS.PostTypeId,\n    PS.CreationDate,\n    PS.Score,\n    PS.ViewCount,\n    PS.CommentCount,\n    PS.AnswerCount,\n    PS.VoteCount,\n    US.UserId,\n    US.GoldBadges,\n    US.SilverBadges,\n    US.BronzeBadges,\n    US.AvgReputation\nFROM \n    PostStats PS\nJOIN \n    Users U ON PS.PostTypeId = U.AccountId\nJOIN \n    UserStats US ON U.Id = US.UserId\nORDER BY \n    PS.ViewCount DESC, PS.Score DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    P.Id AS PostId,\n    P.PostTypeId,\n    P.CreationDate,\n    P.Score,\n    P.ViewCount,\n    COUNT(CASE WHEN C.Id IS NOT NULL THEN 1 END) AS CommentCount,\n    COUNT(CASE WHEN A.Id IS NOT NULL THEN 1 END) AS AnswerCount,\n    COUNT(DISTINCT V.Id) AS VoteCount\nFROM Posts P\nLEFT JOIN Comments C ON P.Id = C.PostId\nLEFT JOIN Posts A ON P.Id = A.ParentId\nLEFT JOIN Votes V ON P.Id = V.PostId\nGROUP BY P.Id, P.PostTypeId, P.CreationDate, P.Score, P.ViewCount;", "sql2": "WITH UserStats AS (\n    SELECT \n        U.Id AS UserId,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges,\n        AVG(U.Reputation) AS AvgReputation\n    FROM Users U\n    LEFT JOIN Badges B ON U.Id = B.UserId\n    GROUP BY U.Id\n)\nSELECT \n    PS.PostId,\n    PS.PostTypeId,\n    PS.CreationDate,\n    PS.Score,\n    PS.ViewCount,\n    PS.CommentCount,\n    PS.AnswerCount,\n    PS.VoteCount,\n    US.UserId,\n    US.GoldBadges,\n    US.SilverBadges,\n    US.BronzeBadges,\n    US.AvgReputation\nFROM s1 PS\nJOIN Users U ON PS.PostTypeId = U.AccountId\nJOIN UserStats US ON U.Id = US.UserId\nORDER BY PS.ViewCount DESC, PS.Score DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "13653.sql", "original_sql": "\nWITH UserStatistics AS (\n    SELECT \n        u.Id AS UserId,\n        u.Reputation,\n        COUNT(DISTINCT p.Id) AS PostCount,\n        COUNT(DISTINCT c.Id) AS CommentCount,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    GROUP BY \n        u.Id, u.Reputation\n)\nSELECT \n    u.Id AS UserId,\n    u.DisplayName,\n    us.PostCount,\n    us.CommentCount,\n    us.UpVotes,\n    us.DownVotes,\n    us.Reputation\nFROM \n    Users u\nJOIN \n    UserStatistics us ON u.Id = us.UserId\nORDER BY \n    us.Reputation DESC, \n    us.PostCount DESC\nLIMIT 100;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 's1'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"u\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"reputation\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"creationdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"lastaccessdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"websiteurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"location\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"aboutme\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"views\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"upvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"downvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"profileimageurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"accountid\" }, Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "13659.sql", "original_sql": "\nSELECT \n    P.Id AS PostId,\n    P.Title,\n    P.CreationDate,\n    COUNT(CASE WHEN C.Id IS NOT NULL THEN 1 END) AS CommentCount,\n    COUNT(DISTINCT V.Id) AS VoteCount,\n    COUNT(DISTINCT BH.Id) AS HistoryChangeCount,\n    U.DisplayName AS OwnerDisplayName,\n    U.Reputation AS OwnerReputation\nFROM \n    Posts P\nLEFT JOIN \n    Comments C ON P.Id = C.PostId\nLEFT JOIN \n    Votes V ON P.Id = V.PostId\nLEFT JOIN \n    PostHistory BH ON P.Id = BH.PostId\nLEFT JOIN \n    Users U ON P.OwnerUserId = U.Id\nWHERE \n    P.CreationDate > DATE '2020-01-01' \nGROUP BY \n    P.Id, P.Title, P.CreationDate, U.DisplayName, U.Reputation\nORDER BY \n    P.CreationDate DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT\n    P.Id AS PostId,\n    COUNT(DISTINCT C.Id) AS CommentCount,\n    COUNT(DISTINCT V.Id) AS VoteCount,\n    COUNT(DISTINCT BH.Id) AS HistoryChangeCount\nFROM Posts P\nLEFT JOIN Comments C ON P.Id = C.PostId\nLEFT JOIN Votes V ON P.Id = V.PostId\nLEFT JOIN PostHistory BH ON P.Id = BH.PostId\nWHERE P.CreationDate > DATE '2020-01-01'\nGROUP BY P.Id;", "sql2": "SELECT\n    P.Id AS PostId,\n    P.Title,\n    P.CreationDate,\n    COALESCE(s.CommentCount, 0) AS CommentCount,\n    COALESCE(s.VoteCount, 0) AS VoteCount,\n    COALESCE(s.HistoryChangeCount, 0) AS HistoryChangeCount,\n    U.DisplayName AS OwnerDisplayName,\n    U.Reputation AS OwnerReputation\nFROM Posts P\nLEFT JOIN Users U ON P.OwnerUserId = U.Id\nLEFT JOIN s1 s ON P.Id = s.PostId\nWHERE P.CreationDate > DATE '2020-01-01'\nORDER BY P.CreationDate DESC\nLIMIT 100;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "13694.sql", "original_sql": "WITH UserPostStats AS (\n    SELECT\n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(p.Id) AS PostCount,\n        COALESCE(SUM(p.Score), 0) AS TotalScore,\n        COALESCE(SUM(p.ViewCount), 0) AS TotalViews,\n        COALESCE(SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END), 0) AS QuestionCount,\n        COALESCE(SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END), 0) AS AnswerCount,\n        COALESCE(SUM(p.CommentCount), 0) AS TotalComments\n    FROM\n        Users u\n    LEFT JOIN\n        Posts p ON u.Id = p.OwnerUserId\n    GROUP BY\n        u.Id, u.DisplayName\n)\nSELECT\n    UserId,\n    DisplayName,\n    PostCount,\n    TotalScore,\n    TotalViews,\n    QuestionCount,\n    AnswerCount,\n    TotalComments\nFROM\n    UserPostStats\nORDER BY\n    TotalScore DESC, PostCount DESC;", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "13731.sql", "original_sql": "\nWITH UserVoteStats AS (\n    SELECT \n        U.Id AS UserId,\n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n        COUNT(DISTINCT P.Id) AS PostCount\n    FROM \n        Users U\n    LEFT JOIN \n        Votes V ON U.Id = V.UserId\n    LEFT JOIN \n        Posts P ON V.PostId = P.Id\n    WHERE \n        U.Reputation > 100 \n    GROUP BY \n        U.Id\n),\nPostStats AS (\n    SELECT \n        P.Id AS PostId,\n        P.Title,\n        P.CreationDate,\n        COUNT(DISTINCT C.Id) AS CommentCount,\n        COUNT(DISTINCT V.Id) AS VoteCount,\n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVoteCount,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVoteCount\n    FROM \n        Posts P\n    LEFT JOIN \n        Comments C ON P.Id = C.PostId\n    LEFT JOIN \n        Votes V ON P.Id = V.PostId\n    GROUP BY \n        P.Id, P.Title, P.CreationDate\n)\nSELECT \n    U.DisplayName AS UserDisplayName,\n    U.Reputation,\n    U.CreationDate AS UserCreationDate,\n    UVote.UpVotes,\n    UVote.DownVotes,\n    PStats.PostId,\n    PStats.Title,\n    PStats.CreationDate AS PostCreationDate,\n    PStats.CommentCount,\n    PStats.VoteCount,\n    PStats.UpVoteCount,\n    PStats.DownVoteCount\nFROM \n    UserVoteStats UVote\nJOIN \n    Users U ON UVote.UserId = U.Id\nJOIN \n    PostStats PStats ON U.Id = PStats.PostId \nORDER BY \n    U.Reputation DESC, \n    PStats.VoteCount DESC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 's1'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"reputation\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"creationdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"lastaccessdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"websiteurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"location\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"aboutme\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"views\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"upvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"downvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"profileimageurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"accountid\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "13763.sql", "original_sql": "\nWITH UserStatistics AS (\n    SELECT \n        u.Id AS UserId,\n        u.Reputation,\n        COUNT(p.Id) AS PostCount,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        MAX(p.CreationDate) AS LastPostDate,\n        AVG(COALESCE(c.Score, 0)) AS AverageCommentScore\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    GROUP BY \n        u.Id, u.Reputation\n),\nPostStatistics AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        p.ViewCount,\n        p.Score,\n        p.AnswerCount,\n        p.CommentCount,\n        pt.Name AS PostTypeName,\n        p.OwnerUserId\n    FROM \n        Posts p\n    JOIN \n        PostTypes pt ON p.PostTypeId = pt.Id\n)\nSELECT \n    us.UserId,\n    us.Reputation,\n    us.PostCount,\n    us.QuestionCount,\n    us.AnswerCount,\n    us.LastPostDate,\n    us.AverageCommentScore,\n    ps.PostId,\n    ps.Title,\n    ps.CreationDate,\n    ps.ViewCount,\n    ps.Score,\n    ps.AnswerCount,\n    ps.CommentCount,\n    ps.PostTypeName\nFROM \n    UserStatistics us\nLEFT JOIN \n    PostStatistics ps ON us.UserId = ps.OwnerUserId\nORDER BY \n    us.Reputation DESC, \n    ps.ViewCount DESC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 'us'\", span: None, notes: [DiagnosticNote { message: \"possible column ps.owneruserid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"us\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"us\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"postid\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"title\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"creationdate\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"viewcount\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"score\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"answercount\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"commentcount\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"posttypename\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"owneruserid\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "13784.sql", "original_sql": "\nWITH PostEngagement AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title AS PostTitle,\n        p.CreationDate AS PostCreationDate,\n        COUNT(c.Id) AS CommentCount,\n        COUNT(v.Id) AS VoteCount,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVoteCount,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVoteCount,\n        COUNT(DISTINCT b.Id) AS BadgeCount,\n        u.Reputation AS UserReputation,\n        u.DisplayName AS UserDisplayName\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    LEFT JOIN \n        Users u ON p.OwnerUserId = u.Id\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    WHERE \n        p.CreationDate >= CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '1 month'\n    GROUP BY \n        p.Id, p.Title, p.CreationDate, u.Id, u.Reputation, u.DisplayName\n)\nSELECT \n    PostId,\n    PostTitle,\n    PostCreationDate,\n    CommentCount,\n    VoteCount,\n    UpVoteCount,\n    DownVoteCount,\n    BadgeCount,\n    UserReputation,\n    UserDisplayName\nFROM \n    PostEngagement\nORDER BY \n    VoteCount DESC, CommentCount DESC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Collection([Diagnostic(Diagnostic { kind: Error, message: \"column 'postid' not found\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"postid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'posttitle' not found\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"posttitle\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'postcreationdate' not found\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"postcreationdate\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'commentcount' not found\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"commentcount\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'votecount' not found\", span: None, notes: [DiagnosticNote { message: \"possible column s1.count\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"votecount\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'upvotecount' not found\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"upvotecount\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'downvotecount' not found\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"downvotecount\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'badgecount' not found\", span: None, notes: [DiagnosticNote { message: \"possible column s1.count\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"badgecount\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'userreputation' not found\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"userreputation\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'userdisplayname' not found\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"userdisplayname\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\")))])\n", "engine_mem_mb": 500000}
{"query_id": "13805.sql", "original_sql": "SELECT \n    u.Id AS UserId,\n    u.DisplayName,\n    COUNT(DISTINCT p.Id) AS TotalPosts,\n    COUNT(c.Id) AS TotalComments,\n    COUNT(v.Id) AS TotalVotes,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUpVotes,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalDownVotes\nFROM \n    Users u\nLEFT JOIN \n    Posts p ON u.Id = p.OwnerUserId\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nGROUP BY \n    u.Id, u.DisplayName\nORDER BY \n    TotalPosts DESC, TotalComments DESC;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'owneruserid' not found in 's1'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"owneruserid\" }, valid_fields: [Column { relation: Some(Bare { table: \"u\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"reputation\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"creationdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"lastaccessdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"websiteurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"location\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"aboutme\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"views\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"upvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"downvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"profileimageurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"accountid\" }, Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "13811.sql", "original_sql": "SELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate AS PostCreationDate,\n    u.DisplayName AS OwnerDisplayName,\n    u.Reputation AS OwnerReputation,\n    COALESCE(vote_counts.UpVotes, 0) AS UpVoteCount,\n    COALESCE(vote_counts.DownVotes, 0) AS DownVoteCount,\n    COALESCE(c_counts.CommentCount, 0) AS CommentCount,\n    COALESCE(badge_counts.BadgeCount, 0) AS UserBadgeCount\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    (SELECT \n        PostId,\n        SUM(CASE WHEN VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n     FROM \n        Votes\n     GROUP BY \n        PostId) vote_counts ON p.Id = vote_counts.PostId\nLEFT JOIN \n    (SELECT \n        PostId,\n        COUNT(Id) AS CommentCount\n     FROM \n        Comments\n     GROUP BY \n        PostId) c_counts ON p.Id = c_counts.PostId\nLEFT JOIN \n    (SELECT \n        UserId,\n        COUNT(Id) AS BadgeCount\n     FROM \n        Badges\n     GROUP BY \n        UserId) badge_counts ON u.Id = badge_counts.UserId\nWHERE \n    p.PostTypeId = 1 \nORDER BY \n    p.CreationDate DESC\nLIMIT 100;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    p.Id AS PostId,\n    p.OwnerUserId AS OwnerUserId,\n    COALESCE(vc.UpVotes, 0) AS UpVotes,\n    COALESCE(vc.DownVotes, 0) AS DownVotes,\n    COALESCE(cc.CommentCount, 0) AS CommentCount,\n    COALESCE(bc.BadgeCount, 0) AS BadgeCount\nFROM Posts p\nLEFT JOIN (\n    SELECT PostId,\n           SUM(CASE WHEN VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n           SUM(CASE WHEN VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM Votes\n    GROUP BY PostId\n) vc ON p.Id = vc.PostId\nLEFT JOIN (\n    SELECT PostId, COUNT(*) AS CommentCount\n    FROM Comments\n    GROUP BY PostId\n) cc ON p.Id = cc.PostId\nLEFT JOIN (\n    SELECT UserId, COUNT(*) AS BadgeCount\n    FROM Badges\n    GROUP BY UserId\n) bc ON p.OwnerUserId = bc.UserId\nWHERE p.PostTypeId = 1;", "sql2": "SELECT\n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate AS PostCreationDate,\n    u.DisplayName AS OwnerDisplayName,\n    u.Reputation AS OwnerReputation,\n    s1.UpVotes,\n    s1.DownVotes,\n    s1.CommentCount,\n    s1.BadgeCount\nFROM s1\nJOIN Posts p ON p.Id = s1.PostId\nJOIN Users u ON u.Id = s1.OwnerUserId\nORDER BY p.CreationDate DESC\nLIMIT 100;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "13861.sql", "original_sql": "WITH UserPostStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.Reputation,\n        COUNT(p.Id) AS PostCount,\n        COUNT(c.Id) AS CommentCount,\n        COUNT(b.Id) AS BadgeCount\n    FROM Users u\n    LEFT JOIN Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN Comments c ON p.Id = c.PostId\n    LEFT JOIN Badges b ON u.Id = b.UserId\n    GROUP BY u.Id, u.Reputation\n),\nUserVoteStats AS (\n    SELECT \n        v.UserId,\n        COUNT(v.Id) AS VoteCount,\n        SUM(CASE WHEN vt.Name = 'UpMod' THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN vt.Name = 'DownMod' THEN 1 ELSE 0 END) AS DownVotes\n    FROM Votes v\n    JOIN VoteTypes vt ON v.VoteTypeId = vt.Id\n    GROUP BY v.UserId\n)\nSELECT \n    u.UserId,\n    u.Reputation,\n    u.PostCount,\n    u.CommentCount,\n    u.BadgeCount,\n    COALESCE(v.VoteCount, 0) AS TotalVotes,\n    COALESCE(v.UpVotes, 0) AS UpVotes,\n    COALESCE(v.DownVotes, 0) AS DownVotes\nFROM UserPostStats u\nLEFT JOIN UserVoteStats v ON u.UserId = v.UserId\nORDER BY u.Reputation DESC\nLIMIT 100;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH UserPostStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.Reputation,\n        COUNT(p.Id) AS PostCount,\n        COUNT(c.Id) AS CommentCount,\n        COUNT(b.Id) AS BadgeCount\n    FROM Users u\n    LEFT JOIN Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN Comments c ON p.Id = c.PostId\n    LEFT JOIN Badges b ON u.Id = b.UserId\n    GROUP BY u.Id, u.Reputation\n)\nSELECT UserId, Reputation, PostCount, CommentCount, BadgeCount\nFROM UserPostStats;", "sql2": "WITH UserVoteStats AS (\n    SELECT \n        v.UserId,\n        COUNT(v.Id) AS VoteCount,\n        SUM(CASE WHEN vt.Name = 'UpMod' THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN vt.Name = 'DownMod' THEN 1 ELSE 0 END) AS DownVotes\n    FROM Votes v\n    JOIN VoteTypes vt ON v.VoteTypeId = vt.Id\n    GROUP BY v.UserId\n)\nSELECT \n    s1.UserId,\n    s1.Reputation,\n    s1.PostCount,\n    s1.CommentCount,\n    s1.BadgeCount,\n    COALESCE(v.VoteCount, 0) AS TotalVotes,\n    COALESCE(v.UpVotes, 0) AS UpVotes,\n    COALESCE(v.DownVotes, 0) AS DownVotes\nFROM s1\nLEFT JOIN UserVoteStats v ON s1.UserId = v.UserId\nORDER BY s1.Reputation DESC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "13869.sql", "original_sql": "WITH UserPostActivity AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        P.Id AS PostId,\n        P.Title,\n        P.CreationDate AS PostCreationDate,\n        COUNT(CASE WHEN V.VoteTypeId IN (2, 3) THEN 1 END) AS VoteCount, \n        COUNT(CASE WHEN C.Id IS NOT NULL THEN 1 END) AS CommentCount, \n        COUNT(*) AS TotalPosts\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON P.OwnerUserId = U.Id\n    LEFT JOIN \n        Votes V ON V.PostId = P.Id\n    LEFT JOIN \n        Comments C ON C.PostId = P.Id\n    GROUP BY \n        U.Id, U.DisplayName, P.Id, P.Title, P.CreationDate\n)\n\nSELECT \n    U.DisplayName,\n    U.Id AS UserId,\n    COUNT(DISTINCT PA.PostId) AS PostsCreated,\n    SUM(PA.VoteCount) AS TotalVotes,\n    SUM(PA.CommentCount) AS TotalComments,\n    MIN(PA.PostCreationDate) AS FirstPostDate,\n    MAX(PA.PostCreationDate) AS LastPostDate\nFROM \n    UserPostActivity PA\nJOIN \n    Users U ON U.Id = PA.UserId\nGROUP BY \n    U.Id, U.DisplayName\nORDER BY \n    TotalVotes DESC, PostsCreated DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH VoteAgg AS (\n    SELECT PostId, COUNT(*) AS VoteCount\n    FROM Votes\n    WHERE VoteTypeId IN (2, 3)\n    GROUP BY PostId\n),\nCommentAgg AS (\n    SELECT PostId, COUNT(*) AS CommentCount\n    FROM Comments\n    GROUP BY PostId\n)\nSELECT \n    P.Id AS PostId,\n    P.Title,\n    P.CreationDate AS PostCreationDate,\n    COALESCE(VA.VoteCount, 0) AS VoteCount,\n    COALESCE(CA.CommentCount, 0) AS CommentCount,\n    P.OwnerUserId AS UserId\nFROM Posts P\nLEFT JOIN VoteAgg VA ON VA.PostId = P.Id\nLEFT JOIN CommentAgg CA ON CA.PostId = P.Id;", "sql2": "SELECT \n    U.DisplayName,\n    U.Id AS UserId,\n    COUNT(DISTINCT PA.PostId) AS PostsCreated,\n    SUM(PA.VoteCount) AS TotalVotes,\n    SUM(PA.CommentCount) AS TotalComments,\n    MIN(PA.PostCreationDate) AS FirstPostDate,\n    MAX(PA.PostCreationDate) AS LastPostDate\nFROM s1 PA\nJOIN Users U ON U.Id = PA.UserId\nGROUP BY U.Id, U.DisplayName\nORDER BY TotalVotes DESC, PostsCreated DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "13938.sql", "original_sql": "SELECT \n    P.Id AS PostId,\n    P.Title,\n    P.CreationDate,\n    U.DisplayName AS OwnerDisplayName,\n    P.Score,\n    P.ViewCount,\n    COALESCE(AC.AnswerCount, 0) AS AnswerCount,\n    COALESCE(C.CommentCount, 0) AS CommentCount\nFROM \n    Posts P\nJOIN \n    Users U ON P.OwnerUserId = U.Id\nLEFT JOIN \n    (SELECT \n         ParentId,\n         COUNT(*) AS AnswerCount\n     FROM \n         Posts\n     WHERE \n         PostTypeId = 2  \n     GROUP BY \n         ParentId) AC ON P.Id = AC.ParentId\nLEFT JOIN \n    (SELECT \n         PostId,\n         COUNT(*) AS CommentCount\n     FROM \n         Comments\n     GROUP BY \n         PostId) C ON P.Id = C.PostId\nWHERE \n    P.CreationDate >= '2022-01-01'  \nORDER BY \n    P.Score DESC, P.ViewCount DESC;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'postid' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column p.posttypeid\", span: None }, DiagnosticNote { message: \"possible column p.parentid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"postid\" }, valid_fields: [Column { relation: Some(Bare { table: \"p\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"posttypeid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"acceptedanswerid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"parentid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"creationdate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"score\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"viewcount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"body\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"owneruserid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"ownerdisplayname\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lasteditoruserid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lasteditordisplayname\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lasteditdate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lastactivitydate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"title\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"tags\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"answercount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"commentcount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"favoritecount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"closeddate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"communityowneddate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"contentlicense\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"reputation\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"creationdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"lastaccessdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"websiteurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"location\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"aboutme\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"views\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"upvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"downvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"profileimageurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"accountid\" }, Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "13940.sql", "original_sql": "WITH UserPostStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(P.Id) AS TotalPosts,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers,\n        SUM(P.ViewCount) AS TotalViews,\n        AVG(P.Score) AS AverageScore\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    GROUP BY \n        U.Id, U.DisplayName\n),\nUserBadgeCount AS (\n    SELECT \n        UserId,\n        COUNT(Id) AS TotalBadges\n    FROM \n        Badges\n    GROUP BY \n        UserId\n)\nSELECT \n    UPS.UserId,\n    UPS.DisplayName,\n    UPS.TotalPosts,\n    UPS.TotalQuestions,\n    UPS.TotalAnswers,\n    UPS.TotalViews,\n    UPS.AverageScore,\n    COALESCE(UBC.TotalBadges, 0) AS TotalBadges\nFROM \n    UserPostStats UPS\nLEFT JOIN \n    UserBadgeCount UBC ON UPS.UserId = UBC.UserId\nORDER BY \n    UPS.TotalPosts DESC\nLIMIT 100;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column ubc.userid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"ubc\" }), name: \"userid\" }, Column { relation: Some(Bare { table: \"ubc\" }), name: \"totalbadges\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "13945.sql", "original_sql": "\nWITH PostStats AS (\n    SELECT \n        Posts.Id AS PostId,\n        Posts.Title,\n        Posts.CreationDate,\n        Posts.ViewCount,\n        Posts.Score,\n        Users.Reputation AS OwnerReputation,\n        COUNT(DISTINCT Comments.Id) AS CommentCount,\n        COUNT(DISTINCT Votes.Id) AS VoteCount\n    FROM \n        Posts\n    LEFT JOIN \n        Users ON Posts.OwnerUserId = Users.Id\n    LEFT JOIN \n        Comments ON Posts.Id = Comments.PostId\n    LEFT JOIN \n        Votes ON Posts.Id = Votes.PostId\n    GROUP BY \n        Posts.Id, Posts.Title, Posts.CreationDate, Posts.ViewCount, Posts.Score, Users.Reputation\n),\nPostHistoryStats AS (\n    SELECT \n        PostId,\n        COUNT(*) AS HistoryCount,\n        MAX(CreationDate) AS LastEdited\n    FROM \n        PostHistory\n    GROUP BY \n        PostId\n)\n\nSELECT \n    ps.PostId,\n    ps.Title,\n    ps.CreationDate,\n    ps.ViewCount,\n    ps.Score,\n    ps.OwnerReputation,\n    ps.CommentCount,\n    ps.VoteCount,\n    COALESCE(phs.HistoryCount, 0) AS PostHistoryCount,\n    phs.LastEdited\nFROM \n    PostStats ps\nLEFT JOIN \n    PostHistoryStats phs ON ps.PostId = phs.PostId\nORDER BY \n    ps.ViewCount DESC, ps.Score DESC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "WITH PostStats AS (\n    SELECT \n        Posts.Id AS PostId,\n        Posts.Title,\n        Posts.CreationDate,\n        Posts.ViewCount,\n        Posts.Score,\n        Users.Reputation AS OwnerReputation,\n        COUNT(DISTINCT Comments.Id) AS CommentCount,\n        COUNT(DISTINCT Votes.Id) AS VoteCount\n    FROM Posts\n    LEFT JOIN Users ON Posts.OwnerUserId = Users.Id\n    LEFT JOIN Comments ON Posts.Id = Comments.PostId\n    LEFT JOIN Votes ON Posts.Id = Votes.PostId\n    GROUP BY Posts.Id, Posts.Title, Posts.CreationDate, Posts.ViewCount, Posts.Score, Users.Reputation\n)\nSELECT * FROM PostStats;", "sql2": "WITH PostHistoryStats AS (\n    SELECT \n        PostId,\n        COUNT(*) AS HistoryCount,\n        MAX(CreationDate) AS LastEdited\n    FROM PostHistory\n    GROUP BY PostId\n)\nSELECT \n    ps.PostId,\n    ps.Title,\n    ps.CreationDate,\n    ps.ViewCount,\n    ps.Score,\n    ps.OwnerReputation,\n    ps.CommentCount,\n    ps.VoteCount,\n    COALESCE(phs.HistoryCount, 0) AS PostHistoryCount,\n    phs.LastEdited\nFROM s1 ps\nLEFT JOIN PostHistoryStats phs ON ps.PostId = phs.PostId\nORDER BY ps.ViewCount DESC, ps.Score DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "14000.sql", "original_sql": "\nWITH UserActivity AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(DISTINCT P.Id) AS PostCount,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        SUM(CASE WHEN C.Id IS NOT NULL THEN 1 ELSE 0 END) AS CommentCount,\n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM Users U\n    LEFT JOIN Posts P ON U.Id = P.OwnerUserId\n    LEFT JOIN Comments C ON P.Id = C.PostId\n    LEFT JOIN Votes V ON P.Id = V.PostId\n    GROUP BY U.Id, U.DisplayName\n)\n\nSELECT \n    UA.UserId,\n    UA.DisplayName,\n    UA.PostCount,\n    UA.QuestionCount,\n    UA.AnswerCount,\n    UA.CommentCount,\n    UA.UpVotes,\n    UA.DownVotes,\n    U.Reputation,\n    U.CreationDate,\n    U.LastAccessDate\nFROM UserActivity UA\nJOIN Users U ON UA.UserId = U.Id\nORDER BY UA.PostCount DESC\nLIMIT 100;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 's1'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"reputation\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"creationdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"lastaccessdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"websiteurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"location\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"aboutme\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"views\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"upvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"downvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"profileimageurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"accountid\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "14018.sql", "original_sql": "\nWITH PostStatistics AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        p.ViewCount,\n        p.Score,\n        COUNT(c.Id) AS CommentCount,\n        COUNT(v.Id) AS VoteCount,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n        p.OwnerUserId\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    WHERE \n        p.CreationDate >= TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '1 year'  \n    GROUP BY \n        p.Id, p.Title, p.CreationDate, p.ViewCount, p.Score, p.OwnerUserId\n),\nUserReputation AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        U.Reputation,\n        COUNT(DISTINCT P.Id) AS PostsCount,\n        SUM(B.Class) AS BadgesCount  \n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    LEFT JOIN \n        Badges B ON U.Id = B.UserId\n    GROUP BY \n        U.Id, U.DisplayName, U.Reputation\n)\nSELECT \n    ps.PostId,\n    ps.Title,\n    ps.CreationDate,\n    ps.ViewCount,\n    ps.Score,\n    ps.CommentCount,\n    ps.VoteCount,\n    ps.UpVotes,\n    ps.DownVotes,\n    ur.DisplayName AS OwnerDisplayName,\n    ur.Reputation AS UserReputation,\n    ur.PostsCount AS TotalPosts,\n    ur.BadgesCount AS TotalBadges\nFROM \n    PostStatistics ps\nJOIN \n    UserReputation ur ON ps.OwnerUserId = ur.UserId\nORDER BY \n    ps.Score DESC,  \n    ps.ViewCount DESC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'owneruserid' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column ur.userid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"owneruserid\" }, valid_fields: [Column { relation: Some(Bare { table: \"ur\" }), name: \"userid\" }, Column { relation: Some(Bare { table: \"ur\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"ur\" }), name: \"reputation\" }, Column { relation: Some(Bare { table: \"ur\" }), name: \"postscount\" }, Column { relation: Some(Bare { table: \"ur\" }), name: \"badgescount\" }, Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "14038.sql", "original_sql": "\nWITH UserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(DISTINCT p.Id) AS PostCount,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,  \n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes  \n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON p.OwnerUserId = u.Id\n    LEFT JOIN \n        Votes v ON v.PostId = p.Id\n    GROUP BY \n        u.Id, u.DisplayName\n),\nPostStats AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.Score,\n        p.ViewCount,\n        p.CreationDate,\n        COALESCE(pc.CommentCount, 0) AS CommentCount,\n        COALESCE(pa.AnswerCount, 0) AS AnswerCount,\n        p.OwnerUserId\n    FROM \n        Posts p\n    LEFT JOIN \n        (SELECT PostId, COUNT(*) AS CommentCount \n         FROM Comments \n         GROUP BY PostId) pc ON pc.PostId = p.Id\n    LEFT JOIN \n        (SELECT ParentId, COUNT(*) AS AnswerCount \n         FROM Posts WHERE PostTypeId = 2 \n         GROUP BY ParentId) pa ON pa.ParentId = p.Id\n)\nSELECT \n    us.UserId,\n    us.DisplayName,\n    us.PostCount,\n    us.QuestionCount,\n    us.AnswerCount,\n    us.UpVotes,\n    us.DownVotes,\n    ps.PostId,\n    ps.Title,\n    ps.Score,\n    ps.ViewCount,\n    ps.CreationDate,\n    ps.CommentCount,\n    ps.AnswerCount\nFROM \n    UserStats us\nLEFT JOIN \n    PostStats ps ON us.UserId = ps.OwnerUserId\nORDER BY \n    us.UserId, us.PostCount DESC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 145, in benchmark_distributed_only\n    results_match = _tables_exact_equal(dist_tbl, baseline_tbl, float_tol=0.0, ignore_column_order=True)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 91, in _tables_exact_equal\n    df1 = _sort_df_by_all_columns(df1)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 41, in _sort_df_by_all_columns\n    return df.sort_values(by=list(df.columns), ascending=True, na_position=\"last\").reset_index(drop=True)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/pandas/core/frame.py\", line 7194, in sort_values\n    keys = [self._get_label_or_level_values(x, axis=axis) for x in by]\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/pandas/core/generic.py\", line 1928, in _get_label_or_level_values\n    raise ValueError(\nValueError: The column label 'answercount' is not unique.\n", "engine_mem_mb": 500000}
{"query_id": "14044.sql", "original_sql": "\nSELECT \n    p.Title,\n    p.CreationDate,\n    u.DisplayName AS OwnerDisplayName,\n    p.ViewCount,\n    p.Score,\n    COUNT(c.Id) AS CommentCount,\n    COUNT(v.Id) AS VoteCount,\n    MAX(ph.CreationDate) AS LastEditDate\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nLEFT JOIN \n    PostHistory ph ON p.Id = ph.PostId\nWHERE \n    p.PostTypeId = 1 \nGROUP BY \n    p.Title, p.CreationDate, u.DisplayName, p.ViewCount, p.Score\nORDER BY \n    p.Score DESC, p.CreationDate DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    p.Id AS PostId,\n    COUNT(DISTINCT c.Id) AS CommentCount,\n    COUNT(DISTINCT v.Id) AS VoteCount,\n    MAX(ph.CreationDate) AS LastEditDate\nFROM Posts p\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Votes v ON p.Id = v.PostId\nLEFT JOIN PostHistory ph ON p.Id = ph.PostId\nWHERE p.PostTypeId = 1\nGROUP BY p.Id", "sql2": "SELECT\n    p.Title,\n    p.CreationDate,\n    u.DisplayName AS OwnerDisplayName,\n    p.ViewCount,\n    p.Score,\n    s1.CommentCount,\n    s1.VoteCount,\n    s1.LastEditDate\nFROM Posts p\nJOIN Users u ON p.OwnerUserId = u.Id\nJOIN s1 ON p.Id = s1.PostId\nWHERE p.PostTypeId = 1\nORDER BY p.Score DESC, p.CreationDate DESC\nLIMIT 100", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "14057.sql", "original_sql": "WITH UserPosts AS (\n    SELECT \n        p.Id AS PostId,\n        p.OwnerUserId,\n        p.CreationDate AS PostCreationDate,\n        p.LastActivityDate,\n        p.Score,\n        p.ViewCount,\n        p.AnswerCount,\n        p.CommentCount,\n        p.FavoriteCount,\n        p.Title,\n        u.Reputation AS UserReputation\n    FROM \n        Posts p\n    JOIN \n        Users u ON p.OwnerUserId = u.Id\n    WHERE \n        p.CreationDate >= cast('2024-10-01 12:34:56' as timestamp) - INTERVAL '1 year' \n),\nPostInteractions AS (\n    SELECT \n        p.Id AS PostId,\n        COUNT(c.Id) AS CommentCount,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    GROUP BY \n        p.Id\n)\nSELECT \n    up.PostId,\n    up.Title,\n    up.UserReputation,\n    up.PostCreationDate,\n    up.LastActivityDate,\n    pi.CommentCount,\n    pi.UpVotes,\n    pi.DownVotes,\n    up.Score,\n    up.ViewCount,\n    up.AnswerCount,\n    up.FavoriteCount\nFROM \n    UserPosts up\nJOIN \n    PostInteractions pi ON up.PostId = pi.PostId\nORDER BY \n    up.LastActivityDate DESC\nLIMIT 100;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'postid' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column up.postid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"postid\" }, valid_fields: [Column { relation: Some(Bare { table: \"up\" }), name: \"postid\" }, Column { relation: Some(Bare { table: \"up\" }), name: \"owneruserid\" }, Column { relation: Some(Bare { table: \"up\" }), name: \"postcreationdate\" }, Column { relation: Some(Bare { table: \"up\" }), name: \"lastactivitydate\" }, Column { relation: Some(Bare { table: \"up\" }), name: \"score\" }, Column { relation: Some(Bare { table: \"up\" }), name: \"viewcount\" }, Column { relation: Some(Bare { table: \"up\" }), name: \"answercount\" }, Column { relation: Some(Bare { table: \"up\" }), name: \"commentcount\" }, Column { relation: Some(Bare { table: \"up\" }), name: \"favoritecount\" }, Column { relation: Some(Bare { table: \"up\" }), name: \"title\" }, Column { relation: Some(Bare { table: \"up\" }), name: \"userreputation\" }, Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "14061.sql", "original_sql": "SELECT \n    P.Id AS PostId,\n    P.Title,\n    P.CreationDate AS PostCreationDate,\n    P.Score,\n    P.ViewCount,\n    U.DisplayName AS OwnerDisplayName,\n    U.Reputation AS OwnerReputation,\n    COUNT(C.Id) AS CommentCount,\n    SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpvoteCount,\n    SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownvoteCount,\n    T.TagName AS PostTag,\n    PT.Name AS PostTypeName\nFROM \n    Posts P\nJOIN \n    Users U ON P.OwnerUserId = U.Id\nLEFT JOIN \n    Comments C ON P.Id = C.PostId\nLEFT JOIN \n    Votes V ON P.Id = V.PostId\nLEFT JOIN \n    Tags T ON T.ExcerptPostId = P.Id\nJOIN \n    PostTypes PT ON P.PostTypeId = PT.Id\nGROUP BY \n    P.Id, P.Title, P.CreationDate, P.Score, P.ViewCount, U.DisplayName, U.Reputation, T.TagName, PT.Name\nORDER BY \n    P.CreationDate DESC\nLIMIT 100;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT P.Id AS PostId, P.Title, P.CreationDate, P.Score, P.ViewCount, P.OwnerUserId, P.PostTypeId, COUNT(C.Id) AS CommentCount, SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpvoteCount, SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownvoteCount, MAX(T.TagName) AS PostTag FROM Posts P LEFT JOIN Comments C ON P.Id = C.PostId LEFT JOIN Votes V ON P.Id = V.PostId LEFT JOIN Tags T ON T.ExcerptPostId = P.Id GROUP BY P.Id, P.Title, P.CreationDate, P.Score, P.ViewCount, P.OwnerUserId, P.PostTypeId", "sql2": "SELECT s1.PostId, s1.Title, s1.CreationDate AS PostCreationDate, s1.Score, s1.ViewCount, U.DisplayName AS OwnerDisplayName, U.Reputation AS OwnerReputation, s1.CommentCount, s1.UpvoteCount, s1.DownvoteCount, s1.PostTag, PT.Name AS PostTypeName FROM s1 JOIN Users U ON s1.OwnerUserId = U.Id JOIN PostTypes PT ON s1.PostTypeId = PT.Id ORDER BY s1.CreationDate DESC LIMIT 100", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "14066.sql", "original_sql": "WITH QuestionStats AS (\n    SELECT\n        p.Id AS QuestionId,\n        p.Score AS QuestionScore,\n        p.ViewCount AS QuestionViews,\n        COUNT(a.Id) AS AnswerCount,\n        COALESCE(AVG(a.Score), 0) AS AverageAnswerScore,\n        COALESCE(AVG(a.ViewCount), 0) AS AverageAnswerViews\n    FROM\n        Posts p\n    LEFT JOIN\n        Posts a ON p.Id = a.ParentId\n    WHERE\n        p.PostTypeId = 1 \n    GROUP BY\n        p.Id, p.Score, p.ViewCount\n)\n\nSELECT\n    Q.QuestionId,\n    Q.QuestionScore,\n    Q.QuestionViews,\n    Q.AnswerCount,\n    Q.AverageAnswerScore,\n    Q.AverageAnswerViews\nFROM\n    QuestionStats Q\nORDER BY\n    Q.QuestionId;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Collection([Diagnostic(Diagnostic { kind: Error, message: \"column 'questionid' not found\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"questionid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'questionscore' not found\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"questionscore\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'questionviews' not found\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"questionviews\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'answercount' not found\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"answercount\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'averageanswerscore' not found\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"averageanswerscore\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'averageanswerviews' not found\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"averageanswerviews\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\")))])\n", "engine_mem_mb": 500000}
{"query_id": "14068.sql", "original_sql": "\nWITH PostStats AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        COUNT(c.Id) AS CommentCount,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpvoteCount,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownvoteCount,\n        p.CreationDate,\n        p.LastActivityDate,\n        p.ViewCount,\n        p.Score,\n        p.AnswerCount\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    WHERE \n        p.CreationDate >= CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '1 year'  \n    GROUP BY \n        p.Id, p.Title, p.CreationDate, p.LastActivityDate, p.ViewCount, p.Score, p.AnswerCount\n),\nUserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(b.Id) AS BadgeCount,\n        AVG(u.Reputation) AS AverageReputation,\n        SUM(p.ViewCount) AS TotalViews,\n        SUM(p.Score) AS TotalScore\n    FROM \n        Users u\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    GROUP BY \n        u.Id, u.DisplayName\n)\nSELECT \n    ps.PostId,\n    ps.Title,\n    ps.CommentCount,\n    ps.UpvoteCount,\n    ps.DownvoteCount,\n    ps.CreationDate,\n    ps.LastActivityDate,\n    ps.ViewCount,\n    ps.Score,\n    ps.AnswerCount,\n    us.UserId,\n    us.DisplayName,\n    us.BadgeCount,\n    us.AverageReputation,\n    us.TotalViews,\n    us.TotalScore\nFROM \n    PostStats ps\nJOIN \n    UserStats us ON ps.PostId = us.UserId\nORDER BY \n    ps.Score DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    p.Id AS PostId,\n    p.Title,\n    COUNT(c.Id) AS CommentCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpvoteCount,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownvoteCount,\n    p.CreationDate,\n    p.LastActivityDate,\n    p.ViewCount,\n    p.Score,\n    p.AnswerCount\nFROM Posts p\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Votes v ON p.Id = v.PostId\nWHERE p.CreationDate >= CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '1 year'\nGROUP BY p.Id, p.Title, p.CreationDate, p.LastActivityDate, p.ViewCount, p.Score, p.AnswerCount;", "sql2": "SELECT\n    ps.PostId,\n    ps.Title,\n    ps.CommentCount,\n    ps.UpvoteCount,\n    ps.DownvoteCount,\n    ps.CreationDate,\n    ps.LastActivityDate,\n    ps.ViewCount,\n    ps.Score,\n    ps.AnswerCount,\n    us.UserId,\n    us.DisplayName,\n    us.BadgeCount,\n    us.AverageReputation,\n    us.TotalViews,\n    us.TotalScore\nFROM (\n    SELECT * FROM s1\n) ps\nJOIN (\n    SELECT\n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(b.Id) AS BadgeCount,\n        AVG(u.Reputation) AS AverageReputation,\n        SUM(p.ViewCount) AS TotalViews,\n        SUM(p.Score) AS TotalScore\n    FROM Users u\n    LEFT JOIN Badges b ON u.Id = b.UserId\n    LEFT JOIN Posts p ON u.Id = p.OwnerUserId\n    GROUP BY u.Id, u.DisplayName\n) us ON ps.PostId = us.UserId\nORDER BY ps.Score DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "14100.sql", "original_sql": "\nWITH PostStatistics AS (\n    SELECT \n        p.Id AS PostId,\n        pt.Name AS PostType,\n        COUNT(c.Id) AS CommentCount,\n        COUNT(DISTINCT v.Id) AS VoteCount,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n        MAX(p.CreationDate) AS LastActivityDate,\n        SUM(COALESCE(p.ViewCount, 0)) AS TotalViews\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    JOIN \n        PostTypes pt ON p.PostTypeId = pt.Id\n    GROUP BY \n        p.Id, pt.Name\n),\nUserStatistics AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(b.Id) AS BadgeCount,\n        SUM(u.UpVotes) AS UserUpVotes,\n        SUM(u.DownVotes) AS UserDownVotes,\n        COUNT(DISTINCT p.Id) AS PostsCount\n    FROM \n        Users u\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    GROUP BY \n        u.Id, u.DisplayName\n)\n\nSELECT \n    ps.PostId,\n    ps.PostType,\n    ps.CommentCount,\n    ps.VoteCount,\n    ps.UpVotes,\n    ps.DownVotes,\n    ps.LastActivityDate,\n    ps.TotalViews,\n    us.UserId,\n    us.DisplayName AS OwnerDisplayName,\n    us.BadgeCount,\n    us.UserUpVotes,\n    us.UserDownVotes,\n    us.PostsCount\nFROM \n    PostStatistics ps\nLEFT JOIN \n    UserStatistics us ON ps.PostId = us.UserId\nORDER BY \n    ps.TotalViews DESC\nLIMIT 100;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'postid' not found in 's1'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"postid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"userid\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"badgecount\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"userupvotes\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"userdownvotes\" }, Column { relation: Some(Bare { table: \"us\" }), name: \"postscount\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "14109.sql", "original_sql": "WITH UserPosts AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName AS UserDisplayName,\n        P.Id AS PostId,\n        P.Title AS PostTitle,\n        P.CreationDate AS PostCreationDate,\n        P.Score AS PostScore,\n        P.ViewCount AS PostViewCount,\n        P.AnswerCount AS PostAnswerCount,\n        P.CommentCount AS PostCommentCount,\n        COALESCE(C.VoteCount, 0) AS VoteCount\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    LEFT JOIN (\n        SELECT \n            PostId,\n            COUNT(*) AS VoteCount \n        FROM \n            Votes \n        GROUP BY \n            PostId\n    ) C ON P.Id = C.PostId\n)\n\nSELECT \n    UP.UserId,\n    UP.UserDisplayName,\n    COUNT(UP.PostId) AS TotalPosts,\n    SUM(UP.PostScore) AS TotalPostScore,\n    SUM(UP.PostViewCount) AS TotalPostViews,\n    SUM(UP.VoteCount) AS TotalVotes,\n    MAX(UP.PostCreationDate) AS LastPostDate\nFROM \n    UserPosts UP\nGROUP BY \n    UP.UserId, UP.UserDisplayName\nORDER BY \n    TotalPosts DESC\nLIMIT 10;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 231, in run\n    self._register_downstream_aliases(nid, tbl, id_to_node, adj)\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 169, in _register_downstream_aliases\n    self._register_input_duckdb(alias, tbl)\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 81, in _register_input_duckdb\n    self.con.register(name, obj)\nduckdb.duckdb.InvalidInputException: Invalid Input Error: Provided table/dataframe must have at least one column\n", "engine_mem_mb": 500000}
{"query_id": "14211.sql", "original_sql": "\nWITH PostSummary AS (\n    SELECT \n        p.Id AS PostId,\n        p.PostTypeId,\n        p.CreationDate,\n        p.Score,\n        p.ViewCount,\n        p.AnswerCount,\n        p.CommentCount,\n        p.FavoriteCount,\n        u.Reputation AS OwnerReputation,\n        COUNT(c.Id) AS TotalCommentCount,\n        AVG(vote.VoteTypeId) AS AvgVoteType\n    FROM \n        Posts p\n    LEFT JOIN \n        Users u ON p.OwnerUserId = u.Id\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes vote ON p.Id = vote.PostId\n    GROUP BY \n        p.Id, p.PostTypeId, p.CreationDate, p.Score, p.ViewCount, p.AnswerCount, p.CommentCount, p.FavoriteCount, u.Reputation\n),\n\nPostHistoryStats AS (\n    SELECT \n        ph.PostId,\n        COUNT(*) AS RevisionCount,\n        MAX(ph.CreationDate) AS LastEditDate,\n        MAX(CASE WHEN ph.PostHistoryTypeId = 10 THEN 1 ELSE 0 END) AS ClosedPosts,\n        MAX(CASE WHEN ph.PostHistoryTypeId = 11 THEN 1 ELSE 0 END) AS ReopenedPosts\n    FROM \n        PostHistory ph\n    GROUP BY \n        ph.PostId\n)\n\nSELECT \n    ps.PostId,\n    ps.PostTypeId,\n    ps.CreationDate,\n    ps.Score,\n    ps.ViewCount,\n    ps.AnswerCount,\n    ps.TotalCommentCount,\n    ps.FavoriteCount,\n    ps.OwnerReputation,\n    pht.RevisionCount,\n    pht.LastEditDate,\n    pht.ClosedPosts,\n    pht.ReopenedPosts\nFROM \n    PostSummary ps\nLEFT JOIN \n    PostHistoryStats pht ON ps.PostId = pht.PostId\nORDER BY \n    ps.CreationDate DESC\nFETCH FIRST 100 ROWS ONLY;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    p.Id AS PostId,\n    p.PostTypeId,\n    p.CreationDate,\n    p.Score,\n    p.ViewCount,\n    p.AnswerCount,\n    p.CommentCount,\n    p.FavoriteCount,\n    u.Reputation AS OwnerReputation,\n    COUNT(c.Id) AS TotalCommentCount,\n    AVG(vote.VoteTypeId) AS AvgVoteType\nFROM Posts p\nLEFT JOIN Users u ON p.OwnerUserId = u.Id\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Votes vote ON p.Id = vote.PostId\nGROUP BY p.Id, p.PostTypeId, p.CreationDate, p.Score, p.ViewCount, p.AnswerCount, p.CommentCount, p.FavoriteCount, u.Reputation;", "sql2": "SELECT \n    s1.PostId,\n    s1.PostTypeId,\n    s1.CreationDate,\n    s1.Score,\n    s1.ViewCount,\n    s1.AnswerCount,\n    s1.TotalCommentCount,\n    s1.FavoriteCount,\n    s1.OwnerReputation,\n    pht.RevisionCount,\n    pht.LastEditDate,\n    pht.ClosedPosts,\n    pht.ReopenedPosts\nFROM s1\nLEFT JOIN (\n    SELECT \n        ph.PostId,\n        COUNT(*) AS RevisionCount,\n        MAX(ph.CreationDate) AS LastEditDate,\n        MAX(CASE WHEN ph.PostHistoryTypeId = 10 THEN 1 ELSE 0 END) AS ClosedPosts,\n        MAX(CASE WHEN ph.PostHistoryTypeId = 11 THEN 1 ELSE 0 END) AS ReopenedPosts\n    FROM PostHistory ph\n    GROUP BY ph.PostId\n) pht ON s1.PostId = pht.PostId\nORDER BY s1.CreationDate DESC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "14266.sql", "original_sql": "\nWITH PostSummary AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        p.Score,\n        p.ViewCount,\n        COUNT(DISTINCT c.Id) AS CommentCount,\n        COUNT(DISTINCT a.Id) AS AnswerCount\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Posts a ON p.Id = a.ParentId\n    WHERE \n        p.PostTypeId = 1  \n    GROUP BY \n        p.Id, p.Title, p.CreationDate, p.Score, p.ViewCount\n),\nUserSummary AS (\n    SELECT \n        u.Id AS UserId,\n        COUNT(DISTINCT b.Id) AS BadgeCount,\n        SUM(u.UpVotes) AS TotalUpVotes,\n        SUM(u.DownVotes) AS TotalDownVotes\n    FROM \n        Users u\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    GROUP BY \n        u.Id\n)\nSELECT \n    ps.PostId,\n    ps.Title,\n    ps.CreationDate,\n    ps.Score,\n    ps.ViewCount,\n    ps.CommentCount,\n    ps.AnswerCount,\n    us.UserId,\n    us.BadgeCount,\n    us.TotalUpVotes,\n    us.TotalDownVotes\nFROM \n    PostSummary ps\nJOIN \n    UserSummary us ON ps.PostId = us.UserId  \nORDER BY \n    ps.Score DESC, ps.ViewCount DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.Score,\n    p.ViewCount,\n    COUNT(DISTINCT c.Id) AS CommentCount,\n    COUNT(DISTINCT a.Id) AS AnswerCount\nFROM Posts p\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Posts a ON p.Id = a.ParentId\nWHERE p.PostTypeId = 1\nGROUP BY p.Id, p.Title, p.CreationDate, p.Score, p.ViewCount", "sql2": "SELECT \n    s1.PostId,\n    s1.Title,\n    s1.CreationDate,\n    s1.Score,\n    s1.ViewCount,\n    s1.CommentCount,\n    s1.AnswerCount,\n    us.UserId,\n    us.BadgeCount,\n    us.TotalUpVotes,\n    us.TotalDownVotes\nFROM s1\nJOIN (\n    SELECT \n        u.Id AS UserId,\n        COUNT(DISTINCT b.Id) AS BadgeCount,\n        SUM(u.UpVotes) AS TotalUpVotes,\n        SUM(u.DownVotes) AS TotalDownVotes\n    FROM Users u\n    LEFT JOIN Badges b ON u.Id = b.UserId\n    GROUP BY u.Id\n) us ON s1.PostId = us.UserId\nORDER BY s1.Score DESC, s1.ViewCount DESC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "14303.sql", "original_sql": "\nSELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.Score,\n    p.ViewCount,\n    u.DisplayName AS OwnerDisplayName,\n    u.Reputation AS OwnerReputation,\n    ARRAY_AGG(t.TagName) AS Tags,\n    COUNT(v.Id) AS VoteCount\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    Tags t ON t.ExcerptPostId = p.Id\nLEFT JOIN \n    Votes v ON v.PostId = p.Id\nWHERE \n    p.CreationDate >= '2023-01-01' \nGROUP BY \n    p.Id, p.Title, p.CreationDate, p.Score, p.ViewCount, u.DisplayName, u.Reputation\nORDER BY \n    p.CreationDate DESC\nLIMIT 100;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "14313.sql", "original_sql": "\nWITH UserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        u.Reputation,\n        COUNT(DISTINCT p.Id) AS PostCount,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS Answers,\n        SUM(p.Score) AS TotalScore,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    GROUP BY \n        u.Id, u.DisplayName, u.Reputation\n),\nPostStats AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        p.Score,\n        p.ViewCount,\n        COUNT(c.Id) AS CommentCount,\n        COUNT(DISTINCT ph.Id) AS EditHistoryCount\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        PostHistory ph ON p.Id = ph.PostId\n    GROUP BY \n        p.Id, p.Title, p.CreationDate, p.Score, p.ViewCount\n)\nSELECT \n    us.UserId,\n    us.DisplayName,\n    us.Reputation,\n    us.PostCount,\n    us.Questions,\n    us.Answers,\n    us.TotalScore,\n    us.UpVotes,\n    us.DownVotes,\n    ps.PostId,\n    ps.Title,\n    ps.CreationDate,\n    ps.Score AS PostScore,\n    ps.ViewCount,\n    ps.CommentCount,\n    ps.EditHistoryCount\nFROM \n    UserStats us\nJOIN \n    PostStats ps ON us.UserId = ps.PostId\nORDER BY \n    us.Reputation DESC, \n    ps.Score DESC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "WITH UserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        u.Reputation,\n        COUNT(DISTINCT p.Id) AS PostCount,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS Answers,\n        SUM(p.Score) AS TotalScore,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM Users u\n    LEFT JOIN Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN Votes v ON p.Id = v.PostId\n    GROUP BY u.Id, u.DisplayName, u.Reputation\n)\nSELECT * FROM UserStats;", "sql2": "WITH PostStats AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        p.Score,\n        p.ViewCount,\n        COUNT(c.Id) AS CommentCount,\n        COUNT(DISTINCT ph.Id) AS EditHistoryCount\n    FROM Posts p\n    LEFT JOIN Comments c ON p.Id = c.PostId\n    LEFT JOIN PostHistory ph ON p.Id = ph.PostId\n    GROUP BY p.Id, p.Title, p.CreationDate, p.Score, p.ViewCount\n)\nSELECT \n    s1.UserId,\n    s1.DisplayName,\n    s1.Reputation,\n    s1.PostCount,\n    s1.Questions,\n    s1.Answers,\n    s1.TotalScore,\n    s1.UpVotes,\n    s1.DownVotes,\n    ps.PostId,\n    ps.Title,\n    ps.CreationDate,\n    ps.Score AS PostScore,\n    ps.ViewCount,\n    ps.CommentCount,\n    ps.EditHistoryCount\nFROM PostStats ps\nJOIN s1 ON s1.UserId = ps.PostId\nORDER BY s1.Reputation DESC, ps.Score DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "14321.sql", "original_sql": "\nWITH UserVotes AS (\n    SELECT \n        u.Id AS UserId,\n        COUNT(v.Id) AS TotalVotes,\n        SUM(CASE WHEN v.VoteTypeId IN (2, 4) THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM Users u\n    LEFT JOIN Votes v ON u.Id = v.UserId\n    GROUP BY u.Id\n),\nPostStatistics AS (\n    SELECT \n        p.Id AS PostId,\n        p.OwnerUserId,\n        COUNT(c.Id) AS TotalComments,\n        COUNT(DISTINCT CASE WHEN p.PostTypeId = 2 THEN p.Id END) AS TotalAnswers,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalDownVotes\n    FROM Posts p\n    LEFT JOIN Comments c ON p.Id = c.PostId\n    LEFT JOIN Votes v ON p.Id = v.PostId\n    GROUP BY p.Id, p.OwnerUserId\n)\nSELECT \n    u.DisplayName AS UserName,\n    u.Reputation,\n    uv.TotalVotes,\n    uv.UpVotes,\n    uv.DownVotes,\n    ps.PostId,\n    ps.TotalComments,\n    ps.TotalAnswers,\n    ps.TotalUpVotes,\n    ps.TotalDownVotes\nFROM Users u\nJOIN UserVotes uv ON u.Id = uv.UserId\nJOIN PostStatistics ps ON ps.OwnerUserId = u.Id\nORDER BY u.Reputation DESC, uv.TotalVotes DESC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT \n    p.Id AS PostId,\n    p.OwnerUserId,\n    COUNT(c.Id) AS TotalComments,\n    COUNT(DISTINCT CASE WHEN p.PostTypeId = 2 THEN p.Id END) AS TotalAnswers,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUpVotes,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalDownVotes\nFROM Posts p\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Votes v ON p.Id = v.PostId\nGROUP BY p.Id, p.OwnerUserId;", "sql2": "WITH UserVotes AS (\n    SELECT \n        u.Id AS UserId,\n        COUNT(v.Id) AS TotalVotes,\n        SUM(CASE WHEN v.VoteTypeId IN (2, 4) THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM Users u\n    LEFT JOIN Votes v ON u.Id = v.UserId\n    GROUP BY u.Id\n)\nSELECT \n    u.DisplayName AS UserName,\n    u.Reputation,\n    uv.TotalVotes,\n    uv.UpVotes,\n    uv.DownVotes,\n    s1.PostId,\n    s1.TotalComments,\n    s1.TotalAnswers,\n    s1.TotalUpVotes,\n    s1.TotalDownVotes\nFROM Users u\nJOIN UserVotes uv ON u.Id = uv.UserId\nJOIN s1 ON s1.OwnerUserId = u.Id\nORDER BY u.Reputation DESC, uv.TotalVotes DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "14371.sql", "original_sql": "WITH PostStats AS (\n    SELECT \n        P.Id AS PostId,\n        P.PostTypeId,\n        COUNT(CASE WHEN C.Id IS NOT NULL THEN 1 END) AS CommentCount,\n        COUNT(CASE WHEN V.Id IS NOT NULL THEN 1 END) AS VoteCount,\n        COUNT(CASE WHEN PH.Id IS NOT NULL THEN 1 END) AS HistoryCount,\n        SUM(COALESCE(P.Score, 0)) AS TotalScore,\n        SUM(COALESCE(P.ViewCount, 0)) AS TotalViews\n    FROM \n        Posts P\n    LEFT JOIN \n        Comments C ON P.Id = C.PostId\n    LEFT JOIN \n        Votes V ON P.Id = V.PostId\n    LEFT JOIN \n        PostHistory PH ON P.Id = PH.PostId\n    GROUP BY \n        P.Id, P.PostTypeId\n),\nUserStats AS (\n    SELECT \n        U.Id AS UserId,\n        COUNT(DISTINCT P.Id) AS PostCount,\n        SUM(U.Reputation) AS TotalReputation\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    GROUP BY \n        U.Id\n)\nSELECT \n    PS.PostId,\n    PS.PostTypeId,\n    PS.CommentCount,\n    PS.VoteCount,\n    PS.HistoryCount,\n    PS.TotalScore,\n    PS.TotalViews,\n    US.UserId,\n    US.PostCount,\n    US.TotalReputation\nFROM \n    PostStats PS\nJOIN \n    Users U ON PS.PostTypeId = 1 AND U.Id = PS.PostId  \nLEFT JOIN \n    UserStats US ON U.Id = US.UserId\nORDER BY \n    PS.TotalViews DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    P.Id AS PostId,\n    P.PostTypeId,\n    COUNT(CASE WHEN C.Id IS NOT NULL THEN 1 END) AS CommentCount,\n    COUNT(CASE WHEN V.Id IS NOT NULL THEN 1 END) AS VoteCount,\n    COUNT(CASE WHEN PH.Id IS NOT NULL THEN 1 END) AS HistoryCount,\n    SUM(COALESCE(P.Score, 0)) AS TotalScore,\n    SUM(COALESCE(P.ViewCount, 0)) AS TotalViews\nFROM Posts P\nLEFT JOIN Comments C ON P.Id = C.PostId\nLEFT JOIN Votes V ON P.Id = V.PostId\nLEFT JOIN PostHistory PH ON P.Id = PH.PostId\nGROUP BY P.Id, P.PostTypeId;", "sql2": "WITH UserStats AS (\n    SELECT \n        U.Id AS UserId,\n        COUNT(DISTINCT P.Id) AS PostCount,\n        SUM(U.Reputation) AS TotalReputation\n    FROM Users U\n    LEFT JOIN Posts P ON U.Id = P.OwnerUserId\n    GROUP BY U.Id\n)\nSELECT \n    s1.PostId,\n    s1.PostTypeId,\n    s1.CommentCount,\n    s1.VoteCount,\n    s1.HistoryCount,\n    s1.TotalScore,\n    s1.TotalViews,\n    U.Id AS UserId,\n    US.PostCount,\n    US.TotalReputation\nFROM s1\nJOIN Users U ON s1.PostTypeId = 1 AND U.Id = s1.PostId\nLEFT JOIN UserStats US ON U.Id = US.UserId\nORDER BY s1.TotalViews DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "14375.sql", "original_sql": "SELECT \n    pt.Name AS PostType,\n    COUNT(p.Id) AS TotalPosts,\n    AVG(p.Score) AS AverageScore,\n    SUM(c.CommentCount) AS TotalComments\nFROM \n    Posts p\nJOIN \n    PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN \n    (SELECT PostId, COUNT(Id) AS CommentCount FROM Comments GROUP BY PostId) c ON p.Id = c.PostId\nGROUP BY \n    pt.Name\nORDER BY \n    TotalPosts DESC;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 231, in run\n    self._register_downstream_aliases(nid, tbl, id_to_node, adj)\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 169, in _register_downstream_aliases\n    self._register_input_duckdb(alias, tbl)\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 81, in _register_input_duckdb\n    self.con.register(name, obj)\nduckdb.duckdb.InvalidInputException: Invalid Input Error: Provided table/dataframe must have at least one column\n", "engine_mem_mb": 500000}
{"query_id": "14384.sql", "original_sql": "\nSELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.ViewCount,\n    p.Score,\n    u.DisplayName AS OwnerDisplayName,\n    COUNT(c.Id) AS CommentCount,\n    COUNT(DISTINCT v.Id) AS VoteCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n    COUNT(b.Id) AS BadgeCount\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nLEFT JOIN \n    Badges b ON u.Id = b.UserId\nWHERE \n    p.PostTypeId = 1  \nGROUP BY \n    p.Id, p.Title, p.CreationDate, p.ViewCount, p.Score, u.DisplayName\nORDER BY \n    p.CreationDate DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH comment_counts AS (\n    SELECT PostId, COUNT(*) AS CommentCount\n    FROM Comments\n    GROUP BY PostId\n),\nvote_aggregates AS (\n    SELECT PostId,\n           COUNT(*) AS VoteCount,\n           SUM(CASE WHEN VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n           SUM(CASE WHEN VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM Votes\n    GROUP BY PostId\n),\nbadge_counts AS (\n    SELECT UserId, COUNT(*) AS BadgeCount\n    FROM Badges\n    GROUP BY UserId\n)\nSELECT p.Id AS PostId,\n       COALESCE(cc.CommentCount, 0) AS CommentCount,\n       COALESCE(va.VoteCount, 0) AS VoteCount,\n       COALESCE(va.UpVotes, 0) AS UpVotes,\n       COALESCE(va.DownVotes, 0) AS DownVotes,\n       COALESCE(bc.BadgeCount, 0) AS BadgeCount\nFROM Posts p\nLEFT JOIN comment_counts cc ON p.Id = cc.PostId\nLEFT JOIN vote_aggregates va ON p.Id = va.PostId\nLEFT JOIN badge_counts bc ON p.OwnerUserId = bc.UserId\nWHERE p.PostTypeId = 1;", "sql2": "SELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.ViewCount,\n    p.Score,\n    u.DisplayName AS OwnerDisplayName,\n    s1.CommentCount,\n    s1.VoteCount,\n    s1.UpVotes,\n    s1.DownVotes,\n    s1.BadgeCount\nFROM Posts p\nJOIN Users u ON p.OwnerUserId = u.Id\nJOIN s1 ON p.Id = s1.PostId\nWHERE p.PostTypeId = 1\nORDER BY p.CreationDate DESC\nLIMIT 100;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "14388.sql", "original_sql": "SELECT \n    pt.Name AS PostType,\n    COUNT(p.Id) AS TotalPosts,\n    COUNT(a.Id) AS TotalAnswers,\n    SUM(COALESCE(c.CommentCount, 0)) AS TotalComments,\n    SUM(COALESCE(v.VoteCount, 0)) AS TotalVotes,\n    AVG(p.Score) AS AverageScore\nFROM \n    Posts p\nJOIN \n    PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN \n    Posts a ON p.Id = a.ParentId AND a.PostTypeId = 2 \nLEFT JOIN \n    (SELECT \n        PostId, COUNT(*) AS CommentCount \n     FROM \n        Comments \n     GROUP BY \n        PostId) c ON p.Id = c.PostId\nLEFT JOIN \n    (SELECT \n        PostId, COUNT(*) AS VoteCount \n     FROM \n        Votes \n     GROUP BY \n        PostId) v ON p.Id = v.PostId\nGROUP BY \n    pt.Name\nORDER BY \n    TotalPosts DESC;", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT \n    p.Id AS PostId,\n    p.PostTypeId,\n    p.Score,\n    COALESCE(c.CommentCount, 0) AS CommentCount,\n    COALESCE(v.VoteCount, 0) AS VoteCount\nFROM Posts p\nLEFT JOIN (\n    SELECT PostId, COUNT(*) AS CommentCount\n    FROM Comments\n    GROUP BY PostId\n) c ON p.Id = c.PostId\nLEFT JOIN (\n    SELECT PostId, COUNT(*) AS VoteCount\n    FROM Votes\n    GROUP BY PostId\n) v ON p.Id = v.PostId;", "sql2": "SELECT \n    pt.Name AS PostType,\n    COUNT(s1.PostId) AS TotalPosts,\n    COUNT(a.Id) AS TotalAnswers,\n    SUM(s1.CommentCount) AS TotalComments,\n    SUM(s1.VoteCount) AS TotalVotes,\n    AVG(s1.Score) AS AverageScore\nFROM s1\nJOIN PostTypes pt ON s1.PostTypeId = pt.Id\nLEFT JOIN Posts a ON s1.PostId = a.ParentId AND a.PostTypeId = 2\nGROUP BY pt.Name\nORDER BY TotalPosts DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "14454.sql", "original_sql": "SELECT \n    pt.Name AS PostType,\n    COUNT(p.Id) AS TotalPosts,\n    AVG(p.Score) AS AverageScore,\n    MAX(p.ViewCount) AS MaxViews,\n    COUNT(DISTINCT c.Id) AS TotalComments\nFROM \n    Posts p\nJOIN \n    PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nGROUP BY \n    pt.Name\nORDER BY \n    TotalPosts DESC;", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT PostId, COUNT(*) AS CommentCount FROM Comments GROUP BY PostId;", "sql2": "SELECT pt.Name AS PostType,\n       COUNT(p.Id) AS TotalPosts,\n       AVG(p.Score) AS AverageScore,\n       MAX(p.ViewCount) AS MaxViews,\n       SUM(COALESCE(s1.CommentCount,0)) AS TotalComments\nFROM Posts p\nJOIN PostTypes pt ON p.PostTypeId = pt.Id\nLEFT JOIN s1 ON p.Id = s1.PostId\nGROUP BY pt.Name\nORDER BY TotalPosts DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "14501.sql", "original_sql": "\nWITH PostStats AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        p.ViewCount,\n        p.Score,\n        COUNT(DISTINCT c.Id) AS CommentCount,\n        COUNT(DISTINCT v.Id) AS VoteCount,\n        COALESCE(SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END), 0) AS UpVotes,\n        COALESCE(SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END), 0) AS DownVotes\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    GROUP BY \n        p.Id, p.Title, p.CreationDate, p.ViewCount, p.Score\n), UserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        u.Reputation,\n        COUNT(DISTINCT p.Id) AS PostsCreated,\n        COUNT(DISTINCT b.Id) AS BadgesCount\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    GROUP BY \n        u.Id, u.DisplayName, u.Reputation\n)\n\nSELECT \n    ps.PostId,\n    ps.Title,\n    ps.CreationDate,\n    ps.ViewCount,\n    ps.Score,\n    ps.CommentCount,\n    ps.VoteCount,\n    ps.UpVotes,\n    ps.DownVotes,\n    us.UserId,\n    us.DisplayName AS AuthorName,\n    us.Reputation AS AuthorReputation,\n    us.PostsCreated AS TotalPosts,\n    us.BadgesCount AS TotalBadges\nFROM \n    PostStats ps\nJOIN \n    Users u ON ps.PostId = u.Id\nJOIN \n    UserStats us ON u.Id = us.UserId\nORDER BY \n    ps.CreationDate DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH PostStats AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        p.ViewCount,\n        p.Score,\n        COUNT(DISTINCT c.Id) AS CommentCount,\n        COUNT(DISTINCT v.Id) AS VoteCount,\n        COALESCE(SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END), 0) AS UpVotes,\n        COALESCE(SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END), 0) AS DownVotes\n    FROM Posts p\n    LEFT JOIN Comments c ON p.Id = c.PostId\n    LEFT JOIN Votes v ON p.Id = v.PostId\n    GROUP BY p.Id, p.Title, p.CreationDate, p.ViewCount, p.Score\n),\nUserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        u.Reputation,\n        COUNT(DISTINCT p.Id) AS PostsCreated,\n        COUNT(DISTINCT b.Id) AS BadgesCount\n    FROM Users u\n    LEFT JOIN Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN Badges b ON u.Id = b.UserId\n    GROUP BY u.Id, u.DisplayName, u.Reputation\n)\nSELECT \n    ps.PostId,\n    ps.Title,\n    ps.CreationDate,\n    ps.ViewCount,\n    ps.Score,\n    ps.CommentCount,\n    ps.VoteCount,\n    ps.UpVotes,\n    ps.DownVotes,\n    us.UserId,\n    us.DisplayName AS AuthorName,\n    us.Reputation AS AuthorReputation,\n    us.PostsCreated AS TotalPosts,\n    us.BadgesCount AS TotalBadges\nFROM PostStats ps\nJOIN Users u ON ps.PostId = u.Id\nJOIN UserStats us ON u.Id = us.UserId;", "sql2": "SELECT *\nFROM s1\nORDER BY CreationDate DESC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "14604.sql", "original_sql": "\nWITH PostStats AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.PostTypeId,\n        p.CreationDate,\n        COUNT(v.Id) AS VoteCount,\n        COUNT(c.Id) AS CommentCount,\n        COUNT(b.Id) AS BadgeCount,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS Upvotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS Downvotes\n    FROM \n        Posts p\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Badges b ON p.OwnerUserId = b.UserId\n    WHERE \n        p.CreationDate >= DATE '2023-01-01'\n    GROUP BY \n        p.Id, p.Title, p.PostTypeId, p.CreationDate\n)\nSELECT \n    ps.PostId,\n    ps.Title,\n    ps.PostTypeId,\n    ps.CreationDate,\n    ps.VoteCount,\n    ps.CommentCount,\n    ps.BadgeCount,\n    ps.Upvotes,\n    ps.Downvotes,\n    u.DisplayName AS OwnerDisplayName,\n    u.Reputation AS OwnerReputation\nFROM \n    PostStats ps\nJOIN \n    Users u ON ps.PostId = u.Id\nORDER BY \n    ps.CreationDate DESC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT \n    p.Id AS PostId,\n    p.Title,\n    p.PostTypeId,\n    p.CreationDate,\n    COUNT(v.Id) AS VoteCount,\n    COUNT(c.Id) AS CommentCount,\n    COUNT(b.Id) AS BadgeCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS Upvotes,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS Downvotes\nFROM Posts p\nLEFT JOIN Votes v ON p.Id = v.PostId\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Badges b ON p.OwnerUserId = b.UserId\nWHERE p.CreationDate >= DATE '2023-01-01'\nGROUP BY p.Id, p.Title, p.PostTypeId, p.CreationDate;", "sql2": "SELECT \n    s1.PostId,\n    s1.Title,\n    s1.PostTypeId,\n    s1.CreationDate,\n    s1.VoteCount,\n    s1.CommentCount,\n    s1.BadgeCount,\n    s1.Upvotes,\n    s1.Downvotes,\n    u.DisplayName AS OwnerDisplayName,\n    u.Reputation AS OwnerReputation\nFROM s1\nJOIN Users u ON s1.PostId = u.Id\nORDER BY s1.CreationDate DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "14625.sql", "original_sql": "\nSELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    u.DisplayName AS Author,\n    COUNT(c.Id) AS CommentCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n    COUNT(DISTINCT b.Id) AS BadgeCount\nFROM \n    Posts p\nLEFT JOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nLEFT JOIN \n    Badges b ON u.Id = b.UserId\nWHERE \n    p.PostTypeId = 1  \nGROUP BY \n    p.Id, p.Title, p.CreationDate, u.DisplayName\nORDER BY \n    p.CreationDate DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT p.Id AS PostId,\n       p.Title,\n       p.CreationDate,\n       p.OwnerUserId AS AuthorId,\n       u.DisplayName AS Author,\n       COUNT(c.Id) AS CommentCount,\n       SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n       SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\nFROM Posts p\nLEFT JOIN Users u ON p.OwnerUserId = u.Id\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Votes v ON p.Id = v.PostId\nWHERE p.PostTypeId = 1\nGROUP BY p.Id, p.Title, p.CreationDate, p.OwnerUserId, u.DisplayName", "sql2": "SELECT s1.PostId,\n       s1.Title,\n       s1.CreationDate,\n       s1.Author,\n       s1.CommentCount,\n       s1.UpVotes,\n       s1.DownVotes,\n       COALESCE(bc.BadgeCount, 0) AS BadgeCount\nFROM s1\nLEFT JOIN (\n    SELECT UserId, COUNT(Id) AS BadgeCount\n    FROM Badges\n    GROUP BY UserId\n) bc ON s1.AuthorId = bc.UserId\nORDER BY s1.CreationDate DESC\nLIMIT 100", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "14741.sql", "original_sql": "\nWITH UserStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        U.Reputation,\n        COUNT(DISTINCT P.Id) AS PostCount,\n        COALESCE(SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END), 0) AS UpVotes,\n        COALESCE(SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END), 0) AS DownVotes\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    LEFT JOIN \n        Votes V ON P.Id = V.PostId\n    GROUP BY \n        U.Id, U.DisplayName, U.Reputation\n),\nAggregatedStats AS (\n    SELECT \n        AVG(Reputation) AS AvgReputation,\n        AVG(PostCount) AS AvgPostCount,\n        AVG(UpVotes) AS AvgUpVotes,\n        AVG(DownVotes) AS AvgDownVotes\n    FROM \n        UserStats\n)\n\nSELECT \n    U.UserId,\n    U.DisplayName,\n    U.Reputation,\n    U.PostCount,\n    U.UpVotes,\n    U.DownVotes,\n    A.AvgReputation,\n    A.AvgPostCount,\n    A.AvgUpVotes,\n    A.AvgDownVotes\nFROM \n    UserStats U, AggregatedStats A\nWHERE \n    U.Reputation > 1000  \nORDER BY \n    U.Reputation DESC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 178, in _run_single_node\n    out_tbl = self._run_on_duckdb(node.sql)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 104, in _run_on_duckdb\n    return self.con.execute(sql).arrow()\n           ^^^^^^^^^^^^^^^^^^^^^\nduckdb.duckdb.InvalidInputException: Invalid Input Error: arrow_scan: get_next failed(): NotImplemented: Function 'array_filter' has no kernel matching input types (string_view, bool)\n", "engine_mem_mb": 500000}
{"query_id": "14747.sql", "original_sql": "\nWITH PostStats AS (\n    SELECT \n        p.PostTypeId,\n        COUNT(*) AS TotalPosts,\n        SUM(p.Score) AS TotalScore,\n        AVG(p.ViewCount) AS AverageViewCount,\n        AVG(p.AnswerCount) AS AverageAnswerCount,\n        AVG(p.CommentCount) AS AverageCommentCount\n    FROM \n        Posts p\n    GROUP BY \n        p.PostTypeId\n),\nUserStats AS (\n    SELECT \n        COUNT(*) AS TotalUsers,\n        AVG(u.Reputation) AS AverageReputation,\n        MAX(u.LastAccessDate) AS MostRecentAccessDate\n    FROM \n        Users u\n),\nVoteStats AS (\n    SELECT \n        v.VoteTypeId,\n        COUNT(*) AS TotalVotes\n    FROM \n        Votes v\n    GROUP BY \n        v.VoteTypeId\n)\n\nSELECT \n    ps.PostTypeId,\n    ps.TotalPosts,\n    ps.TotalScore,\n    ps.AverageViewCount,\n    ps.AverageAnswerCount,\n    ps.AverageCommentCount,\n    us.TotalUsers,\n    us.AverageReputation,\n    us.MostRecentAccessDate,\n    vs.VoteTypeId,\n    vs.TotalVotes\nFROM \n    PostStats ps\nJOIN \n    UserStats us ON TRUE  \nJOIN \n    VoteStats vs ON TRUE  \nORDER BY \n    ps.PostTypeId, vs.VoteTypeId;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "14781.sql", "original_sql": "\nWITH UserVoteStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(V.Id) AS TotalVotes,\n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM Users U\n    LEFT JOIN Votes V ON U.Id = V.UserId\n    GROUP BY U.Id, U.DisplayName\n),\nPostStats AS (\n    SELECT \n        P.Id AS PostId,\n        P.Title,\n        P.OwnerUserId,\n        P.Score,\n        P.ViewCount,\n        P.AnswerCount,\n        COUNT(C.Id) AS CommentCount\n    FROM Posts P\n    LEFT JOIN Comments C ON P.Id = C.PostId\n    GROUP BY P.Id, P.Title, P.OwnerUserId, P.Score, P.ViewCount, P.AnswerCount\n),\nPostVoteStats AS (\n    SELECT \n        P.Id AS PostId,\n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS PostUpVotes,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS PostDownVotes\n    FROM Posts P\n    LEFT JOIN Votes V ON P.Id = V.PostId\n    GROUP BY P.Id\n)\nSELECT \n    U.DisplayName,\n    U.TotalVotes,\n    U.UpVotes,\n    U.DownVotes,\n    P.PostId,\n    P.Title,\n    P.Score,\n    P.ViewCount,\n    P.AnswerCount,\n    P.CommentCount,\n    PV.PostUpVotes,\n    PV.PostDownVotes\nFROM UserVoteStats U\nJOIN PostStats P ON U.UserId = P.OwnerUserId\nJOIN PostVoteStats PV ON P.PostId = PV.PostId\nORDER BY U.TotalVotes DESC, P.Score DESC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column ps.owneruserid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"ps\" }), name: \"postid\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"title\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"owneruserid\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"score\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"viewcount\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"answercount\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"commentcount\" }, Column { relation: Some(Bare { table: \"pv\" }), name: \"postid\" }, Column { relation: Some(Bare { table: \"pv\" }), name: \"postupvotes\" }, Column { relation: Some(Bare { table: \"pv\" }), name: \"postdownvotes\" }, Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "14788.sql", "original_sql": "WITH UserPostStats AS (\n    SELECT\n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(P.Id) AS TotalPosts,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers,\n        SUM(CASE WHEN P.PostTypeId IN (4, 5) THEN 1 ELSE 0 END) AS TotalTagWikis,\n        SUM(P.Score) AS TotalScore,\n        AVG(P.ViewCount) AS AvgViewCount\n    FROM\n        Users U\n    LEFT JOIN\n        Posts P ON U.Id = P.OwnerUserId\n    GROUP BY\n        U.Id, U.DisplayName\n),\nPostHistoryStats AS (\n    SELECT\n        PH.UserId,\n        COUNT(PH.Id) AS TotalEdits,\n        SUM(CASE WHEN PHT.Name = 'Edit Title' THEN 1 ELSE 0 END) AS TotalTitleEdits,\n        SUM(CASE WHEN PHT.Name = 'Edit Body' THEN 1 ELSE 0 END) AS TotalBodyEdits,\n        SUM(CASE WHEN PHT.Name = 'Edit Tags' THEN 1 ELSE 0 END) AS TotalTagEdits\n    FROM\n        PostHistory PH\n    JOIN\n        PostHistoryTypes PHT ON PH.PostHistoryTypeId = PHT.Id\n    GROUP BY\n        PH.UserId\n),\nCombinedStats AS (\n    SELECT\n        UPS.UserId,\n        UPS.DisplayName,\n        UPS.TotalPosts,\n        UPS.TotalQuestions,\n        UPS.TotalAnswers,\n        UPS.TotalTagWikis,\n        UPS.TotalScore,\n        UPS.AvgViewCount,\n        PHS.TotalEdits,\n        PHS.TotalTitleEdits,\n        PHS.TotalBodyEdits,\n        PHS.TotalTagEdits\n    FROM\n        UserPostStats UPS\n    LEFT JOIN\n        PostHistoryStats PHS ON UPS.UserId = PHS.UserId\n)\nSELECT\n    UserId,\n    DisplayName,\n    TotalPosts,\n    TotalQuestions,\n    TotalAnswers,\n    TotalTagWikis,\n    TotalScore,\n    AvgViewCount,\n    COALESCE(TotalEdits, 0) AS TotalEdits,\n    COALESCE(TotalTitleEdits, 0) AS TotalTitleEdits,\n    COALESCE(TotalBodyEdits, 0) AS TotalBodyEdits,\n    COALESCE(TotalTagEdits, 0) AS TotalTagEdits\nFROM\n    CombinedStats\nORDER BY\n    TotalScore DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    U.Id AS UserId,\n    U.DisplayName,\n    COUNT(P.Id) AS TotalPosts,\n    SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n    SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers,\n    SUM(CASE WHEN P.PostTypeId IN (4, 5) THEN 1 ELSE 0 END) AS TotalTagWikis,\n    SUM(P.Score) AS TotalScore,\n    AVG(P.ViewCount) AS AvgViewCount\nFROM Users U\nLEFT JOIN Posts P ON U.Id = P.OwnerUserId\nGROUP BY U.Id, U.DisplayName", "sql2": "SELECT\n    s1.UserId,\n    s1.DisplayName,\n    s1.TotalPosts,\n    s1.TotalQuestions,\n    s1.TotalAnswers,\n    s1.TotalTagWikis,\n    s1.TotalScore,\n    s1.AvgViewCount,\n    COALESCE(phs.TotalEdits, 0) AS TotalEdits,\n    COALESCE(phs.TotalTitleEdits, 0) AS TotalTitleEdits,\n    COALESCE(phs.TotalBodyEdits, 0) AS TotalBodyEdits,\n    COALESCE(phs.TotalTagEdits, 0) AS TotalTagEdits\nFROM (\n    -- placeholder for the result of sql1\n    SELECT * FROM s1\n) s1\nLEFT JOIN (\n    SELECT\n        PH.UserId,\n        COUNT(PH.Id) AS TotalEdits,\n        SUM(CASE WHEN PHT.Name = 'Edit Title' THEN 1 ELSE 0 END) AS TotalTitleEdits,\n        SUM(CASE WHEN PHT.Name = 'Edit Body' THEN 1 ELSE 0 END) AS TotalBodyEdits,\n        SUM(CASE WHEN PHT.Name = 'Edit Tags' THEN 1 ELSE 0 END) AS TotalTagEdits\n    FROM PostHistory PH\n    JOIN PostHistoryTypes PHT ON PH.PostHistoryTypeId = PHT.Id\n    GROUP BY PH.UserId\n) phs ON s1.UserId = phs.UserId\nORDER BY s1.TotalScore DESC", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "14809.sql", "original_sql": "WITH UserPostStats AS (\n    SELECT\n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(p.Id) AS TotalPosts,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers,\n        SUM(p.Score) AS TotalScore,\n        AVG(p.ViewCount) AS AvgViewCount\n    FROM Users u\n    LEFT JOIN Posts p ON u.Id = p.OwnerUserId\n    GROUP BY u.Id, u.DisplayName\n),\nUserBadgeStats AS (\n    SELECT\n        b.UserId,\n        COUNT(b.Id) AS TotalBadges,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Badges b\n    GROUP BY b.UserId\n)\nSELECT\n    ups.UserId,\n    ups.DisplayName,\n    ups.TotalPosts,\n    ups.TotalQuestions,\n    ups.TotalAnswers,\n    ups.TotalScore,\n    ups.AvgViewCount,\n    ubs.TotalBadges,\n    ubs.GoldBadges,\n    ubs.SilverBadges,\n    ubs.BronzeBadges\nFROM UserPostStats ups\nLEFT JOIN UserBadgeStats ubs ON ups.UserId = ubs.UserId\nORDER BY ups.TotalPosts DESC\nLIMIT 100;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column ub.userid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"ub\" }), name: \"userid\" }, Column { relation: Some(Bare { table: \"ub\" }), name: \"totalbadges\" }, Column { relation: Some(Bare { table: \"ub\" }), name: \"goldbadges\" }, Column { relation: Some(Bare { table: \"ub\" }), name: \"silverbadges\" }, Column { relation: Some(Bare { table: \"ub\" }), name: \"bronzebadges\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "14848.sql", "original_sql": "WITH PostCounts AS (\n    SELECT \n        PostTypeId, \n        COUNT(*) AS TotalPosts,\n        SUM(CASE WHEN AcceptedAnswerId IS NOT NULL THEN 1 ELSE 0 END) AS TotalAcceptedAnswers\n    FROM \n        Posts\n    GROUP BY \n        PostTypeId\n),\nUserStats AS (\n    SELECT \n        U.Id AS UserId, \n        U.Reputation, \n        COUNT(DISTINCT P.Id) AS PostsCount,\n        SUM(V.BountyAmount) AS TotalBounties\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    LEFT JOIN \n        Votes V ON P.Id = V.PostId AND V.VoteTypeId = 8 \n    GROUP BY \n        U.Id, U.Reputation\n)\n\nSELECT \n    PCT.PostTypeId,\n    PCT.TotalPosts,\n    PCT.TotalAcceptedAnswers,\n    US.UserId,\n    US.Reputation,\n    US.PostsCount,\n    US.TotalBounties\nFROM \n    PostCounts PCT\nJOIN \n    UserStats US ON US.PostsCount > 0\nORDER BY \n    PCT.TotalPosts DESC, \n    US.Reputation DESC;", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT \n    U.Id AS UserId,\n    U.Reputation,\n    COUNT(DISTINCT P.Id) AS PostsCount,\n    SUM(V.BountyAmount) AS TotalBounties\nFROM Users U\nLEFT JOIN Posts P ON U.Id = P.OwnerUserId\nLEFT JOIN Votes V ON P.Id = V.PostId AND V.VoteTypeId = 8\nGROUP BY U.Id, U.Reputation;", "sql2": "WITH PostCounts AS (\n    SELECT \n        PostTypeId,\n        COUNT(*) AS TotalPosts,\n        SUM(CASE WHEN AcceptedAnswerId IS NOT NULL THEN 1 ELSE 0 END) AS TotalAcceptedAnswers\n    FROM Posts\n    GROUP BY PostTypeId\n)\nSELECT \n    PCT.PostTypeId,\n    PCT.TotalPosts,\n    PCT.TotalAcceptedAnswers,\n    s1.UserId,\n    s1.Reputation,\n    s1.PostsCount,\n    s1.TotalBounties\nFROM PostCounts PCT\nJOIN s1 ON s1.PostsCount > 0\nORDER BY PCT.TotalPosts DESC, s1.Reputation DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "14867.sql", "original_sql": "\nWITH UserPosts AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(p.Id) AS PostCount,\n        SUM(p.Score) AS TotalScore,\n        SUM(p.ViewCount) AS TotalViews\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    GROUP BY \n        u.Id, u.DisplayName\n),\n\nPostStats AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        pt.Name AS PostType,\n        p.CreationDate,\n        p.LastActivityDate,\n        p.Score,\n        p.ViewCount,\n        COALESCE(c.CommentCount, 0) AS CommentCount,\n        p.OwnerUserId\n    FROM \n        Posts p\n    JOIN \n        PostTypes pt ON p.PostTypeId = pt.Id\n    LEFT JOIN (\n        SELECT \n            PostId,\n            COUNT(*) AS CommentCount\n        FROM \n            Comments\n        GROUP BY \n            PostId\n    ) c ON p.Id = c.PostId\n)\n\nSELECT \n    up.DisplayName,\n    up.PostCount,\n    up.TotalScore,\n    up.TotalViews,\n    ps.PostId,\n    ps.Title,\n    ps.PostType,\n    ps.CreationDate,\n    ps.LastActivityDate,\n    ps.Score,\n    ps.ViewCount,\n    ps.CommentCount\nFROM \n    UserPosts up\nJOIN \n    PostStats ps ON up.UserId = ps.OwnerUserId\nORDER BY \n    up.TotalScore DESC,\n    up.PostCount DESC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 'up'\", span: None, notes: [DiagnosticNote { message: \"possible column p.owneruserid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"up\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"up\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"posttypeid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"acceptedanswerid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"parentid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"creationdate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"score\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"viewcount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"body\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"owneruserid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"ownerdisplayname\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lasteditoruserid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lasteditordisplayname\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lasteditdate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lastactivitydate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"title\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"tags\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"answercount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"commentcount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"favoritecount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"closeddate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"communityowneddate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"contentlicense\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "14888.sql", "original_sql": "SELECT \n    P.Id AS PostId,\n    P.Title,\n    P.CreationDate,\n    P.Score,\n    P.ViewCount,\n    COALESCE(A.AcceptedAnswerId, 0) AS AcceptedAnswerId,\n    U.DisplayName AS OwnerDisplayName,\n    U.Reputation AS OwnerReputation,\n    C.CommentCount,\n    B.BadgeCount,\n    T.TagName\nFROM \n    Posts P\nJOIN \n    Users U ON P.OwnerUserId = U.Id\nLEFT JOIN \n    (SELECT PostId, COUNT(*) AS CommentCount FROM Comments GROUP BY PostId) C ON P.Id = C.PostId\nLEFT JOIN \n    (SELECT UserId, COUNT(*) AS BadgeCount FROM Badges GROUP BY UserId) B ON U.Id = B.UserId\nLEFT JOIN \n    (SELECT PostId, STRING_AGG(TagName, ', ') AS TagName FROM PostLinks PL \n     JOIN Tags T ON PL.RelatedPostId = T.Id \n     GROUP BY PL.PostId) T ON P.Id = T.PostId\nLEFT JOIN \n    (SELECT AcceptedAnswerId FROM Posts WHERE PostTypeId = 1) A ON P.Id = A.AcceptedAnswerId\nWHERE \n    P.PostTypeId = 1 \nORDER BY \n    P.CreationDate DESC\nLIMIT 100;", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT Id AS PostId,\n       Title,\n       CreationDate,\n       Score,\n       ViewCount,\n       AcceptedAnswerId,\n       OwnerUserId\nFROM Posts\nWHERE PostTypeId = 1\nORDER BY CreationDate DESC\nLIMIT 100;", "sql2": "SELECT s1.PostId,\n       s1.Title,\n       s1.CreationDate,\n       s1.Score,\n       s1.ViewCount,\n       COALESCE(s1.AcceptedAnswerId, 0) AS AcceptedAnswerId,\n       u.DisplayName AS OwnerDisplayName,\n       u.Reputation AS OwnerReputation,\n       COALESCE(c.CommentCount, 0) AS CommentCount,\n       COALESCE(b.BadgeCount, 0) AS BadgeCount,\n       t.Tags AS TagName\nFROM s1\nLEFT JOIN Users u ON s1.OwnerUserId = u.Id\nLEFT JOIN (\n    SELECT PostId, COUNT(*) AS CommentCount\n    FROM Comments\n    GROUP BY PostId\n) c ON s1.PostId = c.PostId\nLEFT JOIN (\n    SELECT UserId, COUNT(*) AS BadgeCount\n    FROM Badges\n    GROUP BY UserId\n) b ON s1.OwnerUserId = b.UserId\nLEFT JOIN (\n    SELECT pl.PostId, STRING_AGG(t.TagName, ', ') AS Tags\n    FROM PostLinks pl\n    JOIN Tags t ON pl.RelatedPostId = t.Id\n    GROUP BY pl.PostId\n) t ON s1.PostId = t.PostId;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "14891.sql", "original_sql": "SELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.ViewCount,\n    COUNT(DISTINCT c.Id) AS CommentCount,\n    COUNT(DISTINCT v.Id) AS VoteCount,\n    COUNT(DISTINCT b.Id) AS BadgeCount,\n    u.DisplayName AS OwnerDisplayName,\n    u.Reputation AS OwnerReputation,\n    p.LastActivityDate\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    Comments c ON p.Id = c.PostId\nLEFT JOIN \n    Votes v ON p.Id = v.PostId\nLEFT JOIN \n    Badges b ON u.Id = b.UserId\nWHERE \n    p.CreationDate >= '2022-01-01' \nGROUP BY \n    p.Id, p.Title, p.CreationDate, p.ViewCount, u.DisplayName, u.Reputation, p.LastActivityDate\nORDER BY \n    p.ViewCount DESC;", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT p.Id AS PostId,\n       COUNT(DISTINCT c.Id) AS CommentCount,\n       COUNT(DISTINCT v.Id) AS VoteCount\nFROM Posts p\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Votes v ON p.Id = v.PostId\nWHERE p.CreationDate >= '2022-01-01'\nGROUP BY p.Id;", "sql2": "WITH badge_agg AS (\n    SELECT UserId, COUNT(DISTINCT Id) AS BadgeCount\n    FROM Badges\n    GROUP BY UserId\n)\nSELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.ViewCount,\n    COALESCE(s1.CommentCount, 0) AS CommentCount,\n    COALESCE(s1.VoteCount, 0) AS VoteCount,\n    COALESCE(b.BadgeCount, 0) AS BadgeCount,\n    u.DisplayName AS OwnerDisplayName,\n    u.Reputation AS OwnerReputation,\n    p.LastActivityDate\nFROM Posts p\nJOIN Users u ON p.OwnerUserId = u.Id\nLEFT JOIN badge_agg b ON u.Id = b.UserId\nLEFT JOIN s1 ON p.Id = s1.PostId\nWHERE p.CreationDate >= '2022-01-01'\nORDER BY p.ViewCount DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "14903.sql", "original_sql": "WITH PostStats AS (\n    SELECT \n        COUNT(*) AS TotalPosts,\n        COUNT(DISTINCT OwnerUserId) AS UniqueUsers,\n        SUM(COALESCE(AnswerCount, 0)) AS TotalAnswers,\n        SUM(COALESCE(CommentCount, 0)) AS TotalComments\n    FROM Posts\n),\nVoteStats AS (\n    SELECT \n        COUNT(*) AS TotalVotes,\n        COUNT(DISTINCT UserId) AS UniqueVoters\n    FROM Votes\n),\nUserStats AS (\n    SELECT \n        COUNT(*) AS TotalUsers,\n        AVG(Reputation) AS AvgReputation,\n        MAX(Reputation) AS MaxReputation\n    FROM Users\n)\n\nSELECT \n    p.TotalPosts,\n    p.UniqueUsers,\n    p.TotalAnswers,\n    p.TotalComments,\n    v.TotalVotes,\n    v.UniqueVoters,\n    u.TotalUsers,\n    u.AvgReputation,\n    u.MaxReputation\nFROM \n    PostStats p,\n    VoteStats v,\n    UserStats u;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    p.TotalPosts,\n    p.UniqueUsers,\n    p.TotalAnswers,\n    p.TotalComments,\n    v.TotalVotes,\n    v.UniqueVoters\nFROM (\n    SELECT COUNT(*) AS TotalPosts,\n           COUNT(DISTINCT OwnerUserId) AS UniqueUsers,\n           SUM(COALESCE(AnswerCount, 0)) AS TotalAnswers,\n           SUM(COALESCE(CommentCount, 0)) AS TotalComments\n    FROM Posts\n) p\nCROSS JOIN (\n    SELECT COUNT(*) AS TotalVotes,\n           COUNT(DISTINCT UserId) AS UniqueVoters\n    FROM Votes\n) v;", "sql2": "SELECT \n    s1.TotalPosts,\n    s1.UniqueUsers,\n    s1.TotalAnswers,\n    s1.TotalComments,\n    s1.TotalVotes,\n    s1.UniqueVoters,\n    u.TotalUsers,\n    u.AvgReputation,\n    u.MaxReputation\nFROM s1\nCROSS JOIN (\n    SELECT COUNT(*) AS TotalUsers,\n           AVG(Reputation) AS AvgReputation,\n           MAX(Reputation) AS MaxReputation\n    FROM Users\n) u;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "14907.sql", "original_sql": "SELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.ViewCount,\n    p.Score,\n    COUNT(CASE WHEN c.Id IS NOT NULL THEN 1 END) AS CommentCount,\n    COUNT(DISTINCT v.UserId) AS VoteCount,\n    u.DisplayName AS OwnerDisplayName,\n    COUNT(DISTINCT b.Id) AS BadgeCount\nFROM Posts p\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Votes v ON p.Id = v.PostId\nLEFT JOIN Users u ON p.OwnerUserId = u.Id\nLEFT JOIN Badges b ON u.Id = b.UserId\nWHERE p.CreationDate >= '2023-01-01' \nGROUP BY p.Id, p.Title, p.CreationDate, p.ViewCount, p.Score, u.DisplayName\nORDER BY p.CreationDate DESC;", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT\n    p.Id AS PostId,\n    COUNT(DISTINCT c.Id) AS CommentCount,\n    COUNT(DISTINCT v.UserId) AS VoteCount\nFROM Posts p\nLEFT JOIN Comments c ON p.Id = c.PostId\nLEFT JOIN Votes v ON p.Id = v.PostId\nWHERE p.CreationDate >= '2023-01-01'\nGROUP BY p.Id;", "sql2": "SELECT\n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    p.ViewCount,\n    p.Score,\n    COALESCE(s1.CommentCount, 0) AS CommentCount,\n    COALESCE(s1.VoteCount, 0) AS VoteCount,\n    u.DisplayName AS OwnerDisplayName,\n    COUNT(DISTINCT b.Id) AS BadgeCount\nFROM Posts p\nLEFT JOIN s1 ON p.Id = s1.PostId\nLEFT JOIN Users u ON p.OwnerUserId = u.Id\nLEFT JOIN Badges b ON u.Id = b.UserId\nWHERE p.CreationDate >= '2023-01-01'\nGROUP BY p.Id, p.Title, p.CreationDate, p.ViewCount, p.Score, u.DisplayName, s1.CommentCount, s1.VoteCount\nORDER BY p.CreationDate DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "14958.sql", "original_sql": "WITH UserPostStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(p.Id) AS TotalPosts,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers,\n        SUM(CASE WHEN p.ViewCount IS NOT NULL THEN p.ViewCount ELSE 0 END) AS TotalViews,\n        SUM(CASE WHEN p.Score IS NOT NULL THEN p.Score ELSE 0 END) AS TotalScore\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    GROUP BY \n        u.Id, u.DisplayName\n),\nPostTypeCounts AS (\n    SELECT \n        pt.Id AS PostTypeId,\n        pt.Name AS PostTypeName,\n        COUNT(p.Id) AS PostCount\n    FROM \n        Posts p\n    JOIN \n        PostTypes pt ON p.PostTypeId = pt.Id\n    GROUP BY \n        pt.Id, pt.Name\n)\nSELECT \n    u.DisplayName,\n    u.TotalPosts,\n    u.TotalQuestions,\n    u.TotalAnswers,\n    u.TotalViews,\n    u.TotalScore,\n    ptc.PostTypeName,\n    ptc.PostCount\nFROM \n    UserPostStats u\nLEFT JOIN \n    PostTypeCounts ptc ON u.TotalPosts > 0\nORDER BY \n    u.TotalScore DESC, \n    u.TotalPosts DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT u.Id AS UserId,\n       u.DisplayName,\n       COUNT(p.Id) AS TotalPosts,\n       SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n       SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers,\n       SUM(CASE WHEN p.ViewCount IS NOT NULL THEN p.ViewCount ELSE 0 END) AS TotalViews,\n       SUM(CASE WHEN p.Score IS NOT NULL THEN p.Score ELSE 0 END) AS TotalScore\nFROM Users u\nLEFT JOIN Posts p ON u.Id = p.OwnerUserId\nGROUP BY u.Id, u.DisplayName;", "sql2": "SELECT s1.DisplayName,\n       s1.TotalPosts,\n       s1.TotalQuestions,\n       s1.TotalAnswers,\n       s1.TotalViews,\n       s1.TotalScore,\n       ptc.PostTypeName,\n       ptc.PostCount\nFROM s1\nLEFT JOIN (\n    SELECT pt.Id AS PostTypeId,\n           pt.Name AS PostTypeName,\n           COUNT(p.Id) AS PostCount\n    FROM Posts p\n    JOIN PostTypes pt ON p.PostTypeId = pt.Id\n    GROUP BY pt.Id, pt.Name\n) ptc ON s1.TotalPosts > 0\nWHERE s1.TotalPosts > 0\nORDER BY s1.TotalScore DESC, s1.TotalPosts DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "14964.sql", "original_sql": "WITH UserActivity AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        u.Reputation,\n        COUNT(DISTINCT p.Id) AS PostCount,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        SUM(c.Score) AS TotalCommentScore,\n        SUM(v.BountyAmount) AS TotalBountyAmount,\n        COUNT(DISTINCT b.Id) AS BadgeCount,\n        MAX(p.CreationDate) AS LastActive\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId AND v.UserId = u.Id\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    GROUP BY \n        u.Id, u.DisplayName, u.Reputation\n)\nSELECT \n    UserId,\n    DisplayName,\n    Reputation,\n    PostCount,\n    QuestionCount,\n    AnswerCount,\n    TotalCommentScore,\n    TotalBountyAmount,\n    BadgeCount,\n    LastActive\nFROM \n    UserActivity\nORDER BY \n    Reputation DESC, PostCount DESC\nLIMIT 100;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 231, in run\n    self._register_downstream_aliases(nid, tbl, id_to_node, adj)\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 169, in _register_downstream_aliases\n    self._register_input_duckdb(alias, tbl)\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 81, in _register_input_duckdb\n    self.con.register(name, obj)\nduckdb.duckdb.InvalidInputException: Invalid Input Error: Provided table/dataframe must have at least one column\n", "engine_mem_mb": 500000}
{"query_id": "15356.sql", "original_sql": "SELECT \n    p.Title,\n    p.CreationDate,\n    u.DisplayName AS OwnerDisplayName,\n    COALESCE(p.ViewCount, 0) AS ViewCount,\n    COALESCE(p.AnswerCount, 0) AS AnswerCount\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nWHERE \n    p.PostTypeId = 1 \nORDER BY \n    p.CreationDate DESC\nLIMIT 10;", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "15541.sql", "original_sql": "SELECT \n    p.Id AS PostId,\n    p.Title,\n    u.DisplayName AS Owner,\n    p.CreationDate,\n    p.Score,\n    p.ViewCount,\n    COALESCE(p.AnswerCount, 0) AS AnswerCount,\n    COALESCE(p.CommentCount, 0) AS CommentCount\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nWHERE \n    p.PostTypeId = 1 \nORDER BY \n    p.CreationDate DESC\nLIMIT 10;", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "15647.sql", "original_sql": "SELECT \n    p.Id AS PostId, \n    p.Title, \n    u.DisplayName AS OwnerDisplayName, \n    p.CreationDate, \n    p.Score, \n    p.ViewCount,\n    (SELECT COUNT(*) FROM Comments c WHERE c.PostId = p.Id) AS CommentCount\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nWHERE \n    p.PostTypeId = 1 \nORDER BY \n    p.CreationDate DESC\nLIMIT 10;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT PostId, COUNT(*) AS CommentCount FROM Comments GROUP BY PostId;", "sql2": "SELECT p.Id AS PostId,\n       p.Title,\n       u.DisplayName AS OwnerDisplayName,\n       p.CreationDate,\n       p.Score,\n       p.ViewCount,\n       COALESCE(s1.CommentCount, 0) AS CommentCount\nFROM Posts p\nJOIN Users u ON p.OwnerUserId = u.Id\nLEFT JOIN s1 ON s1.PostId = p.Id\nWHERE p.PostTypeId = 1\nORDER BY p.CreationDate DESC\nLIMIT 10;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "15896.sql", "original_sql": "SELECT \n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate,\n    u.DisplayName AS OwnerDisplayName,\n    COALESCE(c.CommentCount, 0) AS NumberOfComments,\n    COALESCE(an.AnswerCount, 0) AS NumberOfAnswers,\n    COALESCE(v.TotalUpVotes, 0) AS TotalUpVotes\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    (SELECT PostId, COUNT(*) AS CommentCount FROM Comments GROUP BY PostId) c ON p.Id = c.PostId\nLEFT JOIN \n    (SELECT ParentId, COUNT(*) AS AnswerCount FROM Posts WHERE PostTypeId = 2 GROUP BY ParentId) an ON p.Id = an.ParentId\nLEFT JOIN \n    (SELECT PostId, COUNT(*) AS TotalUpVotes FROM Votes WHERE VoteTypeId = 2 GROUP BY PostId) v ON p.Id = v.PostId\nWHERE \n    p.PostTypeId = 1  \nORDER BY \n    p.CreationDate DESC\nLIMIT 10;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'postid' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column p.posttypeid\", span: None }, DiagnosticNote { message: \"possible column p.parentid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"postid\" }, valid_fields: [Column { relation: Some(Bare { table: \"p\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"posttypeid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"acceptedanswerid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"parentid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"creationdate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"score\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"viewcount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"body\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"owneruserid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"ownerdisplayname\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lasteditoruserid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lasteditordisplayname\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lasteditdate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lastactivitydate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"title\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"tags\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"answercount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"commentcount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"favoritecount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"closeddate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"communityowneddate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"contentlicense\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"reputation\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"creationdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"lastaccessdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"websiteurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"location\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"aboutme\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"views\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"upvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"downvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"profileimageurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"accountid\" }, Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "16373.sql", "original_sql": "SELECT p.Id, p.Title, p.CreationDate, u.DisplayName, t.TagName \nFROM Posts p\nJOIN Users u ON p.OwnerUserId = u.Id\nJOIN Tags t ON p.Tags LIKE CONCAT('%', t.TagName, '%')\nWHERE p.PostTypeId = 1\nORDER BY p.CreationDate DESC\nLIMIT 10;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT p.Id,\n       p.Title,\n       p.CreationDate,\n       p.OwnerUserId AS OwnerUserId,\n       t.TagName\nFROM Posts p\nJOIN Tags t ON p.Tags LIKE CONCAT('%', t.TagName, '%')\nWHERE p.PostTypeId = 1;", "sql2": "SELECT s1.Id,\n       s1.Title,\n       s1.CreationDate,\n       u.DisplayName,\n       s1.TagName\nFROM s1\nJOIN Users u ON s1.OwnerUserId = u.Id\nORDER BY s1.CreationDate DESC\nLIMIT 10;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "17332.sql", "original_sql": "SELECT \n    P.Id AS PostId,\n    P.Title,\n    U.DisplayName AS OwnerDisplayName,\n    P.CreationDate,\n    P.Score,\n    P.ViewCount,\n    C.CommentCount,\n    V.VoteCount\nFROM \n    Posts P\nJOIN \n    Users U ON P.OwnerUserId = U.Id\nLEFT JOIN \n    (SELECT PostId, COUNT(*) AS CommentCount FROM Comments GROUP BY PostId) C ON P.Id = C.PostId\nLEFT JOIN \n    (SELECT PostId, COUNT(*) AS VoteCount FROM Votes GROUP BY PostId) V ON P.Id = V.PostId\nWHERE \n    P.PostTypeId = 1  \nORDER BY \n    P.CreationDate DESC\nLIMIT 10;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT P.Id AS PostId,\n       P.Title,\n       P.OwnerUserId,\n       P.CreationDate,\n       P.Score,\n       P.ViewCount,\n       COALESCE(C.CommentCount,0) AS CommentCount,\n       COALESCE(V.VoteCount,0) AS VoteCount\nFROM Posts P\nLEFT JOIN (\n    SELECT PostId, COUNT(*) AS CommentCount\n    FROM Comments\n    GROUP BY PostId\n) C ON P.Id = C.PostId\nLEFT JOIN (\n    SELECT PostId, COUNT(*) AS VoteCount\n    FROM Votes\n    GROUP BY PostId\n) V ON P.Id = V.PostId\nWHERE P.PostTypeId = 1\nORDER BY P.CreationDate DESC\nLIMIT 10;", "sql2": "SELECT s1.PostId,\n       s1.Title,\n       U.DisplayName AS OwnerDisplayName,\n       s1.CreationDate,\n       s1.Score,\n       s1.ViewCount,\n       s1.CommentCount,\n       s1.VoteCount\nFROM s1\nJOIN Users U ON s1.OwnerUserId = U.Id\nORDER BY s1.CreationDate DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "17357.sql", "original_sql": "SELECT u.DisplayName, COUNT(DISTINCT p.Id) AS PostCount\nFROM Users u\nJOIN Posts p ON u.Id = p.OwnerUserId\nWHERE u.Reputation > 1000\nGROUP BY u.DisplayName\nORDER BY PostCount DESC\nLIMIT 10;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT Id, DisplayName FROM Users WHERE Reputation > 1000;", "sql2": "SELECT s1.DisplayName, COUNT(DISTINCT p.Id) AS PostCount\nFROM s1 JOIN Posts p ON s1.Id = p.OwnerUserId\nGROUP BY s1.DisplayName\nORDER BY PostCount DESC\nLIMIT 10;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "17599.sql", "original_sql": "SELECT \n    Users.DisplayName,\n    COUNT(DISTINCT Posts.Id) AS PostCount,\n    SUM(CASE WHEN Posts.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n    SUM(CASE WHEN Posts.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n    AVG(Users.Reputation) AS AverageReputation\nFROM \n    Users\nLEFT JOIN \n    Posts ON Users.Id = Posts.OwnerUserId\nGROUP BY \n    Users.DisplayName\nORDER BY \n    PostCount DESC\nLIMIT 10;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT OwnerUserId AS UserId,\n       COUNT(*) AS PostCount,\n       SUM(CASE WHEN PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n       SUM(CASE WHEN PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount\nFROM Posts\nGROUP BY OwnerUserId;", "sql2": "SELECT u.DisplayName,\n       SUM(COALESCE(s1.PostCount,0)) AS PostCount,\n       SUM(COALESCE(s1.QuestionCount,0)) AS QuestionCount,\n       SUM(COALESCE(s1.AnswerCount,0)) AS AnswerCount,\n       AVG(u.Reputation) AS AverageReputation\nFROM Users u\nLEFT JOIN s1 ON u.Id = s1.UserId\nGROUP BY u.DisplayName\nORDER BY PostCount DESC\nLIMIT 10;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "17677.sql", "original_sql": "SELECT \n    p.Id, \n    p.Title, \n    p.CreationDate, \n    p.Score, \n    u.DisplayName AS OwnerDisplayName \nFROM \n    Posts p \nJOIN \n    Users u ON p.OwnerUserId = u.Id \nWHERE \n    p.PostTypeId = 1 \nORDER BY \n    p.CreationDate DESC \nLIMIT 10;", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "18210.sql", "original_sql": "SELECT \n    U.DisplayName,\n    COUNT(P.Id) AS PostCount,\n    SUM(COALESCE(P.ViewCount, 0)) AS TotalViews\nFROM \n    Users U\nJOIN \n    Posts P ON U.Id = P.OwnerUserId\nGROUP BY \n    U.DisplayName\nORDER BY \n    PostCount DESC\nLIMIT 10;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "18312.sql", "original_sql": "SELECT \n    p.Id AS PostID,\n    p.Title,\n    u.DisplayName AS Owner,\n    p.CreationDate,\n    p.ViewCount,\n    p.Score,\n    (SELECT COUNT(*) FROM Comments c WHERE c.PostId = p.Id) AS CommentCount\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nWHERE \n    p.PostTypeId = 1 \nORDER BY \n    p.CreationDate DESC\nLIMIT 10;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT p.Id AS PostID,\n       p.Title,\n       u.DisplayName AS Owner,\n       p.CreationDate,\n       p.ViewCount,\n       p.Score\nFROM Posts p\nJOIN Users u ON p.OwnerUserId = u.Id\nWHERE p.PostTypeId = 1\nORDER BY p.CreationDate DESC\nLIMIT 10", "sql2": "SELECT rp.PostID,\n       rp.Title,\n       rp.Owner,\n       rp.CreationDate,\n       rp.ViewCount,\n       rp.Score,\n       COALESCE(cc.CommentCount, 0) AS CommentCount\nFROM s1 rp\nLEFT JOIN (\n    SELECT PostId, COUNT(*) AS CommentCount\n    FROM Comments\n    GROUP BY PostId\n) cc ON cc.PostId = rp.PostID", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "18572.sql", "original_sql": "SELECT \n    Users.DisplayName, \n    Posts.Title, \n    Posts.CreationDate, \n    Posts.Score, \n    Tags.TagName\nFROM \n    Posts\nJOIN \n    Users ON Posts.OwnerUserId = Users.Id\nJOIN \n    Tags ON Posts.Tags LIKE '%' || Tags.TagName || '%'\nWHERE \n    Posts.PostTypeId = 1 \nORDER BY \n    Posts.CreationDate DESC\nLIMIT 10;", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT Id, OwnerUserId, Title, CreationDate, Score, Tags FROM Posts WHERE PostTypeId = 1 ORDER BY CreationDate DESC LIMIT 10;", "sql2": "SELECT u.DisplayName, p.Title, p.CreationDate, p.Score, t.TagName FROM s1 p JOIN Users u ON p.OwnerUserId = u.Id JOIN Tags t ON p.Tags LIKE '%' || t.TagName || '%' ORDER BY p.CreationDate DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "19637.sql", "original_sql": "SELECT p.Title, p.CreationDate, u.DisplayName, t.TagName\nFROM Posts p\nJOIN Users u ON p.OwnerUserId = u.Id\nJOIN Tags t ON p.Tags LIKE CONCAT('%', t.TagName, '%')\nWHERE p.PostTypeId = 1\nORDER BY p.Score DESC\nLIMIT 10;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT Id, Title, CreationDate, OwnerUserId, Tags, Score\nFROM Posts\nWHERE PostTypeId = 1\nORDER BY Score DESC\nLIMIT 10;", "sql2": "SELECT s1.Title,\n       s1.CreationDate,\n       u.DisplayName,\n       t.TagName\nFROM s1\nJOIN Users u ON s1.OwnerUserId = u.Id\nJOIN Tags t ON s1.Tags LIKE CONCAT('%', t.TagName, '%')\nORDER BY s1.Score DESC\nLIMIT 10;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "21342.sql", "original_sql": "WITH UserBadgeCounts AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(B.Id) AS BadgeCount,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Users U\n    LEFT JOIN \n        Badges B ON U.Id = B.UserId\n    GROUP BY \n        U.Id, U.DisplayName\n),\nPostStatistics AS (\n    SELECT \n        P.OwnerUserId,\n        COUNT(P.Id) AS PostCount,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        AVG(P.Score) AS AverageScore,\n        MAX(P.ViewCount) AS MaxViews,\n        MIN(P.CreationDate) AS FirstPostDate\n    FROM \n        Posts P\n    GROUP BY \n        P.OwnerUserId\n),\nVoteSummary AS (\n    SELECT \n        V.UserId,\n        COUNT(V.Id) AS TotalVotes,\n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM \n        Votes V\n    GROUP BY \n        V.UserId\n)\nSELECT \n    U.DisplayName,\n    COALESCE(UB.BadgeCount, 0) AS BadgeCount,\n    COALESCE(PS.PostCount, 0) AS PostCount,\n    COALESCE(PS.QuestionCount, 0) AS QuestionCount,\n    COALESCE(PS.AnswerCount, 0) AS AnswerCount,\n    COALESCE(VS.TotalVotes, 0) AS TotalVotes,\n    COALESCE(VS.UpVotes, 0) AS UpVotes,\n    COALESCE(VS.DownVotes, 0) AS DownVotes,\n    CASE \n        WHEN COALESCE(PS.FirstPostDate, cast('2024-10-01 12:34:56' as timestamp)) > cast('2024-10-01 12:34:56' as timestamp) - INTERVAL '1 year' \n        THEN 'Active'\n        ELSE 'Inactive' \n    END AS UserActivityStatus,\n    CONCAT('User: ', U.DisplayName, '; Badges: ', COALESCE(UB.BadgeCount, 0), \n           '; Posts: ', COALESCE(PS.PostCount, 0), \n           '; Questions: ', COALESCE(PS.QuestionCount, 0), \n           '; Answers: ', COALESCE(PS.AnswerCount, 0), \n           '; Votes: ', COALESCE(VS.TotalVotes, 0)) AS Summary\nFROM \n    Users U\nLEFT JOIN \n    UserBadgeCounts UB ON U.Id = UB.UserId\nLEFT JOIN \n    PostStatistics PS ON U.Id = PS.OwnerUserId\nLEFT JOIN \n    VoteSummary VS ON U.Id = VS.UserId\nWHERE \n    (UPPER(U.DisplayName) LIKE '%SQL%' OR U.Location IS NOT NULL) \n    AND (UB.BadgeCount > 0 OR PS.PostCount > 0)\nORDER BY \n    BadgeCount DESC, \n    PostCount DESC NULLS LAST, \n    TotalVotes DESC;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 's1'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"u\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"reputation\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"creationdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"lastaccessdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"websiteurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"location\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"aboutme\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"views\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"upvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"downvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"profileimageurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"accountid\" }, Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "22203.sql", "original_sql": "WITH UserBadgeCounts AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(B.Id) AS BadgeCount,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Users U\n    LEFT JOIN \n        Badges B ON U.Id = B.UserId\n    GROUP BY \n        U.Id, U.DisplayName\n),\nPostStatistics AS (\n    SELECT \n        P.OwnerUserId,\n        COUNT(P.Id) AS PostCount,\n        COUNT(CASE WHEN P.PostTypeId = 1 THEN 1 END) AS QuestionCount,\n        COUNT(CASE WHEN P.PostTypeId = 2 THEN 1 END) AS AnswerCount,\n        SUM(P.Score) AS TotalScore,\n        AVG(P.ViewCount) AS AverageViews\n    FROM \n        Posts P\n    GROUP BY \n        P.OwnerUserId\n),\nRecentPostActivity AS (\n    SELECT \n        P.OwnerUserId,\n        COUNT(CASE WHEN P.LastActivityDate >= cast('2024-10-01 12:34:56' as timestamp) - INTERVAL '30 days' THEN 1 END) AS RecentActivityCount\n    FROM \n        Posts P\n    GROUP BY \n        P.OwnerUserId\n),\nUserActivitySummary AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COALESCE(UBC.BadgeCount, 0) AS BadgeCount,\n        COALESCE(PS.PostCount, 0) AS PostCount,\n        COALESCE(PS.QuestionCount, 0) AS QuestionCount,\n        COALESCE(PS.AnswerCount, 0) AS AnswerCount,\n        COALESCE(PS.TotalScore, 0) AS TotalScore,\n        COALESCE(PS.AverageViews, 0) AS AverageViews,\n        COALESCE(RPA.RecentActivityCount, 0) AS RecentActivityCount\n    FROM \n        Users U\n    LEFT JOIN \n        UserBadgeCounts UBC ON U.Id = UBC.UserId\n    LEFT JOIN \n        PostStatistics PS ON U.Id = PS.OwnerUserId\n    LEFT JOIN \n        RecentPostActivity RPA ON U.Id = RPA.OwnerUserId\n)\nSELECT \n    UAS.UserId,\n    UAS.DisplayName,\n    UAS.BadgeCount,\n    UAS.PostCount,\n    UAS.QuestionCount,\n    UAS.AnswerCount,\n    UAS.TotalScore,\n    UAS.AverageViews,\n    UAS.RecentActivityCount\nFROM \n    UserActivitySummary UAS\nWHERE \n    UAS.BadgeCount > 0 \n    AND (UAS.TotalScore >= (SELECT AVG(TotalScore) FROM PostStatistics WHERE TotalScore IS NOT NULL) OR UAS.RecentActivityCount > 5)\nORDER BY \n    UAS.TotalScore DESC, UAS.QuestionCount DESC\nLIMIT 10;", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "228.sql", "original_sql": "\nWITH UserReputation AS (\n    SELECT \n        Id,\n        DisplayName,\n        Reputation,\n        CASE \n            WHEN Reputation >= 1000 THEN 'High'\n            WHEN Reputation >= 100 THEN 'Medium'\n            ELSE 'Low' \n        END AS ReputationLevel\n    FROM Users\n),\nPostStats AS (\n    SELECT \n        p.OwnerUserId,\n        COUNT(p.Id) AS TotalPosts,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers\n    FROM Posts p\n    GROUP BY p.OwnerUserId\n),\nRecentActivity AS (\n    SELECT \n        p.OwnerUserId,\n        MAX(p.LastActivityDate) AS LastActivityDate\n    FROM Posts p\n    GROUP BY p.OwnerUserId\n),\nTopUsers AS (\n    SELECT \n        ur.DisplayName,\n        ur.ReputationLevel,\n        ps.TotalPosts,\n        ps.TotalQuestions,\n        ps.TotalAnswers,\n        ra.LastActivityDate,\n        ur.Id AS OwnerUserId\n    FROM UserReputation ur\n    JOIN PostStats ps ON ur.Id = ps.OwnerUserId\n    JOIN RecentActivity ra ON ur.Id = ra.OwnerUserId\n    WHERE ur.ReputationLevel = 'High'\n      AND ps.TotalPosts > 5\n      AND ra.LastActivityDate >= TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '30 days'\n)\nSELECT \n    t.DisplayName,\n    t.ReputationLevel,\n    t.TotalPosts,\n    t.TotalQuestions,\n    t.TotalAnswers,\n    COALESCE(pv.UpVotes, 0) AS RecentUpVotes,\n    COALESCE(cv.CloseVotes, 0) AS RecentCloseVotes\nFROM TopUsers t\nLEFT JOIN (\n    SELECT \n        p.OwnerUserId,\n        COUNT(v.Id) AS UpVotes\n    FROM Posts p\n    JOIN Votes v ON p.Id = v.PostId AND v.VoteTypeId = 2\n    GROUP BY p.OwnerUserId\n) pv ON t.OwnerUserId = pv.OwnerUserId\nLEFT JOIN (\n    SELECT \n        ph.UserId,\n        COUNT(ph.Id) AS CloseVotes\n    FROM PostHistory ph\n    WHERE ph.PostHistoryTypeId = 10\n    GROUP BY ph.UserId\n) cv ON t.OwnerUserId = cv.UserId\nORDER BY t.TotalPosts DESC, t.ReputationLevel;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH UserReputation AS (\n    SELECT \n        Id,\n        DisplayName,\n        Reputation,\n        CASE \n            WHEN Reputation >= 1000 THEN 'High'\n            WHEN Reputation >= 100 THEN 'Medium'\n            ELSE 'Low' \n        END AS ReputationLevel\n    FROM Users\n),\nPostStats AS (\n    SELECT \n        p.OwnerUserId,\n        COUNT(p.Id) AS TotalPosts,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers\n    FROM Posts p\n    GROUP BY p.OwnerUserId\n),\nRecentActivity AS (\n    SELECT \n        p.OwnerUserId,\n        MAX(p.LastActivityDate) AS LastActivityDate\n    FROM Posts p\n    GROUP BY p.OwnerUserId\n)\nSELECT \n    ur.Id AS OwnerUserId,\n    ur.DisplayName,\n    ur.ReputationLevel,\n    ps.TotalPosts,\n    ps.TotalQuestions,\n    ps.TotalAnswers,\n    ra.LastActivityDate\nFROM UserReputation ur\nJOIN PostStats ps ON ur.Id = ps.OwnerUserId\nJOIN RecentActivity ra ON ur.Id = ra.OwnerUserId\nWHERE ur.ReputationLevel = 'High'\n  AND ps.TotalPosts > 5\n  AND ra.LastActivityDate >= TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '30 days';", "sql2": "SELECT \n    t.DisplayName,\n    t.ReputationLevel,\n    t.TotalPosts,\n    t.TotalQuestions,\n    t.TotalAnswers,\n    COALESCE(pv.UpVotes, 0) AS RecentUpVotes,\n    COALESCE(cv.CloseVotes, 0) AS RecentCloseVotes\nFROM s1 t\nLEFT JOIN (\n    SELECT \n        p.OwnerUserId,\n        COUNT(v.Id) AS UpVotes\n    FROM Posts p\n    JOIN Votes v ON p.Id = v.PostId AND v.VoteTypeId = 2\n    GROUP BY p.OwnerUserId\n) pv ON t.OwnerUserId = pv.OwnerUserId\nLEFT JOIN (\n    SELECT \n        ph.UserId,\n        COUNT(ph.Id) AS CloseVotes\n    FROM PostHistory ph\n    WHERE ph.PostHistoryTypeId = 10\n    GROUP BY ph.UserId\n) cv ON t.OwnerUserId = cv.UserId\nORDER BY t.TotalPosts DESC, t.ReputationLevel;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "23193.sql", "original_sql": "WITH UserStatistics AS (\n    SELECT \n        U.Id AS UserId,\n        U.Reputation,\n        COUNT(DISTINCT P.Id) AS TotalPosts,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionsCount,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswersCount,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Users U\n    LEFT JOIN Posts P ON U.Id = P.OwnerUserId\n    LEFT JOIN Badges B ON U.Id = B.UserId\n    GROUP BY U.Id, U.Reputation\n),\nAggregatedStatistics AS (\n    SELECT \n        UserId,\n        Reputation,\n        TotalPosts,\n        QuestionsCount,\n        AnswersCount,\n        GoldBadges,\n        SilverBadges,\n        BronzeBadges,\n        ROW_NUMBER() OVER (ORDER BY Reputation DESC) AS ReputationRank\n    FROM UserStatistics\n),\nMetricCalculations AS (\n    SELECT \n        UserId,\n        Reputation,\n        TotalPosts,\n        QuestionsCount,\n        AnswersCount,\n        GoldBadges,\n        SilverBadges,\n        BronzeBadges,\n        CASE\n            WHEN TotalPosts = 0 THEN 0\n            ELSE CAST(QuestionsCount AS FLOAT) / TotalPosts\n        END AS QuestionRatio,\n        CASE\n            WHEN TotalPosts = 0 THEN 0\n            ELSE CAST(AnswersCount AS FLOAT) / TotalPosts\n        END AS AnswerRatio\n    FROM AggregatedStatistics\n)\nSELECT \n    U.DisplayName,\n    U.Id,\n    U.Reputation,\n    M.TotalPosts,\n    M.QuestionsCount,\n    M.AnswersCount,\n    M.GoldBadges,\n    M.SilverBadges,\n    M.BronzeBadges,\n    M.QuestionRatio,\n    M.AnswerRatio,\n    (SELECT COUNT(*) \n     FROM Votes V \n     WHERE V.UserId = U.Id \n     AND V.CreationDate >= cast('2024-10-01 12:34:56' as timestamp) - INTERVAL '1 year') AS RecentVoteCount\nFROM Users U\nJOIN MetricCalculations M ON U.Id = M.UserId\nWHERE (M.QuestionRatio > 0.5 OR M.AnswerRatio > 0.5)\n  AND (M.GoldBadges + M.SilverBadges + M.BronzeBadges > 0)\nORDER BY M.Reputation DESC, U.DisplayName\nFETCH FIRST 10 ROWS ONLY;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH UserStatistics AS (\n    SELECT \n        U.Id AS UserId,\n        U.Reputation,\n        COUNT(DISTINCT P.Id) AS TotalPosts,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionsCount,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswersCount,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Users U\n    LEFT JOIN Posts P ON U.Id = P.OwnerUserId\n    LEFT JOIN Badges B ON U.Id = B.UserId\n    GROUP BY U.Id, U.Reputation\n),\nAggregatedStatistics AS (\n    SELECT \n        UserId,\n        Reputation,\n        TotalPosts,\n        QuestionsCount,\n        AnswersCount,\n        GoldBadges,\n        SilverBadges,\n        BronzeBadges,\n        ROW_NUMBER() OVER (ORDER BY Reputation DESC) AS ReputationRank\n    FROM UserStatistics\n),\nMetricCalculations AS (\n    SELECT \n        UserId,\n        Reputation,\n        TotalPosts,\n        QuestionsCount,\n        AnswersCount,\n        GoldBadges,\n        SilverBadges,\n        BronzeBadges,\n        CASE WHEN TotalPosts = 0 THEN 0 ELSE CAST(QuestionsCount AS FLOAT) / TotalPosts END AS QuestionRatio,\n        CASE WHEN TotalPosts = 0 THEN 0 ELSE CAST(AnswersCount AS FLOAT) / TotalPosts END AS AnswerRatio\n    FROM AggregatedStatistics\n)\nSELECT \n    U.DisplayName,\n    U.Id,\n    U.Reputation,\n    M.TotalPosts,\n    M.QuestionsCount,\n    M.AnswersCount,\n    M.GoldBadges,\n    M.SilverBadges,\n    M.BronzeBadges,\n    M.QuestionRatio,\n    M.AnswerRatio,\n    (SELECT COUNT(*) \n     FROM Votes V \n     WHERE V.UserId = U.Id \n       AND V.CreationDate >= CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '1 year') AS RecentVoteCount\nFROM Users U\nJOIN MetricCalculations M ON U.Id = M.UserId\nWHERE (M.QuestionRatio > 0.5 OR M.AnswerRatio > 0.5)\n  AND (M.GoldBadges + M.SilverBadges + M.BronzeBadges > 0);", "sql2": "SELECT *\nFROM s1\nORDER BY Reputation DESC, DisplayName\nLIMIT 10;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "23267.sql", "original_sql": "\nWITH UserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        u.Reputation,\n        u.CreationDate,\n        COALESCE(SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END), 0) AS TotalUpvotes,\n        COALESCE(SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END), 0) AS TotalDownvotes,\n        COALESCE(COUNT(DISTINCT p.Id), 0) AS TotalPosts,\n        COALESCE(SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END), 0) AS GoldBadges,\n        COALESCE(SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END), 0) AS SilverBadges,\n        COALESCE(SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END), 0) AS BronzeBadges\n    FROM \n        Users u\n    LEFT JOIN \n        Votes v ON u.Id = v.UserId\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    GROUP BY \n        u.Id, u.DisplayName, u.Reputation, u.CreationDate\n),\nPostActivity AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        p.ViewCount,\n        p.Score,\n        COUNT(CASE WHEN c.Id IS NOT NULL THEN 1 END) AS TotalComments,\n        SUM(CASE WHEN ph.PostHistoryTypeId = 10 THEN 1 ELSE 0 END) AS TotalCloseVotes\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        PostHistory ph ON p.Id = ph.PostId\n    WHERE \n        p.CreationDate >= (CURRENT_DATE - INTERVAL '1 year')\n    GROUP BY \n        p.Id, p.Title, p.CreationDate, p.ViewCount, p.Score\n),\nRankedPosts AS (\n    SELECT \n        pa.*,\n        RANK() OVER (ORDER BY pa.Score DESC, pa.ViewCount DESC) AS PostRank\n    FROM \n        PostActivity pa\n),\nBizarreLogic AS (\n    SELECT \n        ups.UserId,\n        SUM(CASE WHEN ups.TotalUpvotes > ups.TotalDownvotes THEN 1 ELSE 0 END) AS PositiveContributions,\n        SUM(CASE WHEN ups.TotalDownvotes > ups.TotalUpvotes THEN 1 ELSE 0 END) AS NegativeContributions,\n        COUNT(DISTINCT rp.PostId) AS ContributingPosts,\n        STRING_AGG(rp.Title, '; ') AS PostTitles\n    FROM \n        UserStats ups\n    LEFT JOIN \n        RankedPosts rp ON ups.UserId = rp.PostId\n    WHERE \n        ups.Reputation > 100 AND \n        (ups.GoldBadges + ups.SilverBadges + ups.BronzeBadges) >= 1\n    GROUP BY \n        ups.UserId\n)\nSELECT \n    bl.UserId,\n    u.DisplayName,\n    bl.PositiveContributions,\n    bl.NegativeContributions,\n    bl.ContributingPosts,\n    bl.PostTitles,\n    CASE \n        WHEN bl.PositiveContributions > bl.NegativeContributions THEN 'Overall Positive Contributor' \n        WHEN bl.NegativeContributions > bl.PositiveContributions THEN 'Overall Negative Contributor' \n        ELSE 'Neutral Contributor' \n    END AS ContributionType\nFROM \n    BizarreLogic bl\nJOIN \n    Users u ON bl.UserId = u.Id\nWHERE \n    bl.ContributingPosts > 0\nORDER BY \n    bl.PositiveContributions DESC, \n    bl.NegativeContributions ASC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH UserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        u.Reputation,\n        u.CreationDate,\n        COALESCE(SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END), 0) AS TotalUpvotes,\n        COALESCE(SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END), 0) AS TotalDownvotes,\n        COALESCE(COUNT(DISTINCT p.Id), 0) AS TotalPosts,\n        COALESCE(SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END), 0) AS GoldBadges,\n        COALESCE(SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END), 0) AS SilverBadges,\n        COALESCE(SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END), 0) AS BronzeBadges\n    FROM Users u\n    LEFT JOIN Votes v ON u.Id = v.UserId\n    LEFT JOIN Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN Badges b ON u.Id = b.UserId\n    GROUP BY u.Id, u.DisplayName, u.Reputation, u.CreationDate\n),\nPostActivity AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        p.ViewCount,\n        p.Score,\n        COUNT(CASE WHEN c.Id IS NOT NULL THEN 1 END) AS TotalComments,\n        SUM(CASE WHEN ph.PostHistoryTypeId = 10 THEN 1 ELSE 0 END) AS TotalCloseVotes\n    FROM Posts p\n    LEFT JOIN Comments c ON p.Id = c.PostId\n    LEFT JOIN PostHistory ph ON p.Id = ph.PostId\n    WHERE p.CreationDate >= (CURRENT_DATE - INTERVAL '1 year')\n    GROUP BY p.Id, p.Title, p.CreationDate, p.ViewCount, p.Score\n),\nRankedPosts AS (\n    SELECT \n        pa.*,\n        RANK() OVER (ORDER BY pa.Score DESC, pa.ViewCount DESC) AS PostRank\n    FROM PostActivity pa\n),\nBizarreLogic AS (\n    SELECT \n        ups.UserId,\n        SUM(CASE WHEN ups.TotalUpvotes > ups.TotalDownvotes THEN 1 ELSE 0 END) AS PositiveContributions,\n        SUM(CASE WHEN ups.TotalDownvotes > ups.TotalUpvotes THEN 1 ELSE 0 END) AS NegativeContributions,\n        COUNT(DISTINCT rp.PostId) AS ContributingPosts,\n        STRING_AGG(rp.Title, '; ') AS PostTitles\n    FROM UserStats ups\n    LEFT JOIN RankedPosts rp ON ups.UserId = rp.PostId\n    WHERE ups.Reputation > 100 \n      AND (ups.GoldBadges + ups.SilverBadges + ups.BronzeBadges) >= 1\n    GROUP BY ups.UserId\n)\nSELECT *\nFROM BizarreLogic;", "sql2": "SELECT \n    bl.UserId,\n    u.DisplayName,\n    bl.PositiveContributions,\n    bl.NegativeContributions,\n    bl.ContributingPosts,\n    bl.PostTitles,\n    CASE \n        WHEN bl.PositiveContributions > bl.NegativeContributions THEN 'Overall Positive Contributor'\n        WHEN bl.NegativeContributions > bl.PositiveContributions THEN 'Overall Negative Contributor'\n        ELSE 'Neutral Contributor'\n    END AS ContributionType\nFROM s1 bl\nJOIN Users u ON bl.UserId = u.Id\nWHERE bl.ContributingPosts > 0\nORDER BY bl.PositiveContributions DESC, bl.NegativeContributions ASC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "24824.sql", "original_sql": "WITH UserBadgeStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(b.Id) AS BadgeCount,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Users u\n    LEFT JOIN Badges b ON u.Id = b.UserId\n    GROUP BY u.Id, u.DisplayName\n),\nPostAggregates AS (\n    SELECT \n        p.OwnerUserId,\n        COUNT(p.Id) AS TotalPosts,\n        COUNT(DISTINCT p.ParentId) AS AnsweredQuestions,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions,\n        SUM(CASE WHEN p.ViewCount > 100 THEN 1 ELSE 0 END) AS PopularPosts\n    FROM Posts p\n    GROUP BY p.OwnerUserId\n),\nUserActivity AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COALESCE(ps.TotalPosts, 0) AS TotalPosts,\n        COALESCE(ps.AnsweredQuestions, 0) AS AnsweredQuestions,\n        COALESCE(ps.Questions, 0) AS QuestionsPosted,\n        COALESCE(bs.BadgeCount, 0) AS BadgeCount,\n        COALESCE(bs.GoldBadges, 0) AS GoldBadges,\n        COALESCE(bs.SilverBadges, 0) AS SilverBadges,\n        COALESCE(bs.BronzeBadges, 0) AS BronzeBadges\n    FROM Users u\n    LEFT JOIN PostAggregates ps ON u.Id = ps.OwnerUserId\n    LEFT JOIN UserBadgeStats bs ON u.Id = bs.UserId\n    WHERE u.Reputation > (SELECT AVG(Reputation) FROM Users) \n      AND u.LastAccessDate = (SELECT MAX(LastAccessDate) FROM Users) \n)\n\nSELECT \n    ua.UserId,\n    ua.DisplayName,\n    ua.TotalPosts,\n    ua.AnsweredQuestions,\n    ua.QuestionsPosted,\n    ua.BadgeCount,\n    ua.GoldBadges,\n    ua.SilverBadges,\n    ua.BronzeBadges,\n    CASE WHEN ua.AnsweredQuestions > 0 THEN 'Active Contributor' ELSE 'Lurker' END AS UserStatus,\n    CASE \n        WHEN ua.BadgeCount = 0 THEN 'No Badges'\n        WHEN ua.BadgeCount BETWEEN 1 AND 3 THEN 'Novice'\n        WHEN ua.BadgeCount BETWEEN 4 AND 10 THEN 'Intermediate'\n        ELSE 'Expert'\n    END AS BadgeLevel\nFROM UserActivity ua\nORDER BY ua.TotalPosts DESC\nLIMIT 10\nOFFSET 0;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH ub AS (\n  SELECT u.Id AS UserId,\n         u.DisplayName,\n         COUNT(b.Id) AS BadgeCount,\n         SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n         SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n         SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n  FROM Users u\n  LEFT JOIN Badges b ON u.Id = b.UserId\n  GROUP BY u.Id, u.DisplayName\n),\npa AS (\n  SELECT p.OwnerUserId AS UserId,\n         COUNT(p.Id) AS TotalPosts,\n         COUNT(DISTINCT p.ParentId) AS AnsweredQuestions,\n         SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions,\n         SUM(CASE WHEN p.ViewCount > 100 THEN 1 ELSE 0 END) AS PopularPosts\n  FROM Posts p\n  GROUP BY p.OwnerUserId\n)\nSELECT \n  ub.UserId,\n  ub.DisplayName,\n  COALESCE(pa.TotalPosts,0) AS TotalPosts,\n  COALESCE(pa.AnsweredQuestions,0) AS AnsweredQuestions,\n  COALESCE(pa.Questions,0) AS QuestionsPosted,\n  COALESCE(ub.BadgeCount,0) AS BadgeCount,\n  COALESCE(ub.GoldBadges,0) AS GoldBadges,\n  COALESCE(ub.SilverBadges,0) AS SilverBadges,\n  COALESCE(ub.BronzeBadges,0) AS BronzeBadges\nFROM ub\nLEFT JOIN pa ON ub.UserId = pa.UserId;", "sql2": "SELECT \n    s1.UserId,\n    s1.DisplayName,\n    s1.TotalPosts,\n    s1.AnsweredQuestions,\n    s1.QuestionsPosted,\n    s1.BadgeCount,\n    s1.GoldBadges,\n    s1.SilverBadges,\n    s1.BronzeBadges,\n    CASE WHEN s1.AnsweredQuestions > 0 THEN 'Active Contributor' ELSE 'Lurker' END AS UserStatus,\n    CASE \n        WHEN s1.BadgeCount = 0 THEN 'No Badges'\n        WHEN s1.BadgeCount BETWEEN 1 AND 3 THEN 'Novice'\n        WHEN s1.BadgeCount BETWEEN 4 AND 10 THEN 'Intermediate'\n        ELSE 'Expert'\n    END AS BadgeLevel\nFROM s1\nJOIN Users u ON s1.UserId = u.Id\nWHERE u.Reputation > (SELECT AVG(Reputation) FROM Users)\n  AND u.LastAccessDate = (SELECT MAX(LastAccessDate) FROM Users)\nORDER BY s1.TotalPosts DESC\nLIMIT 10 OFFSET 0;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "25217.sql", "original_sql": "WITH TagCounts AS (\n    SELECT \n        t.Id AS TagId, \n        t.TagName, \n        COUNT(p.Id) AS PostCount\n    FROM \n        Tags t\n    LEFT JOIN \n        Posts p ON p.Tags LIKE '%' || t.TagName || '%'\n    GROUP BY \n        t.Id, t.TagName\n),\nMostActiveUsers AS (\n    SELECT \n        u.Id AS UserId, \n        u.DisplayName, \n        COUNT(p.Id) AS PostsCount,\n        SUM(COALESCE(CommentsCount, 0)) AS TotalComments,\n        SUM(u.UpVotes) AS TotalUpVotes,\n        SUM(u.DownVotes) AS TotalDownVotes\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON p.OwnerUserId = u.Id \n    LEFT JOIN \n        (SELECT PostId, COUNT(Id) AS CommentsCount \n         FROM Comments \n         GROUP BY PostId) c ON c.PostId = p.Id\n    WHERE \n        u.Reputation > 1000 \n    GROUP BY \n        u.Id, u.DisplayName\n),\nTopTags AS (\n    SELECT \n        TagId, \n        TagName, \n        PostCount\n    FROM \n        TagCounts\n    WHERE \n        PostCount > 0\n    ORDER BY \n        PostCount DESC \n    LIMIT 10\n)\nSELECT \n    u.DisplayName AS ActiveUser,\n    u.PostsCount,\n    u.TotalComments,\n    u.TotalUpVotes,\n    u.TotalDownVotes,\n    t.TagName,\n    t.PostCount\nFROM \n    MostActiveUsers u\nJOIN \n    TopTags t ON u.PostsCount > 5\nORDER BY \n    u.TotalUpVotes DESC, \n    t.PostCount DESC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "WITH TagCounts AS (\n    SELECT \n        t.Id AS TagId,\n        t.TagName,\n        COUNT(p.Id) AS PostCount\n    FROM Tags t\n    LEFT JOIN Posts p\n        ON p.Tags LIKE '%' || t.TagName || '%'\n    GROUP BY t.Id, t.TagName\n)\nSELECT \n    TagId,\n    TagName,\n    PostCount\nFROM TagCounts\nWHERE PostCount > 0\nORDER BY PostCount DESC\nLIMIT 10;", "sql2": "WITH MostActiveUsers AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(p.Id) AS PostsCount,\n        SUM(COALESCE(c.CommentsCount, 0)) AS TotalComments,\n        SUM(u.UpVotes) AS TotalUpVotes,\n        SUM(u.DownVotes) AS TotalDownVotes\n    FROM Users u\n    LEFT JOIN Posts p ON p.OwnerUserId = u.Id\n    LEFT JOIN (\n        SELECT PostId, COUNT(Id) AS CommentsCount\n        FROM Comments\n        GROUP BY PostId\n    ) c ON c.PostId = p.Id\n    WHERE u.Reputation > 1000\n    GROUP BY u.Id, u.DisplayName\n)\nSELECT \n    u.DisplayName AS ActiveUser,\n    u.PostsCount,\n    u.TotalComments,\n    u.TotalUpVotes,\n    u.TotalDownVotes,\n    s1.TagName,\n    s1.PostCount\nFROM MostActiveUsers u\nJOIN s1 ON u.PostsCount > 5\nORDER BY u.TotalUpVotes DESC, s1.PostCount DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "25396.sql", "original_sql": "WITH UserStatistics AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(DISTINCT P.Id) AS TotalPosts,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS Answers,\n        SUM(P.Score) AS TotalScore,\n        AVG(V.BountyAmount) AS AverageBounty \n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    LEFT JOIN \n        Votes V ON P.Id = V.PostId AND V.VoteTypeId = 8 \n    GROUP BY \n        U.Id, U.DisplayName\n),\nClosedPostStatistics AS (\n    SELECT \n        PH.UserId,\n        COUNT(DISTINCT PH.PostId) AS TotalClosedPosts,\n        COUNT(DISTINCT CASE WHEN P.PostTypeId = 1 THEN PH.PostId END) AS TotalClosedQuestions,\n        COUNT(DISTINCT CASE WHEN P.PostTypeId = 2 THEN PH.PostId END) AS TotalClosedAnswers,\n        COUNT(DISTINCT PH.Comment) AS TotalCloseReasons\n    FROM \n        PostHistory PH\n    JOIN \n        Posts P ON PH.PostId = P.Id\n    WHERE \n        PH.PostHistoryTypeId IN (10, 11) \n    GROUP BY \n        PH.UserId\n)\nSELECT \n    US.UserId,\n    US.DisplayName,\n    US.TotalPosts,\n    US.Questions,\n    US.Answers,\n    US.TotalScore,\n    US.AverageBounty,\n    CPS.TotalClosedPosts,\n    CPS.TotalClosedQuestions,\n    CPS.TotalClosedAnswers,\n    CPS.TotalCloseReasons\nFROM \n    UserStatistics US\nLEFT JOIN \n    ClosedPostStatistics CPS ON US.UserId = CPS.UserId\nORDER BY \n    US.TotalScore DESC,\n    US.TotalPosts DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    U.Id AS UserId,\n    U.DisplayName,\n    COUNT(DISTINCT P.Id) AS TotalPosts,\n    SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions,\n    SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS Answers,\n    SUM(P.Score) AS TotalScore,\n    AVG(V.BountyAmount) AS AverageBounty\nFROM Users U\nLEFT JOIN Posts P ON U.Id = P.OwnerUserId\nLEFT JOIN Votes V ON P.Id = V.PostId AND V.VoteTypeId = 8\nGROUP BY U.Id, U.DisplayName;", "sql2": "WITH ClosedPostStatistics AS (\n    SELECT \n        PH.UserId,\n        COUNT(DISTINCT PH.PostId) AS TotalClosedPosts,\n        COUNT(DISTINCT CASE WHEN P.PostTypeId = 1 THEN PH.PostId END) AS TotalClosedQuestions,\n        COUNT(DISTINCT CASE WHEN P.PostTypeId = 2 THEN PH.PostId END) AS TotalClosedAnswers,\n        COUNT(DISTINCT PH.Comment) AS TotalCloseReasons\n    FROM PostHistory PH\n    JOIN Posts P ON PH.PostId = P.Id\n    WHERE PH.PostHistoryTypeId IN (10, 11)\n    GROUP BY PH.UserId\n)\nSELECT \n    s1.UserId,\n    s1.DisplayName,\n    s1.TotalPosts,\n    s1.Questions,\n    s1.Answers,\n    s1.TotalScore,\n    s1.AverageBounty,\n    CPS.TotalClosedPosts,\n    CPS.TotalClosedQuestions,\n    CPS.TotalClosedAnswers,\n    CPS.TotalCloseReasons\nFROM s1\nLEFT JOIN ClosedPostStatistics CPS ON s1.UserId = CPS.UserId\nORDER BY s1.TotalScore DESC, s1.TotalPosts DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "25546.sql", "original_sql": "WITH PostTagStatistics AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.ViewCount,\n        p.AnswerCount,\n        p.CreationDate,\n        STRING_AGG(DISTINCT t.TagName, ', ') AS TagsList,\n        COUNT(DISTINCT mh.UserId) AS TotalModerationHistory,\n        COALESCE(SUM(CASE WHEN mh.PostHistoryTypeId = 10 THEN 1 ELSE 0 END), 0) AS TotalClosures,\n        COALESCE(SUM(CASE WHEN mh.PostHistoryTypeId = 11 THEN 1 ELSE 0 END), 0) AS TotalReopens\n    FROM \n        Posts p\n    LEFT JOIN \n        Tags t ON POSITION(t.TagName IN p.Tags) > 0  \n    LEFT JOIN \n        PostHistory mh ON mh.PostId = p.Id\n    WHERE \n        p.PostTypeId = 1  \n        AND p.CreationDate >= cast('2024-10-01 12:34:56' as timestamp) - INTERVAL '1 year'  \n    GROUP BY \n        p.Id, p.Title, p.ViewCount, p.AnswerCount, p.CreationDate\n),\nUserPostEngagement AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(DISTINCT p.Id) AS TotalPosts,\n        SUM(p.ViewCount) AS TotalViews,\n        SUM(CASE WHEN p.AnswerCount > 0 THEN 1 ELSE 0 END) AS TotalAnswered,\n        SUM(CASE WHEN p.ViewCount > 100 THEN 1 ELSE 0 END) AS HighEngagementPosts\n    FROM \n        Users u\n    JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    WHERE \n        p.CreationDate >= cast('2024-10-01 12:34:56' as timestamp) - INTERVAL '1 year'  \n    GROUP BY \n        u.Id, u.DisplayName\n),\nBenchmarkingResults AS (\n    SELECT \n        pts.PostId,\n        pts.Title,\n        pts.TagsList,\n        ups.DisplayName AS UserDisplayName,\n        ups.TotalPosts,\n        ups.TotalViews,\n        ups.TotalAnswered,\n        ups.HighEngagementPosts,\n        pts.TotalModerationHistory,\n        pts.TotalClosures,\n        pts.TotalReopens\n    FROM \n        PostTagStatistics pts\n    JOIN \n        UserPostEngagement ups ON pts.PostId = ups.TotalPosts\n    ORDER BY \n        pts.ViewCount DESC,  \n        ups.TotalPosts DESC   \n)\nSELECT \n    BenchmarkingResults.*\nFROM \n    BenchmarkingResults\nWHERE \n    TotalViews > 500  \nORDER BY \n    TotalAnswered DESC;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'postid' not found in 's1'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"postid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"ups\" }), name: \"userid\" }, Column { relation: Some(Bare { table: \"ups\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"ups\" }), name: \"totalposts\" }, Column { relation: Some(Bare { table: \"ups\" }), name: \"totalviews\" }, Column { relation: Some(Bare { table: \"ups\" }), name: \"totalanswered\" }, Column { relation: Some(Bare { table: \"ups\" }), name: \"highengagementposts\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "25679.sql", "original_sql": "WITH UserBadges AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(B.Id) AS BadgeCount,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Users U\n    LEFT JOIN \n        Badges B ON U.Id = B.UserId\n    GROUP BY \n        U.Id, U.DisplayName\n),\nPostStats AS (\n    SELECT \n        P.OwnerUserId,\n        COUNT(P.Id) AS PostCount,\n        SUM(P.ViewCount) AS TotalViews,\n        SUM(P.Score) AS TotalScore,\n        AVG(P.Score) AS AvgScore\n    FROM \n        Posts P\n    WHERE \n        P.OwnerUserId IS NOT NULL\n    GROUP BY \n        P.OwnerUserId\n),\nUserPostBadgeStats AS (\n    SELECT \n        U.DisplayName,\n        U.BadgeCount,\n        U.GoldBadges,\n        U.SilverBadges,\n        U.BronzeBadges,\n        P.PostCount,\n        P.TotalViews,\n        P.TotalScore,\n        P.AvgScore\n    FROM \n        UserBadges U\n    JOIN \n        PostStats P ON U.UserId = P.OwnerUserId\n)\n\nSELECT \n    DisplayName,\n    BadgeCount,\n    GoldBadges,\n    SilverBadges,\n    BronzeBadges,\n    PostCount,\n    TotalViews,\n    TotalScore,\n    AvgScore\nFROM \n    UserPostBadgeStats\nWHERE \n    BadgeCount > 0 AND PostCount > 10\nORDER BY \n    TotalScore DESC, TotalViews DESC\nLIMIT 10;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT U.Id AS UserId,\n       U.DisplayName,\n       COUNT(B.Id) AS BadgeCount,\n       SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n       SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n       SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\nFROM Users U\nLEFT JOIN Badges B ON U.Id = B.UserId\nGROUP BY U.Id, U.DisplayName;", "sql2": "SELECT ub.DisplayName,\n       ub.BadgeCount,\n       ub.GoldBadges,\n       ub.SilverBadges,\n       ub.BronzeBadges,\n       ps.PostCount,\n       ps.TotalViews,\n       ps.TotalScore,\n       ps.AvgScore\nFROM s1 ub\nJOIN (\n    SELECT OwnerUserId,\n           COUNT(Id) AS PostCount,\n           SUM(ViewCount) AS TotalViews,\n           SUM(Score) AS TotalScore,\n           AVG(Score) AS AvgScore\n    FROM Posts\n    WHERE OwnerUserId IS NOT NULL\n    GROUP BY OwnerUserId\n) ps ON ub.UserId = ps.OwnerUserId\nWHERE ub.BadgeCount > 0 AND ps.PostCount > 10\nORDER BY ps.TotalScore DESC, ps.TotalViews DESC\nLIMIT 10;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "26327.sql", "original_sql": "\nWITH UserBadgeSummary AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(B.Id) AS BadgeCount,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Users U\n    LEFT JOIN \n        Badges B ON U.Id = B.UserId\n    GROUP BY \n        U.Id, U.DisplayName\n),\nPostStatistics AS (\n    SELECT \n        P.OwnerUserId,\n        COUNT(P.Id) AS TotalPosts,\n        COUNT(CASE WHEN P.PostTypeId = 1 THEN 1 END) AS Questions,\n        COUNT(CASE WHEN P.PostTypeId = 2 THEN 1 END) AS Answers,\n        COUNT(CASE WHEN P.PostTypeId IN (4, 5) THEN 1 END) AS TagWikis,\n        SUM(P.ViewCount) AS TotalViews,\n        SUM(P.Score) AS TotalScore\n    FROM \n        Posts P\n    GROUP BY \n        P.OwnerUserId\n),\nUserPostBadgeSummary AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        UBS.BadgeCount,\n        UBS.GoldBadges,\n        UBS.SilverBadges,\n        UBS.BronzeBadges,\n        PS.TotalPosts,\n        PS.Questions,\n        PS.Answers,\n        PS.TagWikis,\n        PS.TotalViews,\n        PS.TotalScore\n    FROM \n        UserBadgeSummary UBS\n    JOIN \n        PostStatistics PS ON UBS.UserId = PS.OwnerUserId \n    JOIN \n        Users U ON UBS.UserId = U.Id\n)\nSELECT \n    UserId,\n    DisplayName,\n    BadgeCount,\n    GoldBadges,\n    SilverBadges,\n    BronzeBadges,\n    TotalPosts,\n    Questions,\n    Answers,\n    TagWikis,\n    TotalViews,\n    TotalScore,\n    CASE \n        WHEN TotalPosts > 0 THEN TotalScore / CAST(TotalPosts AS FLOAT) \n        ELSE 0 \n    END AS AvgScorePerPost\nFROM \n    UserPostBadgeSummary\nORDER BY \n    AvgScorePerPost DESC,\n    BadgeCount DESC\nLIMIT 10;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column ps.userid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"userid\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"totalposts\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"questions\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"answers\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"tagwikis\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"totalviews\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"totalscore\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "26783.sql", "original_sql": "\nWITH UserBadges AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(B.Id) AS TotalBadges,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Users U\n    LEFT JOIN \n        Badges B ON U.Id = B.UserId\n    GROUP BY \n        U.Id, U.DisplayName\n),\nRecentPosts AS (\n    SELECT \n        P.OwnerUserId,\n        P.Title,\n        P.CreationDate,\n        COUNT(C.Id) AS CommentCount,\n        SUM(CASE WHEN V.CreationDate IS NOT NULL THEN 1 ELSE 0 END) AS VoteCount\n    FROM \n        Posts P\n    LEFT JOIN \n        Comments C ON P.Id = C.PostId\n    LEFT JOIN \n        Votes V ON P.Id = V.PostId\n    WHERE \n        P.CreationDate >= (CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '30 days')\n    GROUP BY \n        P.OwnerUserId, P.Title, P.CreationDate\n),\nUserActivity AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        UB.TotalBadges,\n        UB.GoldBadges,\n        UB.SilverBadges,\n        UB.BronzeBadges,\n        COUNT(RP.Title) AS RecentPostCount,\n        SUM(RP.CommentCount) AS TotalComments,\n        SUM(RP.VoteCount) AS TotalVotes\n    FROM \n        UserBadges UB\n    LEFT JOIN \n        RecentPosts RP ON UB.UserId = RP.OwnerUserId\n    LEFT JOIN \n        Users U ON UB.UserId = U.Id\n    GROUP BY \n        U.Id, U.DisplayName, UB.TotalBadges, UB.GoldBadges, UB.SilverBadges, UB.BronzeBadges\n)\nSELECT \n    UA.UserId,\n    UA.DisplayName,\n    UA.TotalBadges,\n    UA.GoldBadges,\n    UA.SilverBadges,\n    UA.BronzeBadges,\n    UA.RecentPostCount,\n    UA.TotalComments,\n    UA.TotalVotes\nFROM \n    UserActivity UA\nORDER BY \n    UA.TotalBadges DESC, \n    UA.TotalComments DESC, \n    UA.RecentPostCount DESC\nLIMIT 10;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT \n    U.Id AS UserId,\n    U.DisplayName,\n    COUNT(B.Id) AS TotalBadges,\n    SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n    SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n    SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\nFROM Users U\nLEFT JOIN Badges B ON U.Id = B.UserId\nGROUP BY U.Id, U.DisplayName;", "sql2": "WITH RecentPosts AS (\n    SELECT \n        P.OwnerUserId,\n        COUNT(C.Id) AS CommentCount,\n        SUM(CASE WHEN V.CreationDate IS NOT NULL THEN 1 ELSE 0 END) AS VoteCount\n    FROM Posts P\n    LEFT JOIN Comments C ON P.Id = C.PostId\n    LEFT JOIN Votes V ON P.Id = V.PostId\n    WHERE P.CreationDate >= (CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '30 days')\n    GROUP BY P.OwnerUserId\n)\nSELECT \n    ub.UserId,\n    ub.DisplayName,\n    ub.TotalBadges,\n    ub.GoldBadges,\n    ub.SilverBadges,\n    ub.BronzeBadges,\n    COUNT(rp.OwnerUserId) AS RecentPostCount,\n    COALESCE(SUM(rp.CommentCount),0) AS TotalComments,\n    COALESCE(SUM(rp.VoteCount),0) AS TotalVotes\nFROM s1 ub\nLEFT JOIN RecentPosts rp ON ub.UserId = rp.OwnerUserId\nGROUP BY ub.UserId, ub.DisplayName, ub.TotalBadges, ub.GoldBadges, ub.SilverBadges, ub.BronzeBadges\nORDER BY ub.TotalBadges DESC, TotalComments DESC, RecentPostCount DESC\nLIMIT 10;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "28027.sql", "original_sql": "WITH TagCounts AS (\n    SELECT\n        Tags.TagName,\n        COUNT(*) AS PostCount,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        SUM(CASE WHEN PH.PostHistoryTypeId = 10 THEN 1 ELSE 0 END) AS ClosedPostCount\n    FROM \n        Posts P\n    JOIN \n        Tags ON P.Tags LIKE '%' || Tags.TagName || '%'\n    LEFT JOIN \n        PostHistory PH ON P.Id = PH.PostId\n    GROUP BY \n        Tags.TagName\n), \nUserVotes AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVoteCount,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVoteCount\n    FROM \n        Users U\n    LEFT JOIN \n        Votes V ON U.Id = V.UserId\n    GROUP BY \n        U.Id, U.DisplayName\n),\nPostMetrics AS (\n    SELECT \n        P.Id AS PostId,\n        P.Title,\n        COALESCE(PC.PostCount, 0) AS TotalPosts,\n        COALESCE(UC.UpVoteCount, 0) AS TotalUpVotes,\n        COALESCE(UC.DownVoteCount, 0) AS TotalDownVotes,\n        COALESCE(TC.ClosedPostCount, 0) AS TotalClosedPosts\n    FROM \n        Posts P\n    LEFT JOIN \n        (SELECT \n            P.Id, \n            COUNT(P.Id) AS PostCount \n        FROM \n            Posts P \n        WHERE \n            P.PostTypeId IN (1, 2) \n        GROUP BY \n            P.Id) PC ON P.Id = PC.Id\n    LEFT JOIN \n        UserVotes UC ON P.OwnerUserId = UC.UserId\n    LEFT JOIN \n        TagCounts TC ON P.Tags LIKE '%' || TC.TagName || '%'\n)\nSELECT \n    Title,\n    TotalPosts,\n    TotalUpVotes,\n    TotalDownVotes,\n    TotalClosedPosts\nFROM \n    PostMetrics\nWHERE \n    TotalPosts > 1\nORDER BY \n    TotalPosts DESC, TotalUpVotes DESC, TotalDownVotes ASC\nLIMIT 10;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"tagname\" }, valid_fields: [Column { relation: Some(Bare { table: \"p\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"posttypeid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"acceptedanswerid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"parentid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"creationdate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"score\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"viewcount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"body\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"owneruserid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"ownerdisplayname\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lasteditoruserid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lasteditordisplayname\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lasteditdate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lastactivitydate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"title\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"tags\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"answercount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"commentcount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"favoritecount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"closeddate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"communityowneddate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"contentlicense\" }, Column { relation: Some(Bare { table: \"pc\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"pc\" }), name: \"postcount\" }, Column { relation: Some(Bare { table: \"uv\" }), name: \"userid\" }, Column { relation: Some(Bare { table: \"uv\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"uv\" }), name: \"upvotecount\" }, Column { relation: Some(Bare { table: \"uv\" }), name: \"downvotecount\" }, Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))\n", "engine_mem_mb": 500000}
{"query_id": "28306.sql", "original_sql": "WITH TagStats AS (\n    SELECT \n        t.TagName,\n        COUNT(DISTINCT p.Id) AS PostCount,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        AVG(p.ViewCount) AS AvgViewCount,\n        AVG(p.Score) AS AvgScore,\n        MAX(p.CreationDate) AS RecentPostDate\n    FROM \n        Tags t\n    LEFT JOIN \n        Posts p ON p.Tags LIKE '%' || t.TagName || '%'\n    GROUP BY \n        t.TagName\n),\nUserActivity AS (\n    SELECT \n        u.DisplayName,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalDownVotes,\n        SUM(CASE WHEN c.Id IS NOT NULL THEN 1 ELSE 0 END) AS TotalComments,\n        SUM(CASE WHEN b.Id IS NOT NULL THEN 1 ELSE 0 END) AS TotalBadges\n    FROM \n        Users u\n    LEFT JOIN \n        Votes v ON v.UserId = u.Id\n    LEFT JOIN \n        Comments c ON c.UserId = u.Id\n    LEFT JOIN \n        Badges b ON b.UserId = u.Id\n    GROUP BY \n        u.DisplayName\n),\nPostTrends AS (\n    SELECT \n        p.OwnerDisplayName,\n        COUNT(*) AS TotalPosts,\n        SUM(CASE WHEN p.Score > 0 THEN 1 ELSE 0 END) AS PositivePosts,\n        SUM(CASE WHEN p.ViewCount > 100 THEN 1 ELSE 0 END) AS PopularPosts\n    FROM \n        Posts p\n    GROUP BY \n        p.OwnerDisplayName\n)\nSELECT \n    ts.TagName,\n    ts.PostCount,\n    ts.QuestionCount,\n    ts.AnswerCount,\n    ts.AvgViewCount,\n    ts.AvgScore,\n    ts.RecentPostDate,\n    ua.DisplayName AS ActiveUser,\n    ua.TotalUpVotes,\n    ua.TotalDownVotes,\n    ua.TotalComments,\n    ua.TotalBadges,\n    pt.TotalPosts,\n    pt.PositivePosts,\n    pt.PopularPosts\nFROM \n    TagStats ts\nJOIN \n    UserActivity ua ON ua.TotalUpVotes > 0\nJOIN \n    PostTrends pt ON pt.TotalPosts > 5\nORDER BY \n    ts.PostCount DESC, ua.TotalUpVotes DESC, pt.TotalPosts DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    t.TagName,\n    COUNT(DISTINCT p.Id) AS PostCount,\n    SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n    SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n    AVG(p.ViewCount) AS AvgViewCount,\n    AVG(p.Score) AS AvgScore,\n    MAX(p.CreationDate) AS RecentPostDate\nFROM Tags t\nLEFT JOIN Posts p ON p.Tags LIKE '%' || t.TagName || '%'\nGROUP BY t.TagName;", "sql2": "SELECT \n    ts.TagName,\n    ts.PostCount,\n    ts.QuestionCount,\n    ts.AnswerCount,\n    ts.AvgViewCount,\n    ts.AvgScore,\n    ts.RecentPostDate,\n    ua.DisplayName AS ActiveUser,\n    ua.TotalUpVotes,\n    ua.TotalDownVotes,\n    ua.TotalComments,\n    ua.TotalBadges,\n    pt.TotalPosts,\n    pt.PositivePosts,\n    pt.PopularPosts\nFROM s1 ts\nJOIN (\n    SELECT \n        u.DisplayName,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalDownVotes,\n        SUM(CASE WHEN c.Id IS NOT NULL THEN 1 ELSE 0 END) AS TotalComments,\n        SUM(CASE WHEN b.Id IS NOT NULL THEN 1 ELSE 0 END) AS TotalBadges\n    FROM Users u\n    LEFT JOIN Votes v ON v.UserId = u.Id\n    LEFT JOIN Comments c ON c.UserId = u.Id\n    LEFT JOIN Badges b ON b.UserId = u.Id\n    GROUP BY u.DisplayName\n) ua ON ua.TotalUpVotes > 0\nJOIN (\n    SELECT \n        p.OwnerDisplayName,\n        COUNT(*) AS TotalPosts,\n        SUM(CASE WHEN p.Score > 0 THEN 1 ELSE 0 END) AS PositivePosts,\n        SUM(CASE WHEN p.ViewCount > 100 THEN 1 ELSE 0 END) AS PopularPosts\n    FROM Posts p\n    GROUP BY p.OwnerDisplayName\n) pt ON pt.TotalPosts > 5\nORDER BY ts.PostCount DESC, ua.TotalUpVotes DESC, pt.TotalPosts DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "28437.sql", "original_sql": "\nWITH UserBadgeStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(B.Id) AS BadgeCount,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Users U\n    LEFT JOIN Badges B ON U.Id = B.UserId\n    GROUP BY U.Id, U.DisplayName\n),\nPostAggStats AS (\n    SELECT \n        P.OwnerUserId,\n        COUNT(P.Id) AS TotalPosts,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        AVG(P.Score) AS AvgScore,\n        SUM(P.ViewCount) AS TotalViews\n    FROM Posts P\n    GROUP BY P.OwnerUserId\n),\nPostHistoryStats AS (\n    SELECT \n        PH.UserId,\n        COUNT(PH.Id) AS TotalEdits,\n        SUM(CASE WHEN PH.PostHistoryTypeId IN (4, 5, 6) THEN 1 ELSE 0 END) AS TitleEdits,\n        SUM(CASE WHEN PH.PostHistoryTypeId = 10 THEN 1 ELSE 0 END) AS PostsClosed,\n        SUM(CASE WHEN PH.PostHistoryTypeId = 12 THEN 1 ELSE 0 END) AS PostsDeleted\n    FROM PostHistory PH\n    GROUP BY PH.UserId\n)\nSELECT \n    U.Id AS UserId,\n    U.DisplayName,\n    COALESCE(UB.BadgeCount, 0) AS BadgeCount,\n    COALESCE(UB.GoldBadges, 0) AS GoldBadges,\n    COALESCE(UB.SilverBadges, 0) AS SilverBadges,\n    COALESCE(UB.BronzeBadges, 0) AS BronzeBadges,\n    COALESCE(PA.TotalPosts, 0) AS TotalPosts,\n    COALESCE(PA.QuestionCount, 0) AS QuestionCount,\n    COALESCE(PA.AnswerCount, 0) AS AnswerCount,\n    COALESCE(PA.AvgScore, 0) AS AvgScore,\n    COALESCE(PA.TotalViews, 0) AS TotalViews,\n    COALESCE(PH.TotalEdits, 0) AS TotalEdits,\n    COALESCE(PH.TitleEdits, 0) AS TitleEdits,\n    COALESCE(PH.PostsClosed, 0) AS PostsClosed,\n    COALESCE(PH.PostsDeleted, 0) AS PostsDeleted\nFROM Users U\nLEFT JOIN UserBadgeStats UB ON U.Id = UB.UserId\nLEFT JOIN PostAggStats PA ON U.Id = PA.OwnerUserId\nLEFT JOIN PostHistoryStats PH ON U.Id = PH.UserId\nORDER BY BadgeCount DESC, TotalPosts DESC, AvgScore DESC\nLIMIT 100;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: SchemaError(AmbiguousReference { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"avgscore\" } }, Some(\"\"))\n", "engine_mem_mb": 500000}
{"query_id": "28597.sql", "original_sql": "WITH TagAnalysis AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        COUNT(DISTINCT c.Id) AS CommentCount,\n        COALESCE(SUM(v.BountyAmount), 0) AS TotalBounty,\n        STRING_AGG(DISTINCT t.TagName, ', ') AS Tags\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId AND v.VoteTypeId = 9 \n    LEFT JOIN \n        Tags t ON t.ExcerptPostId = p.Id OR t.WikiPostId = p.Id\n    WHERE \n        p.PostTypeId = 1 \n    GROUP BY \n        p.Id, p.Title, p.CreationDate\n),\nUserBadgeStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(DISTINCT b.Id) AS BadgeCount,\n        SUM(u.Reputation) AS TotalReputation\n    FROM \n        Users u\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    GROUP BY \n        u.Id, u.DisplayName\n),\nPostHistoryStats AS (\n    SELECT \n        p.Id AS PostId,\n        COUNT(h.Id) AS HistoryCount,\n        MAX(h.CreationDate) AS LastHistoryDate\n    FROM \n        Posts p\n    LEFT JOIN \n        PostHistory h ON p.Id = h.PostId\n    GROUP BY \n        p.Id\n)\nSELECT \n    ta.PostId,\n    ta.Title,\n    ta.CreationDate,\n    ta.CommentCount,\n    ta.TotalBounty,\n    ta.Tags,\n    ubs.DisplayName,\n    ubs.BadgeCount,\n    ubs.TotalReputation,\n    phs.HistoryCount,\n    phs.LastHistoryDate\nFROM \n    TagAnalysis ta\nJOIN \n    Users u ON u.Id = ta.PostId \nJOIN \n    UserBadgeStats ubs ON u.Id = ubs.UserId\nJOIN \n    PostHistoryStats phs ON ta.PostId = phs.PostId\nORDER BY \n    ta.CommentCount DESC, \n    ubs.TotalReputation DESC;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'postid' not found in 's1'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"postid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"reputation\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"creationdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"lastaccessdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"websiteurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"location\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"aboutme\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"views\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"upvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"downvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"profileimageurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"accountid\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "28751.sql", "original_sql": "\nWITH RankedPosts AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.Body,\n        p.ViewCount,\n        p.CreationDate,\n        p.OwnerUserId,\n        p.AcceptedAnswerId,\n        ROW_NUMBER() OVER (PARTITION BY p.OwnerUserId ORDER BY p.CreationDate DESC) AS UserPostRank\n    FROM Posts p\n    WHERE p.PostTypeId = 1 \n),\nUserReputation AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        u.Reputation,\n        CASE \n            WHEN u.Reputation > 1000 THEN 'High'\n            WHEN u.Reputation BETWEEN 500 AND 1000 THEN 'Medium'\n            ELSE 'Low' \n        END AS ReputationLevel\n    FROM Users u\n),\nTopQuestions AS (\n    SELECT \n        rp.PostId,\n        rp.Title,\n        rp.ViewCount,\n        ur.DisplayName,\n        ur.ReputationLevel,\n        COUNT(a.Id) AS AnswerCount\n    FROM RankedPosts rp\n    JOIN UserReputation ur ON rp.OwnerUserId = ur.UserId\n    LEFT JOIN Posts a ON rp.PostId = a.ParentId\n    GROUP BY rp.PostId, rp.Title, rp.ViewCount, ur.DisplayName, ur.ReputationLevel\n    ORDER BY rp.ViewCount DESC\n    LIMIT 10\n),\nVoteDetails AS (\n    SELECT \n        p.Id AS PostId, \n        v.VoteTypeId, \n        COUNT(v.Id) AS VoteCount\n    FROM Posts p\n    JOIN Votes v ON p.Id = v.PostId\n    GROUP BY p.Id, v.VoteTypeId\n)\nSELECT \n    tq.PostId,\n    tq.Title,\n    tq.ViewCount,\n    tq.DisplayName,\n    tq.ReputationLevel,\n    COALESCE(SUM(CASE WHEN vd.VoteTypeId = 2 THEN vd.VoteCount ELSE 0 END), 0) AS UpVotes,\n    COALESCE(SUM(CASE WHEN vd.VoteTypeId = 3 THEN vd.VoteCount ELSE 0 END), 0) AS DownVotes,\n    COALESCE(SUM(CASE WHEN vd.VoteTypeId = 6 THEN vd.VoteCount ELSE 0 END), 0) AS CloseVotes,\n    tq.AnswerCount\nFROM TopQuestions tq\nLEFT JOIN VoteDetails vd ON tq.PostId = vd.PostId\nGROUP BY \n    tq.PostId, \n    tq.Title, \n    tq.ViewCount, \n    tq.DisplayName, \n    tq.ReputationLevel,\n    tq.AnswerCount\nORDER BY tq.ViewCount DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH RankedPosts AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.Body,\n        p.ViewCount,\n        p.CreationDate,\n        p.OwnerUserId,\n        p.AcceptedAnswerId,\n        ROW_NUMBER() OVER (PARTITION BY p.OwnerUserId ORDER BY p.CreationDate DESC) AS UserPostRank\n    FROM Posts p\n    WHERE p.PostTypeId = 1 \n),\nUserReputation AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        u.Reputation,\n        CASE \n            WHEN u.Reputation > 1000 THEN 'High'\n            WHEN u.Reputation BETWEEN 500 AND 1000 THEN 'Medium'\n            ELSE 'Low' \n        END AS ReputationLevel\n    FROM Users u\n),\nTopQuestions AS (\n    SELECT \n        rp.PostId,\n        rp.Title,\n        rp.ViewCount,\n        ur.DisplayName,\n        ur.ReputationLevel,\n        COUNT(a.Id) AS AnswerCount\n    FROM RankedPosts rp\n    JOIN UserReputation ur ON rp.OwnerUserId = ur.UserId\n    LEFT JOIN Posts a ON rp.PostId = a.ParentId\n    GROUP BY rp.PostId, rp.Title, rp.ViewCount, ur.DisplayName, ur.ReputationLevel\n    ORDER BY rp.ViewCount DESC\n    LIMIT 10\n)\nSELECT \n    tq.PostId,\n    tq.Title,\n    tq.ViewCount,\n    tq.DisplayName,\n    tq.ReputationLevel,\n    tq.AnswerCount\nFROM TopQuestions tq;", "sql2": "WITH VoteDetails AS (\n    SELECT \n        p.Id AS PostId,\n        v.VoteTypeId,\n        COUNT(v.Id) AS VoteCount\n    FROM Posts p\n    JOIN Votes v ON p.Id = v.PostId\n    GROUP BY p.Id, v.VoteTypeId\n)\nSELECT \n    s1.PostId,\n    s1.Title,\n    s1.ViewCount,\n    s1.DisplayName,\n    s1.ReputationLevel,\n    COALESCE(SUM(CASE WHEN vd.VoteTypeId = 2 THEN vd.VoteCount END), 0) AS UpVotes,\n    COALESCE(SUM(CASE WHEN vd.VoteTypeId = 3 THEN vd.VoteCount END), 0) AS DownVotes,\n    COALESCE(SUM(CASE WHEN vd.VoteTypeId = 6 THEN vd.VoteCount END), 0) AS CloseVotes,\n    s1.AnswerCount\nFROM s1\nLEFT JOIN VoteDetails vd ON s1.PostId = vd.PostId\nGROUP BY \n    s1.PostId, \n    s1.Title, \n    s1.ViewCount, \n    s1.DisplayName, \n    s1.ReputationLevel,\n    s1.AnswerCount\nORDER BY s1.ViewCount DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "2880.sql", "original_sql": "\nWITH UserBadgeCounts AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(B.Id) AS BadgeCount,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Users U\n    LEFT JOIN \n        Badges B ON U.Id = B.UserId\n    GROUP BY \n        U.Id, U.DisplayName\n),\nPostStatistics AS (\n    SELECT \n        P.OwnerUserId,\n        COUNT(CASE WHEN P.PostTypeId = 1 THEN 1 END) AS QuestionCount,\n        COUNT(CASE WHEN P.PostTypeId = 2 THEN 1 END) AS AnswerCount,\n        SUM(P.Score) AS TotalScore,\n        AVG(P.ViewCount) AS AvgViewCount,\n        COUNT(DISTINCT P.Tags) AS UniqueTagCount\n    FROM \n        Posts P\n    GROUP BY \n        P.OwnerUserId\n),\nTopUsers AS (\n    SELECT \n        U.Id,\n        U.DisplayName,\n        COALESCE(UBC.BadgeCount, 0) AS BadgeCount,\n        COALESCE(PS.QuestionCount, 0) AS QuestionCount,\n        COALESCE(PS.AnswerCount, 0) AS AnswerCount,\n        COALESCE(PS.TotalScore, 0) AS TotalScore,\n        COALESCE(PS.AvgViewCount, 0) AS AvgViewCount,\n        COALESCE(UBC.GoldBadges, 0) AS GoldBadges,\n        COALESCE(UBC.SilverBadges, 0) AS SilverBadges,\n        COALESCE(UBC.BronzeBadges, 0) AS BronzeBadges\n    FROM \n        Users U\n    LEFT JOIN \n        UserBadgeCounts UBC ON U.Id = UBC.UserId\n    LEFT JOIN \n        PostStatistics PS ON U.Id = PS.OwnerUserId\n)\nSELECT \n    TU.DisplayName,\n    TU.BadgeCount,\n    TU.QuestionCount,\n    TU.AnswerCount,\n    TU.TotalScore,\n    TU.AvgViewCount,\n    CONCAT('Gold: ', TU.GoldBadges, ', Silver: ', TU.SilverBadges, ', Bronze: ', TU.BronzeBadges) AS BadgeSummary\nFROM \n    TopUsers TU\nWHERE \n    TU.BadgeCount > 0\nORDER BY \n    TU.TotalScore DESC,\n    TU.BadgeCount DESC\nLIMIT 10;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH UserBadgeCounts AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(B.Id) AS BadgeCount,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Users U\n    LEFT JOIN \n        Badges B ON U.Id = B.UserId\n    GROUP BY \n        U.Id, U.DisplayName\n),\nPostStatistics AS (\n    SELECT \n        P.OwnerUserId,\n        COUNT(CASE WHEN P.PostTypeId = 1 THEN 1 END) AS QuestionCount,\n        COUNT(CASE WHEN P.PostTypeId = 2 THEN 1 END) AS AnswerCount,\n        SUM(P.Score) AS TotalScore,\n        AVG(P.ViewCount) AS AvgViewCount,\n        COUNT(DISTINCT P.Tags) AS UniqueTagCount\n    FROM \n        Posts P\n    GROUP BY \n        P.OwnerUserId\n),\nTopUsers AS (\n    SELECT \n        U.Id,\n        U.DisplayName,\n        COALESCE(UBC.BadgeCount, 0) AS BadgeCount,\n        COALESCE(PS.QuestionCount, 0) AS QuestionCount,\n        COALESCE(PS.AnswerCount, 0) AS AnswerCount,\n        COALESCE(PS.TotalScore, 0) AS TotalScore,\n        COALESCE(PS.AvgViewCount, 0) AS AvgViewCount,\n        COALESCE(UBC.GoldBadges, 0) AS GoldBadges,\n        COALESCE(UBC.SilverBadges, 0) AS SilverBadges,\n        COALESCE(UBC.BronzeBadges, 0) AS BronzeBadges\n    FROM \n        Users U\n    LEFT JOIN \n        UserBadgeCounts UBC ON U.Id = UBC.UserId\n    LEFT JOIN \n        PostStatistics PS ON U.Id = PS.OwnerUserId\n)\nSELECT * FROM TopUsers;", "sql2": "SELECT \n    DisplayName,\n    BadgeCount,\n    QuestionCount,\n    AnswerCount,\n    TotalScore,\n    AvgViewCount,\n    CONCAT('Gold: ', GoldBadges, ', Silver: ', SilverBadges, ', Bronze: ', BronzeBadges) AS BadgeSummary\nFROM s1\nWHERE BadgeCount > 0\nORDER BY TotalScore DESC, BadgeCount DESC\nLIMIT 10;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "2885.sql", "original_sql": "\nWITH UserBadges AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(b.Id) AS TotalBadges,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Users u\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    GROUP BY \n        u.Id, u.DisplayName\n),\nPopularPosts AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        COUNT(c.Id) AS CommentCount,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVoteCount,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVoteCount\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    WHERE \n        p.CreationDate >= TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '30 days'\n    GROUP BY \n        p.Id, p.Title\n    HAVING \n        COUNT(c.Id) > 5 AND SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) > SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END)\n)\nSELECT \n    ub.UserId,\n    ub.DisplayName,\n    ub.TotalBadges,\n    ub.GoldBadges,\n    ub.SilverBadges,\n    ub.BronzeBadges,\n    pp.PostId,\n    pp.Title,\n    pp.CommentCount,\n    pp.UpVoteCount,\n    pp.DownVoteCount\nFROM \n    UserBadges ub\nJOIN \n    Posts p ON p.OwnerUserId = ub.UserId\nJOIN \n    PopularPosts pp ON pp.PostId = p.Id\nORDER BY \n    ub.TotalBadges DESC, pp.UpVoteCount DESC\nFETCH FIRST 10 ROWS ONLY;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT p.Id AS PostId, p.Title, COUNT(c.Id) AS CommentCount, SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVoteCount, SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVoteCount FROM Posts p LEFT JOIN Comments c ON p.Id = c.PostId LEFT JOIN Votes v ON p.Id = v.PostId WHERE p.CreationDate >= TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '30 days' GROUP BY p.Id, p.Title HAVING COUNT(c.Id) > 5 AND SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) > SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END)", "sql2": "SELECT ub.UserId, ub.DisplayName, ub.TotalBadges, ub.GoldBadges, ub.SilverBadges, ub.BronzeBadges, s1.PostId, s1.Title, s1.CommentCount, s1.UpVoteCount, s1.DownVoteCount FROM (SELECT u.Id AS UserId, u.DisplayName, COUNT(b.Id) AS TotalBadges, SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges, SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges, SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges FROM Users u LEFT JOIN Badges b ON u.Id = b.UserId GROUP BY u.Id, u.DisplayName) ub JOIN Posts p ON p.OwnerUserId = ub.UserId JOIN s1 ON s1.PostId = p.Id ORDER BY ub.TotalBadges DESC, s1.UpVoteCount DESC LIMIT 10", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "29215.sql", "original_sql": "WITH UserBadgeStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(B.Id) AS BadgeCount,\n        SUM(CASE \n            WHEN B.Class = 1 THEN 1 \n            ELSE 0 \n        END) AS GoldBadges,\n        SUM(CASE \n            WHEN B.Class = 2 THEN 1 \n            ELSE 0 \n        END) AS SilverBadges,\n        SUM(CASE \n            WHEN B.Class = 3 THEN 1 \n            ELSE 0 \n        END) AS BronzeBadges\n    FROM Users U\n    LEFT JOIN Badges B ON U.Id = B.UserId\n    GROUP BY U.Id, U.DisplayName\n),\nPostInteractionStats AS (\n    SELECT \n        P.OwnerUserId,\n        COUNT(P.Id) AS TotalPosts,\n        COUNT(C.Id) AS TotalComments,\n        COUNT(DISTINCT V.Id) AS TotalVotes,\n        SUM(P.ViewCount) AS TotalViews,\n        SUM(P.Score) AS TotalScore\n    FROM Posts P\n    LEFT JOIN Comments C ON P.Id = C.PostId\n    LEFT JOIN Votes V ON P.Id = V.PostId\n    GROUP BY P.OwnerUserId\n),\nUserEngagement AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COALESCE(UBS.BadgeCount, 0) AS BadgeCount,\n        COALESCE(UBS.GoldBadges, 0) AS GoldBadges,\n        COALESCE(UBS.SilverBadges, 0) AS SilverBadges,\n        COALESCE(UBS.BronzeBadges, 0) AS BronzeBadges,\n        COALESCE(PIS.TotalPosts, 0) AS TotalPosts,\n        COALESCE(PIS.TotalComments, 0) AS TotalComments,\n        COALESCE(PIS.TotalVotes, 0) AS TotalVotes,\n        COALESCE(PIS.TotalViews, 0) AS TotalViews,\n        COALESCE(PIS.TotalScore, 0) AS TotalScore\n    FROM Users U\n    LEFT JOIN UserBadgeStats UBS ON U.Id = UBS.UserId\n    LEFT JOIN PostInteractionStats PIS ON U.Id = PIS.OwnerUserId\n)\nSELECT \n    UserId,\n    DisplayName,\n    BadgeCount,\n    GoldBadges,\n    SilverBadges,\n    BronzeBadges,\n    TotalPosts,\n    TotalComments,\n    TotalVotes,\n    TotalViews,\n    TotalScore,\n    (TotalScore * 1.0 / NULLIF(TotalPosts, 0)) AS ScorePerPost,\n    (TotalViews * 1.0 / NULLIF(TotalPosts, 0)) AS ViewsPerPost\nFROM UserEngagement\nORDER BY TotalScore DESC, BadgeCount DESC\nLIMIT 10;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH UserBadgeStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(B.Id) AS BadgeCount,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Users U\n    LEFT JOIN Badges B ON U.Id = B.UserId\n    GROUP BY U.Id, U.DisplayName\n),\nPostInteractionStats AS (\n    SELECT \n        P.OwnerUserId AS UserId,\n        COUNT(P.Id) AS TotalPosts,\n        COUNT(C.Id) AS TotalComments,\n        COUNT(DISTINCT V.Id) AS TotalVotes,\n        SUM(P.ViewCount) AS TotalViews,\n        SUM(P.Score) AS TotalScore\n    FROM Posts P\n    LEFT JOIN Comments C ON P.Id = C.PostId\n    LEFT JOIN Votes V ON P.Id = V.PostId\n    GROUP BY P.OwnerUserId\n)\nSELECT \n    U.Id AS UserId,\n    U.DisplayName,\n    COALESCE(UBS.BadgeCount,0) AS BadgeCount,\n    COALESCE(UBS.GoldBadges,0) AS GoldBadges,\n    COALESCE(UBS.SilverBadges,0) AS SilverBadges,\n    COALESCE(UBS.BronzeBadges,0) AS BronzeBadges,\n    COALESCE(PIS.TotalPosts,0) AS TotalPosts,\n    COALESCE(PIS.TotalComments,0) AS TotalComments,\n    COALESCE(PIS.TotalVotes,0) AS TotalVotes,\n    COALESCE(PIS.TotalViews,0) AS TotalViews,\n    COALESCE(PIS.TotalScore,0) AS TotalScore\nFROM Users U\nLEFT JOIN UserBadgeStats UBS ON U.Id = UBS.UserId\nLEFT JOIN PostInteractionStats PIS ON U.Id = PIS.UserId;", "sql2": "SELECT \n    UserId,\n    DisplayName,\n    BadgeCount,\n    GoldBadges,\n    SilverBadges,\n    BronzeBadges,\n    TotalPosts,\n    TotalComments,\n    TotalVotes,\n    TotalViews,\n    TotalScore,\n    (TotalScore * 1.0 / NULLIF(TotalPosts,0)) AS ScorePerPost,\n    (TotalViews * 1.0 / NULLIF(TotalPosts,0)) AS ViewsPerPost\nFROM s1\nORDER BY TotalScore DESC, BadgeCount DESC\nLIMIT 10;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "3067.sql", "original_sql": "\nWITH UserVoteSummary AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COALESCE(SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END), 0) AS TotalUpvotes,\n        COALESCE(SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END), 0) AS TotalDownvotes\n    FROM Users U\n    LEFT JOIN Votes V ON U.Id = V.UserId\n    GROUP BY U.Id, U.DisplayName\n),\nPostActivitySummary AS (\n    SELECT \n        P.Id AS PostId,\n        P.Title,\n        P.ViewCount,\n        COALESCE(PS.TotalAnswers, 0) AS TotalAnswers,\n        COALESCE(PS.TotalComments, 0) AS TotalComments\n    FROM Posts P\n    LEFT JOIN (\n        SELECT \n            A.ParentId,\n            COUNT(*) AS TotalAnswers,\n            COUNT(DISTINCT C.Id) AS TotalComments\n        FROM Posts A\n        LEFT JOIN Comments C ON A.Id = C.PostId\n        WHERE A.PostTypeId = 2\n        GROUP BY A.ParentId\n    ) PS ON P.Id = PS.ParentId\n    WHERE P.PostTypeId = 1\n),\nClosedPostSummary AS (\n    SELECT \n        PH.PostId,\n        COUNT(PH.Id) AS CloseCount,\n        MAX(PH.CreationDate) AS LastClosedDate\n    FROM PostHistory PH\n    WHERE PH.PostHistoryTypeId = 10\n    GROUP BY PH.PostId\n)\nSELECT \n    UPS.DisplayName AS UserName,\n    UPS.TotalUpvotes,\n    UPS.TotalDownvotes,\n    PAS.PostId,\n    PAS.Title AS PostTitle,\n    PAS.ViewCount,\n    PAS.TotalAnswers,\n    PAS.TotalComments,\n    CPS.CloseCount,\n    CPS.LastClosedDate\nFROM UserVoteSummary UPS\nINNER JOIN Posts P ON UPS.UserId = P.OwnerUserId\nINNER JOIN PostActivitySummary PAS ON P.Id = PAS.PostId\nLEFT JOIN ClosedPostSummary CPS ON PAS.PostId = CPS.PostId\nWHERE UPS.TotalUpvotes > UPS.TotalDownvotes\nORDER BY PAS.ViewCount DESC, UPS.TotalUpvotes DESC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column p.owneruserid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"posttypeid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"acceptedanswerid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"parentid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"creationdate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"score\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"viewcount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"body\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"owneruserid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"ownerdisplayname\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lasteditoruserid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lasteditordisplayname\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lasteditdate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lastactivitydate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"title\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"tags\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"answercount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"commentcount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"favoritecount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"closeddate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"communityowneddate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"contentlicense\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "30959.sql", "original_sql": "WITH RecursivePostHistory AS (\n    SELECT \n        ph.PostId,\n        ph.CreationDate,\n        ph.PostHistoryTypeId,\n        ROW_NUMBER() OVER (PARTITION BY ph.PostId ORDER BY ph.CreationDate DESC) AS RevisionNumber\n    FROM \n        PostHistory ph\n    WHERE \n        ph.PostHistoryTypeId IN (10, 11, 12) \n),\nUserReputation AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        SUM(u.Reputation) AS TotalReputation,\n        COUNT(b.Id) AS BadgeCount,\n        COUNT(DISTINCT ph.PostId) AS ClosedPosts\n    FROM \n        Users u\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN \n        RecursivePostHistory ph ON p.Id = ph.PostId\n    GROUP BY \n        u.Id, u.DisplayName\n),\nPostVoteStats AS (\n    SELECT\n        PostId,\n        SUM(CASE WHEN VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUpVotes,\n        SUM(CASE WHEN VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalDownVotes,\n        AVG(CASE WHEN VoteTypeId IN (2, 3) THEN VoteTypeId END) AS AvgVoteType\n    FROM \n        Votes\n    GROUP BY \n        PostId\n),\nCombinedStats AS (\n    SELECT \n        u.UserId,\n        u.DisplayName,\n        u.TotalReputation,\n        u.BadgeCount,\n        u.ClosedPosts,\n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate AS PostCreationDate,\n        COALESCE(v.TotalUpVotes, 0) AS PostUpVotes,\n        COALESCE(v.TotalDownVotes, 0) AS PostDownVotes,\n        COALESCE(v.AvgVoteType, 0) AS PostAvgVote\n    FROM \n        UserReputation u\n    JOIN \n        Posts p ON u.UserId = p.OwnerUserId\n    LEFT JOIN \n        PostVoteStats v ON p.Id = v.PostId\n    ORDER BY \n        u.TotalReputation DESC, p.CreationDate DESC\n)\nSELECT \n    cs.DisplayName AS UserDisplayName,\n    cs.TotalReputation,\n    cs.BadgeCount,\n    cs.ClosedPosts,\n    cs.Title AS PostTitle,\n    cs.PostCreationDate,\n    cs.PostUpVotes,\n    cs.PostDownVotes,\n    cs.PostAvgVote\nFROM \n    CombinedStats cs\nWHERE \n    cs.ClosedPosts > 0\nORDER BY \n    cs.TotalReputation DESC, cs.PostCreationDate DESC\nLIMIT 100;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH RecursivePostHistory AS (\n    SELECT \n        ph.PostId,\n        ph.CreationDate,\n        ph.PostHistoryTypeId,\n        ROW_NUMBER() OVER (PARTITION BY ph.PostId ORDER BY ph.CreationDate DESC) AS RevisionNumber\n    FROM \n        PostHistory ph\n    WHERE \n        ph.PostHistoryTypeId IN (10, 11, 12)\n),\nUserReputation AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        SUM(u.Reputation) AS TotalReputation,\n        COUNT(b.Id) AS BadgeCount,\n        COUNT(DISTINCT ph.PostId) AS ClosedPosts\n    FROM \n        Users u\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN \n        RecursivePostHistory ph ON p.Id = ph.PostId\n    GROUP BY \n        u.Id, u.DisplayName\n),\nPostVoteStats AS (\n    SELECT\n        PostId,\n        SUM(CASE WHEN VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUpVotes,\n        SUM(CASE WHEN VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalDownVotes,\n        AVG(CASE WHEN VoteTypeId IN (2, 3) THEN VoteTypeId END) AS AvgVoteType\n    FROM \n        Votes\n    GROUP BY \n        PostId\n)\nSELECT \n    u.UserId,\n    u.DisplayName,\n    u.TotalReputation,\n    u.BadgeCount,\n    u.ClosedPosts,\n    p.Id AS PostId,\n    p.Title,\n    p.CreationDate AS PostCreationDate,\n    COALESCE(v.TotalUpVotes, 0) AS PostUpVotes,\n    COALESCE(v.TotalDownVotes, 0) AS PostDownVotes,\n    COALESCE(v.AvgVoteType, 0) AS PostAvgVote\nFROM \n    UserReputation u\nJOIN \n    Posts p ON u.UserId = p.OwnerUserId\nLEFT JOIN \n    PostVoteStats v ON p.Id = v.PostId;", "sql2": "SELECT \n    DisplayName AS UserDisplayName,\n    TotalReputation,\n    BadgeCount,\n    ClosedPosts,\n    Title AS PostTitle,\n    PostCreationDate,\n    PostUpVotes,\n    PostDownVotes,\n    PostAvgVote\nFROM \n    s1\nWHERE \n    ClosedPosts > 0\nORDER BY \n    TotalReputation DESC,\n    PostCreationDate DESC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "3097.sql", "original_sql": "\nWITH RankedPosts AS (\n    SELECT \n        p.Id, \n        p.Title, \n        p.CreationDate, \n        p.Score, \n        p.ViewCount,\n        ROW_NUMBER() OVER (PARTITION BY p.OwnerUserId ORDER BY p.CreationDate DESC) AS PostRank,\n        p.OwnerUserId\n    FROM \n        Posts p\n    WHERE \n        p.CreationDate >= TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '1 year' \n        AND p.Score > 10\n),\nUserStatistics AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(DISTINCT p.Id) AS TotalPosts,\n        SUM(COALESCE(v.BountyAmount, 0)) AS TotalBounty,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId AND v.VoteTypeId = 8  \n    GROUP BY \n        u.Id, u.DisplayName\n)\nSELECT \n    us.UserId,\n    us.DisplayName,\n    us.TotalPosts,\n    us.TotalBounty,\n    us.GoldBadges,\n    us.SilverBadges,\n    us.BronzeBadges,\n    COUNT(rp.Id) AS RecentPostsCount,\n    AVG(rp.Score) AS AverageRecentPostScore\nFROM \n    UserStatistics us\nLEFT JOIN \n    RankedPosts rp ON us.UserId = rp.OwnerUserId\nGROUP BY \n    us.UserId, us.DisplayName, us.TotalPosts, us.TotalBounty, us.GoldBadges, us.SilverBadges, us.BronzeBadges\nHAVING \n    COUNT(rp.Id) > 5 \n    AND AVG(COALESCE(rp.Score, 0)) >= 20\nORDER BY \n    us.TotalBounty DESC, AverageRecentPostScore DESC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT \n    p.OwnerUserId AS UserId,\n    COUNT(*) AS RecentPostsCount,\n    AVG(p.Score) AS AverageRecentPostScore\nFROM Posts p\nWHERE p.CreationDate >= TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '1 year'\n  AND p.Score > 10\nGROUP BY p.OwnerUserId\nHAVING COUNT(*) > 5 AND AVG(p.Score) >= 20;", "sql2": "SELECT \n    us.UserId,\n    us.DisplayName,\n    us.TotalPosts,\n    us.TotalBounty,\n    us.GoldBadges,\n    us.SilverBadges,\n    us.BronzeBadges,\n    s1.RecentPostsCount,\n    s1.AverageRecentPostScore\nFROM (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(DISTINCT p.Id) AS TotalPosts,\n        SUM(COALESCE(v.BountyAmount,0)) AS TotalBounty,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Users u\n    LEFT JOIN Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN Badges b ON u.Id = b.UserId\n    LEFT JOIN Votes v ON p.Id = v.PostId AND v.VoteTypeId = 8\n    GROUP BY u.Id, u.DisplayName\n) us\nJOIN s1 ON us.UserId = s1.UserId\nORDER BY us.TotalBounty DESC, s1.AverageRecentPostScore DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "30992.sql", "original_sql": "\nWITH RECURSIVE UserBadgeCounts AS (\n    SELECT UserId, COUNT(*) AS BadgeCount\n    FROM Badges\n    GROUP BY UserId\n),\nPostVoteCounts AS (\n    SELECT PostId, \n           SUM(CASE WHEN VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n           SUM(CASE WHEN VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n           COUNT(*) AS TotalVotes\n    FROM Votes\n    GROUP BY PostId\n),\nRecentPosts AS (\n    SELECT p.Id AS PostId, \n           p.Title, \n           p.Score, \n           p.CreationDate,\n           COALESCE(v.UpVotes, 0) AS UpVotes,\n           COALESCE(v.DownVotes, 0) AS DownVotes,\n           COALESCE(bc.BadgeCount, 0) AS UserBadgeCount\n    FROM Posts p\n    LEFT JOIN PostVoteCounts v ON p.Id = v.PostId\n    LEFT JOIN Users u ON p.OwnerUserId = u.Id\n    LEFT JOIN UserBadgeCounts bc ON u.Id = bc.UserId\n    WHERE p.CreationDate >= TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '30 days'\n),\nCloseReasons AS (\n    SELECT ph.PostId, \n           MAX(ph.CreationDate) AS LastCloseDate, \n           STRING_AGG(cr.Name, ', ') AS CloseReasonNames\n    FROM PostHistory ph\n    JOIN CloseReasonTypes cr ON CAST(ph.Comment AS INTEGER) = cr.Id\n    WHERE ph.PostHistoryTypeId = 10\n    GROUP BY ph.PostId\n)\nSELECT rp.PostId, \n       rp.Title,\n       rp.Score, \n       rp.CreationDate, \n       rp.UpVotes, \n       rp.DownVotes, \n       rp.UserBadgeCount,\n       cr.LastCloseDate,\n       cr.CloseReasonNames,\n       CASE \n           WHEN cr.LastCloseDate IS NOT NULL THEN 'Closed'\n           ELSE 'Open'\n       END AS PostStatus\nFROM RecentPosts rp\nLEFT JOIN CloseReasons cr ON rp.PostId = cr.PostId\nORDER BY rp.Score DESC, rp.CreationDate DESC\nLIMIT 100;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "3112.sql", "original_sql": "\nWITH UserScore AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COALESCE(SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) - SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END), 0) AS NetVotes,\n        COALESCE(SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END), 0) AS GoldBadges,\n        COALESCE(SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END), 0) AS SilverBadges,\n        COALESCE(SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END), 0) AS BronzeBadges\n    FROM \n        Users u\n    LEFT JOIN \n        Votes v ON u.Id = v.UserId\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    GROUP BY \n        u.Id, u.DisplayName\n),\nPostEngagement AS (\n    SELECT \n        p.Id AS PostId,\n        p.OwnerUserId,\n        COUNT(c.Id) AS CommentCount,\n        COUNT(DISTINCT p2.Id) AS RelatedPosts\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        PostLinks pl ON p.Id = pl.PostId\n    LEFT JOIN \n        Posts p2 ON pl.RelatedPostId = p2.Id\n    WHERE \n        p.CreationDate >= (CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '30 days')\n    GROUP BY \n        p.Id, p.OwnerUserId\n)\nSELECT \n    us.UserId,\n    us.DisplayName,\n    us.NetVotes,\n    us.GoldBadges,\n    us.SilverBadges,\n    us.BronzeBadges,\n    COALESCE(pe.CommentCount, 0) AS CommentCount,\n    COALESCE(pe.RelatedPosts, 0) AS RelatedPosts\nFROM \n    UserScore us\nLEFT JOIN \n    PostEngagement pe ON us.UserId = pe.OwnerUserId\nWHERE \n    us.NetVotes > 10 \n    AND (us.GoldBadges > 0 OR us.SilverBadges > 2)\nORDER BY \n    us.NetVotes DESC, us.DisplayName ASC\nLIMIT 50;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    u.Id AS UserId,\n    u.DisplayName,\n    COALESCE(SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) - SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END), 0) AS NetVotes,\n    COALESCE(SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END), 0) AS GoldBadges,\n    COALESCE(SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END), 0) AS SilverBadges,\n    COALESCE(SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END), 0) AS BronzeBadges\nFROM Users u\nLEFT JOIN Votes v ON u.Id = v.UserId\nLEFT JOIN Badges b ON u.Id = b.UserId\nGROUP BY u.Id, u.DisplayName;", "sql2": "WITH PostEngagement AS (\n    SELECT \n        p.Id AS PostId,\n        p.OwnerUserId,\n        COUNT(c.Id) AS CommentCount,\n        COUNT(DISTINCT p2.Id) AS RelatedPosts\n    FROM Posts p\n    LEFT JOIN Comments c ON p.Id = c.PostId\n    LEFT JOIN PostLinks pl ON p.Id = pl.PostId\n    LEFT JOIN Posts p2 ON pl.RelatedPostId = p2.Id\n    WHERE p.CreationDate >= (CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '30 days')\n    GROUP BY p.Id, p.OwnerUserId\n)\nSELECT \n    s1.UserId,\n    s1.DisplayName,\n    s1.NetVotes,\n    s1.GoldBadges,\n    s1.SilverBadges,\n    s1.BronzeBadges,\n    COALESCE(pe.CommentCount, 0) AS CommentCount,\n    COALESCE(pe.RelatedPosts, 0) AS RelatedPosts\nFROM s1\nLEFT JOIN PostEngagement pe ON s1.UserId = pe.OwnerUserId\nWHERE s1.NetVotes > 10 \n  AND (s1.GoldBadges > 0 OR s1.SilverBadges > 2)\nORDER BY s1.NetVotes DESC, s1.DisplayName ASC\nLIMIT 50;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "31562.sql", "original_sql": "\nWITH RECURSIVE RecursivePosts AS (\n    SELECT \n        p.Id AS PostID,\n        p.Title,\n        p.OwnerUserId,\n        p.AcceptedAnswerId,\n        p.CreationDate,\n        p.Score,\n        p.ViewCount,\n        1 AS Level\n    FROM Posts p\n    WHERE p.PostTypeId = 1  \n\n    UNION ALL\n\n    SELECT \n        a.Id,\n        a.Title,\n        a.OwnerUserId,\n        a.AcceptedAnswerId,\n        a.CreationDate,\n        a.Score,\n        a.ViewCount,\n        rp.Level + 1\n    FROM Posts a\n    JOIN RecursivePosts rp ON a.ParentId = rp.PostID\n)\n\nSELECT \n    u.Id AS UserID,\n    u.DisplayName,\n    u.Reputation,\n    COUNT(DISTINCT p.Id) AS QuestionCount,\n    COUNT(DISTINCT a.Id) AS AnswerCount,\n    SUM(CASE WHEN a.AcceptedAnswerId IS NOT NULL THEN 1 ELSE 0 END) AS AcceptedAnswerCount,\n    SUM(COALESCE(COMMENT_COUNT.comment_count, 0)) AS TotalCommentCount,\n    SUM(COALESCE(VOTE_COUNT.upvote_count, 0)) AS TotalUpVotes,\n    SUM(COALESCE(VOTE_COUNT.downvote_count, 0)) AS TotalDownVotes\nFROM Users u\nLEFT JOIN Posts p ON u.Id = p.OwnerUserId AND p.PostTypeId = 1  \nLEFT JOIN Posts a ON p.Id = a.ParentId  \nLEFT JOIN (\n    SELECT \n        c.PostId,\n        COUNT(c.Id) AS comment_count\n    FROM Comments c\n    GROUP BY c.PostId\n) AS COMMENT_COUNT ON p.Id = COMMENT_COUNT.PostId\nLEFT JOIN (\n    SELECT \n        v.PostId,\n        SUM(CASE WHEN vt.Name = 'UpMod' THEN 1 ELSE 0 END) AS upvote_count,\n        SUM(CASE WHEN vt.Name = 'DownMod' THEN 1 ELSE 0 END) AS downvote_count\n    FROM Votes v\n    JOIN VoteTypes vt ON v.VoteTypeId = vt.Id\n    GROUP BY v.PostId\n) AS VOTE_COUNT ON p.Id = VOTE_COUNT.PostId\nWHERE u.Reputation > 1000  \nGROUP BY u.Id, u.DisplayName, u.Reputation\nHAVING COUNT(DISTINCT p.Id) > 0  \nORDER BY u.Reputation DESC\nLIMIT 10;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'postid' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column p.posttypeid\", span: None }, DiagnosticNote { message: \"possible column p.parentid\", span: None }, DiagnosticNote { message: \"possible column a.posttypeid\", span: None }, DiagnosticNote { message: \"possible column a.parentid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"postid\" }, valid_fields: [Column { relation: Some(Bare { table: \"u\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"reputation\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"creationdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"lastaccessdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"websiteurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"location\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"aboutme\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"views\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"upvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"downvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"profileimageurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"accountid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"posttypeid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"acceptedanswerid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"parentid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"creationdate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"score\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"viewcount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"body\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"owneruserid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"ownerdisplayname\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lasteditoruserid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lasteditordisplayname\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lasteditdate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"lastactivitydate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"title\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"tags\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"answercount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"commentcount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"favoritecount\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"closeddate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"communityowneddate\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"contentlicense\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"posttypeid\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"acceptedanswerid\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"parentid\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"creationdate\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"score\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"viewcount\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"body\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"owneruserid\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"ownerdisplayname\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"lasteditoruserid\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"lasteditordisplayname\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"lasteditdate\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"lastactivitydate\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"title\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"tags\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"answercount\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"commentcount\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"favoritecount\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"closeddate\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"communityowneddate\" }, Column { relation: Some(Bare { table: \"a\" }), name: \"contentlicense\" }, Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "31598.sql", "original_sql": "WITH RankedPosts AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        p.Score,\n        p.ViewCount,\n        p.OwnerUserId,\n        ROW_NUMBER() OVER (PARTITION BY p.OwnerUserId ORDER BY p.Score DESC) AS Rank\n    FROM \n        Posts p\n    WHERE \n        p.PostTypeId = 1 \n),\nTopUsers AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        SUM(p.Score) AS TotalScore,\n        COUNT(DISTINCT p.Id) AS TotalPosts,\n        COUNT(DISTINCT b.Id) AS TotalBadges,\n        AVG(COALESCE(p.ViewCount, 0)) AS AvgViewCount\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId \n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    GROUP BY \n        u.Id, u.DisplayName\n    HAVING \n        COUNT(DISTINCT p.Id) > 5 AND SUM(p.Score) IS NOT NULL\n),\nNextPostHistory AS (\n    SELECT \n        ph.PostId,\n        ph.UserId,\n        ph.CreationDate,\n        ph.Comment,\n        ph.Text,\n        ROW_NUMBER() OVER (PARTITION BY ph.PostId ORDER BY ph.CreationDate DESC) AS RevisionRank\n    FROM \n        PostHistory ph\n    WHERE \n        ph.PostHistoryTypeId IN (10, 11) \n),\nClosedPosts AS (\n    SELECT \n        p.Id AS PostId,\n        COUNT(nph.PostId) AS RevCount,\n        MAX(nph.CreationDate) AS LastRevision,\n        COUNT(DISTINCT ph.UserId) AS UserCount,\n        (SELECT COUNT(1) FROM Votes v WHERE v.PostId = p.Id AND v.VoteTypeId = 3) AS TotalDownVotes \n    FROM \n        Posts p\n    JOIN \n        NextPostHistory nph ON p.Id = nph.PostId\n    LEFT JOIN \n        PostHistory ph ON p.Id = ph.PostId\n    WHERE \n        p.ClosedDate IS NOT NULL \n    GROUP BY \n        p.Id\n),\nFinalReport AS (\n    SELECT \n        tu.UserId,\n        tu.DisplayName,\n        tu.TotalScore,\n        tu.TotalPosts,\n        cp.PostId,\n        cp.RevCount,\n        cp.UserCount,\n        cp.LastRevision,\n        cp.TotalDownVotes\n    FROM \n        TopUsers tu\n    JOIN \n        ClosedPosts cp ON tu.UserId = cp.PostId\n)\nSELECT \n    fr.UserId,\n    fr.DisplayName,\n    fr.TotalScore,\n    fr.TotalPosts,\n    fr.PostId,\n    fr.RevCount,\n    fr.UserCount,\n    fr.LastRevision,\n    fr.TotalDownVotes\nFROM \n    FinalReport fr\nORDER BY \n    fr.TotalScore DESC, fr.UserCount DESC;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 115, in _run_on_datafusion\n    return df.to_arrow_table()\n           ^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/dataframe.py\", line 1164, in to_arrow_table\n    return self.df.to_arrow_table()\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"pyarrow/table.pxi\", line 4767, in pyarrow.lib.Table.from_batches\n  File \"pyarrow/error.pxi\", line 154, in pyarrow.lib.pyarrow_internal_check_status\n  File \"pyarrow/error.pxi\", line 91, in pyarrow.lib.check_status\npyarrow.lib.ArrowInvalid: Schema at index 0 was different: \npostid: int32\nrevcount: int64 not null\nlastrevision: timestamp[us]\nusercount: int64 not null\ntotaldownvotes: int64 not null\nvs\npostid: int32\nrevcount: int64 not null\nlastrevision: timestamp[us]\nusercount: int64 not null\ntotaldownvotes: int64\n", "engine_mem_mb": 500000}
{"query_id": "31868.sql", "original_sql": "\nWITH RECURSIVE UserPostCount AS (\n    SELECT \n        U.Id AS UserId, \n        U.DisplayName, \n        COUNT(P.Id) AS PostCount\n    FROM Users U\n    LEFT JOIN Posts P ON U.Id = P.OwnerUserId\n    GROUP BY U.Id, U.DisplayName\n),\nTopUsers AS (\n    SELECT \n        UserId, \n        DisplayName, \n        PostCount,\n        RANK() OVER (ORDER BY PostCount DESC) AS UserRank\n    FROM UserPostCount\n    WHERE PostCount > 0\n),\nPostVoteDetails AS (\n    SELECT \n        P.Id AS PostId, \n        COUNT(V.Id) AS VoteCount, \n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM Posts P\n    LEFT JOIN Votes V ON P.Id = V.PostId\n    GROUP BY P.Id\n),\nUserBadges AS (\n    SELECT \n        U.Id AS UserId, \n        COUNT(B.Id) AS BadgeCount,\n        MAX(B.Class) AS HighestBadgeLevel\n    FROM Users U\n    LEFT JOIN Badges B ON U.Id = B.UserId\n    GROUP BY U.Id\n),\nFinalResults AS (\n    SELECT \n        U.UserId, \n        U.DisplayName, \n        U.PostCount, \n        PV.VoteCount, \n        PV.UpVotes, \n        PV.DownVotes, \n        UB.BadgeCount, \n        UB.HighestBadgeLevel\n    FROM TopUsers U\n    LEFT JOIN PostVoteDetails PV ON U.UserId = PV.PostId \n    LEFT JOIN UserBadges UB ON U.UserId = UB.UserId\n)\nSELECT \n    FR.UserId,\n    FR.DisplayName,\n    COALESCE(FR.PostCount, 0) AS TotalPosts,\n    COALESCE(FR.VoteCount, 0) AS TotalVotes,\n    COALESCE(FR.UpVotes, 0) AS TotalUpVotes,\n    COALESCE(FR.DownVotes, 0) AS TotalDownVotes,\n    COALESCE(FR.BadgeCount, 0) AS TotalBadges,\n    COALESCE(FR.HighestBadgeLevel, 0) AS HighestBadgeLevel,\n    CASE \n        WHEN FR.HighestBadgeLevel = 1 THEN 'Gold'\n        WHEN FR.HighestBadgeLevel = 2 THEN 'Silver'\n        WHEN FR.HighestBadgeLevel = 3 THEN 'Bronze'\n        ELSE 'No Badge'\n    END AS BadgeLevelDescription\nFROM FinalResults FR\nORDER BY TotalPosts DESC, TotalVotes DESC\nLIMIT 10;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "32360.sql", "original_sql": "\nWITH RecentPosts AS (\n    SELECT \n        p.Id AS PostId, \n        p.Title, \n        p.CreationDate, \n        p.Score, \n        p.ViewCount, \n        p.AnswerCount,\n        p.OwnerUserId,\n        ROW_NUMBER() OVER (PARTITION BY p.OwnerUserId ORDER BY p.CreationDate DESC) AS rn\n    FROM \n        Posts p\n    WHERE \n        p.CreationDate >= (CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '30 days')\n),\nUsersWithBadges AS (\n    SELECT \n        u.Id AS UserId, \n        u.DisplayName, \n        COUNT(DISTINCT b.Id) AS BadgeCount\n    FROM \n        Users u\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    GROUP BY \n        u.Id, u.DisplayName\n),\nPostHistorySummary AS (\n    SELECT \n        ph.PostId,\n        COUNT(CASE WHEN ph.PostHistoryTypeId IN (10, 11) THEN 1 END) AS CloseReopenCount,\n        COUNT(CASE WHEN ph.PostHistoryTypeId IN (12, 13) THEN 1 END) AS DeleteUndeleteCount,\n        MAX(ph.CreationDate) AS LastEdited\n    FROM \n        PostHistory ph\n    GROUP BY \n        ph.PostId\n),\nHighScoringPosts AS (\n    SELECT \n        rp.PostId, \n        rp.Title, \n        rp.Score, \n        rp.ViewCount, \n        rp.AnswerCount, \n        ub.BadgeCount\n    FROM \n        RecentPosts rp\n    JOIN \n        UsersWithBadges ub ON rp.OwnerUserId = ub.UserId\n    WHERE \n        rp.Score > 10\n        AND ub.BadgeCount > 5\n),\nFinalSummary AS (\n    SELECT \n        hsp.PostId, \n        hsp.Title, \n        hsp.Score, \n        hsp.ViewCount, \n        hsp.AnswerCount,\n        ph.CloseReopenCount,\n        ph.DeleteUndeleteCount,\n        ph.LastEdited\n    FROM \n        HighScoringPosts hsp\n    JOIN \n        PostHistorySummary ph ON hsp.PostId = ph.PostId\n)\nSELECT \n    fs.PostId,\n    fs.Title,\n    fs.Score,\n    fs.ViewCount,\n    fs.AnswerCount,\n    fs.CloseReopenCount,\n    fs.DeleteUndeleteCount,\n    fs.LastEdited,\n    CASE \n        WHEN fs.CloseReopenCount > 2 THEN 'Frequently Closed/Reopened'\n        ELSE 'Rarely Closed/Reopened'\n    END AS ClosureStatus\nFROM \n    FinalSummary fs\nORDER BY \n    fs.Score DESC, \n    fs.ViewCount DESC;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "WITH RecentPosts AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        p.Score,\n        p.ViewCount,\n        p.AnswerCount,\n        p.OwnerUserId,\n        ROW_NUMBER() OVER (PARTITION BY p.OwnerUserId ORDER BY p.CreationDate DESC) AS rn\n    FROM Posts p\n    WHERE p.CreationDate >= (CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '30' DAY)\n),\nUsersWithBadges AS (\n    SELECT \n        u.Id AS UserId,\n        COUNT(DISTINCT b.Id) AS BadgeCount\n    FROM Users u\n    LEFT JOIN Badges b ON u.Id = b.UserId\n    GROUP BY u.Id\n),\nHighScoringPosts AS (\n    SELECT \n        rp.PostId,\n        rp.Title,\n        rp.Score,\n        rp.ViewCount,\n        rp.AnswerCount\n    FROM RecentPosts rp\n    JOIN UsersWithBadges ub ON rp.OwnerUserId = ub.UserId\n    WHERE rp.Score > 10\n      AND ub.BadgeCount > 5\n)\nSELECT \n    PostId,\n    Title,\n    Score,\n    ViewCount,\n    AnswerCount\nFROM HighScoringPosts;", "sql2": "WITH PostHistorySummary AS (\n    SELECT \n        ph.PostId,\n        COUNT(CASE WHEN ph.PostHistoryTypeId IN (10, 11) THEN 1 END) AS CloseReopenCount,\n        COUNT(CASE WHEN ph.PostHistoryTypeId IN (12, 13) THEN 1 END) AS DeleteUndeleteCount,\n        MAX(ph.CreationDate) AS LastEdited\n    FROM PostHistory ph\n    GROUP BY ph.PostId\n),\nFinalSummary AS (\n    SELECT \n        s1.PostId,\n        s1.Title,\n        s1.Score,\n        s1.ViewCount,\n        s1.AnswerCount,\n        phs.CloseReopenCount,\n        phs.DeleteUndeleteCount,\n        phs.LastEdited\n    FROM s1\n    JOIN PostHistorySummary phs ON s1.PostId = phs.PostId\n)\nSELECT \n    PostId,\n    Title,\n    Score,\n    ViewCount,\n    AnswerCount,\n    CloseReopenCount,\n    DeleteUndeleteCount,\n    LastEdited,\n    CASE \n        WHEN CloseReopenCount > 2 THEN 'Frequently Closed/Reopened'\n        ELSE 'Rarely Closed/Reopened'\n    END AS ClosureStatus\nFROM FinalSummary\nORDER BY Score DESC, ViewCount DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "32550.sql", "original_sql": "WITH RECURSIVE UserPostStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(p.Id) AS TotalPosts,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers,\n        AVG(p.Score) AS AveragePostScore\n    FROM Users u\n    LEFT JOIN Posts p ON u.Id = p.OwnerUserId\n    GROUP BY u.Id, u.DisplayName\n),\nTopUsers AS (\n    SELECT \n        UserId,\n        DisplayName,\n        TotalPosts,\n        TotalQuestions,\n        TotalAnswers,\n        AveragePostScore,\n        RANK() OVER (ORDER BY TotalPosts DESC) AS PostRank\n    FROM UserPostStats\n    WHERE TotalPosts > 0\n),\nUserBadges AS (\n    SELECT \n        b.UserId,\n        COUNT(b.Id) AS TotalBadges,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Badges b\n    GROUP BY b.UserId\n),\nUserScores AS (\n    SELECT \n        t.UserId,\n        t.DisplayName,\n        t.TotalPosts,\n        t.TotalQuestions,\n        t.TotalAnswers,\n        t.AveragePostScore,\n        COALESCE(ub.TotalBadges, 0) AS TotalBadges,\n        COALESCE(ub.GoldBadges, 0) AS GoldBadges,\n        COALESCE(ub.SilverBadges, 0) AS SilverBadges,\n        COALESCE(ub.BronzeBadges, 0) AS BronzeBadges\n    FROM TopUsers t\n    LEFT JOIN UserBadges ub ON t.UserId = ub.UserId\n)\nSELECT \n    UserId,\n    DisplayName,\n    TotalPosts,\n    TotalQuestions,\n    TotalAnswers,\n    AveragePostScore,\n    TotalBadges,\n    GoldBadges,\n    SilverBadges,\n    BronzeBadges,\n    CASE \n        WHEN TotalPosts > 100 THEN 'High Activity' \n        WHEN TotalPosts BETWEEN 50 AND 100 THEN 'Moderate Activity' \n        ELSE 'Low Activity' \n    END AS ActivityLevel\nFROM UserScores\nWHERE TotalPosts > 0\nORDER BY TotalPosts DESC\nOFFSET 0 ROWS FETCH NEXT 10 ROWS ONLY;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Collection([Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'displayname' not found\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"displayname\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'totalposts' not found\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"totalposts\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'totalquestions' not found\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"totalquestions\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'totalanswers' not found\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"totalanswers\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'averagepostscore' not found\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"averagepostscore\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'totalbadges' not found\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"totalbadges\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'goldbadges' not found\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"goldbadges\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'silverbadges' not found\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"silverbadges\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'bronzebadges' not found\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"bronzebadges\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\"))), Diagnostic(Diagnostic { kind: Error, message: \"column 'totalposts' not found\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: None, name: \"totalposts\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\")))])\n", "engine_mem_mb": 500000}
{"query_id": "32768.sql", "original_sql": "WITH RecursivePostHistory AS (\n    SELECT \n        PH.PostId,\n        PH.PostHistoryTypeId,\n        PH.CreationDate,\n        CAST(NULL AS VARCHAR(400)) AS PreviousAction,\n        ROW_NUMBER() OVER (PARTITION BY PH.PostId ORDER BY PH.CreationDate DESC) AS RowNum\n    FROM \n        PostHistory PH\n    WHERE \n        PH.PostHistoryTypeId IN (10, 11, 12)  \n), \nUserActivity AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(P.Id) AS PostsCreated,\n        SUM(CASE WHEN P.Score IS NOT NULL THEN P.Score ELSE 0 END) AS TotalScore,\n        AVG(COALESCE(P.ViewCount, 0)) AS AvgViewCount\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    GROUP BY \n        U.Id, U.DisplayName\n), \nTagStats AS (\n    SELECT \n        T.TagName,\n        COUNT(P.Id) AS PostCount,\n        SUM(COALESCE(P.ViewCount, 0)) AS TotalViews\n    FROM \n        Tags T\n    LEFT JOIN \n        Posts P ON P.Tags LIKE '%' || T.TagName || '%'\n    GROUP BY \n        T.TagName\n)\nSELECT \n    U.DisplayName AS UserName,\n    U.PostsCreated,\n    U.TotalScore,\n    U.AvgViewCount,\n    P.Title AS PostTitle,\n    PH.PostHistoryTypeId,\n    PH.CreationDate AS ActionDate,\n    CASE \n        WHEN PH.PostHistoryTypeId = 10 THEN 'Closed'\n        WHEN PH.PostHistoryTypeId = 11 THEN 'Reopened'\n        WHEN PH.PostHistoryTypeId = 12 THEN 'Deleted'\n        ELSE 'Other Action'\n    END AS ActionType,\n    T.TagName AS PostTag,\n    TS.PostCount AS TagPostCount,\n    TS.TotalViews AS TagTotalViews\nFROM \n    UserActivity U\nINNER JOIN \n    RecursivePostHistory PH ON U.UserId = PH.PostId\nINNER JOIN \n    Posts P ON P.Id = PH.PostId\nLEFT JOIN \n    Tags T ON P.Tags LIKE '%' || T.TagName || '%'\nLEFT JOIN \n    TagStats TS ON T.TagName = TS.TagName\nWHERE \n    U.TotalScore > 0\nORDER BY \n    U.TotalScore DESC, PH.CreationDate DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT T.TagName,\n       COUNT(P.Id) AS PostCount,\n       SUM(COALESCE(P.ViewCount,0)) AS TotalViews\nFROM Tags T\nLEFT JOIN Posts P ON P.Tags LIKE '%' || T.TagName || '%'\nGROUP BY T.TagName;", "sql2": "WITH RecursivePostHistory AS (\n    SELECT \n        PH.PostId,\n        PH.PostHistoryTypeId,\n        PH.CreationDate,\n        CAST(NULL AS VARCHAR) AS PreviousAction,\n        ROW_NUMBER() OVER (PARTITION BY PH.PostId ORDER BY PH.CreationDate DESC) AS RowNum\n    FROM PostHistory PH\n    WHERE PH.PostHistoryTypeId IN (10, 11, 12)\n),\nUserActivity AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(P.Id) AS PostsCreated,\n        SUM(CASE WHEN P.Score IS NOT NULL THEN P.Score ELSE 0 END) AS TotalScore,\n        AVG(COALESCE(P.ViewCount,0)) AS AvgViewCount\n    FROM Users U\n    LEFT JOIN Posts P ON U.Id = P.OwnerUserId\n    GROUP BY U.Id, U.DisplayName\n)\nSELECT \n    U.DisplayName AS UserName,\n    U.PostsCreated,\n    U.TotalScore,\n    U.AvgViewCount,\n    P.Title AS PostTitle,\n    PH.PostHistoryTypeId,\n    PH.CreationDate AS ActionDate,\n    CASE \n        WHEN PH.PostHistoryTypeId = 10 THEN 'Closed'\n        WHEN PH.PostHistoryTypeId = 11 THEN 'Reopened'\n        WHEN PH.PostHistoryTypeId = 12 THEN 'Deleted'\n        ELSE 'Other Action'\n    END AS ActionType,\n    T.TagName AS PostTag,\n    s1.PostCount AS TagPostCount,\n    s1.TotalViews AS TagTotalViews\nFROM UserActivity U\nINNER JOIN RecursivePostHistory PH ON U.UserId = PH.PostId\nINNER JOIN Posts P ON P.Id = PH.PostId\nLEFT JOIN Tags T ON P.Tags LIKE '%' || T.TagName || '%'\nLEFT JOIN s1 ON T.TagName = s1.TagName\nWHERE U.TotalScore > 0\nORDER BY U.TotalScore DESC, PH.CreationDate DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "3453.sql", "original_sql": "WITH UserBadgeCounts AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(B.Id) AS BadgeCount,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Users U\n    LEFT JOIN \n        Badges B ON U.Id = B.UserId\n    GROUP BY \n        U.Id, U.DisplayName\n),\nPostStats AS (\n    SELECT \n        P.OwnerUserId,\n        COUNT(P.Id) AS TotalPosts,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS Answers,\n        AVG(P.Score) AS AvgScore,\n        SUM(P.ViewCount) AS TotalViews\n    FROM \n        Posts P\n    GROUP BY \n        P.OwnerUserId\n),\nTopUsers AS (\n    SELECT \n        U.Id,\n        U.DisplayName,\n        COALESCE(UB.BadgeCount, 0) AS BadgeCount,\n        PU.TotalPosts,\n        PU.Questions,\n        PU.Answers,\n        PU.AvgScore,\n        PU.TotalViews\n    FROM \n        Users U\n    LEFT JOIN \n        UserBadgeCounts UB ON U.Id = UB.UserId\n    LEFT JOIN \n        PostStats PU ON U.Id = PU.OwnerUserId\n    WHERE \n        U.Reputation > 1000\n)\nSELECT \n    T.DisplayName,\n    T.TotalPosts,\n    T.Questions,\n    T.Answers,\n    T.BadgeCount,\n    T.AvgScore,\n    T.TotalViews\nFROM \n    TopUsers T\nORDER BY \n    T.BadgeCount DESC, T.TotalPosts DESC\nLIMIT 10;", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "WITH UserBadgeCounts AS (\n    SELECT \n        U.Id AS UserId,\n        COUNT(B.Id) AS BadgeCount,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Users U\n    LEFT JOIN Badges B ON U.Id = B.UserId\n    GROUP BY U.Id\n),\nPostStats AS (\n    SELECT \n        P.OwnerUserId,\n        COUNT(P.Id) AS TotalPosts,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS Answers,\n        AVG(P.Score) AS AvgScore,\n        SUM(P.ViewCount) AS TotalViews\n    FROM Posts P\n    GROUP BY P.OwnerUserId\n),\nTopUsers AS (\n    SELECT \n        U.Id,\n        U.DisplayName,\n        COALESCE(UB.BadgeCount, 0) AS BadgeCount,\n        PU.TotalPosts,\n        PU.Questions,\n        PU.Answers,\n        PU.AvgScore,\n        PU.TotalViews\n    FROM Users U\n    LEFT JOIN UserBadgeCounts UB ON U.Id = UB.UserId\n    LEFT JOIN PostStats PU ON U.Id = PU.OwnerUserId\n    WHERE U.Reputation > 1000\n)\nSELECT \n    Id,\n    DisplayName,\n    BadgeCount,\n    TotalPosts,\n    Questions,\n    Answers,\n    AvgScore,\n    TotalViews\nFROM TopUsers;", "sql2": "SELECT \n    DisplayName,\n    TotalPosts,\n    Questions,\n    Answers,\n    BadgeCount,\n    AvgScore,\n    TotalViews\nFROM s1\nORDER BY BadgeCount DESC, TotalPosts DESC\nLIMIT 10;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "3562.sql", "original_sql": "\nWITH RankedPosts AS (\n    SELECT \n        p.Id,\n        p.Title,\n        p.CreationDate,\n        p.Score,\n        p.ViewCount,\n        p.OwnerUserId,\n        RANK() OVER (PARTITION BY p.PostTypeId ORDER BY p.Score DESC) AS ScoreRank\n    FROM \n        Posts p\n    WHERE \n        p.CreationDate >= TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '1 year'\n), \nUserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        u.Reputation,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpvotesReceived,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownvotesReceived\n    FROM \n        Users u\n    LEFT JOIN \n        Votes v ON u.Id = v.UserId\n    GROUP BY \n        u.Id, u.DisplayName, u.Reputation\n), \nClosedPosts AS (\n    SELECT \n        ph.PostId,\n        COUNT(*) AS CloseCount\n    FROM \n        PostHistory ph\n    WHERE \n        ph.PostHistoryTypeId = 10\n    GROUP BY \n        ph.PostId\n), \nPostDetails AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.Score,\n        COALESCE(cp.CloseCount, 0) AS TotalCloseCount,\n        us.DisplayName AS OwnerDisplayName,\n        us.Reputation AS OwnerReputation,\n        CASE \n            WHEN p.OwnerUserId IS NULL THEN 'Deleted User'\n            ELSE us.DisplayName \n        END AS EffectiveOwner\n    FROM \n        Posts p\n    LEFT JOIN \n        UserStats us ON p.OwnerUserId = us.UserId\n    LEFT JOIN \n        ClosedPosts cp ON p.Id = cp.PostId\n    WHERE \n        p.PostTypeId = 1 AND p.Score > 10\n)\n\nSELECT \n    pd.PostId,\n    pd.Title,\n    pd.Score,\n    pd.TotalCloseCount,\n    pd.OwnerDisplayName,\n    pd.OwnerReputation,\n    pd.EffectiveOwner\nFROM \n    PostDetails pd\nWHERE \n    pd.TotalCloseCount = 0\nORDER BY \n    pd.Score DESC, \n    pd.Title ASC;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "3878.sql", "original_sql": "WITH UserReputation AS (\n    SELECT Id, DisplayName, Reputation, \n           ROW_NUMBER() OVER (ORDER BY Reputation DESC) AS Ranking \n    FROM Users\n),\nPostStatistics AS (\n    SELECT OwnerUserId, COUNT(CASE WHEN PostTypeId = 1 THEN 1 END) AS QuestionCount,\n           COUNT(CASE WHEN PostTypeId = 2 THEN 1 END) AS AnswerCount,\n           SUM(ViewCount) AS TotalViews,\n           SUM(Score) AS TotalScore\n    FROM Posts\n    GROUP BY OwnerUserId\n),\nRecentPosts AS (\n    SELECT p.Id, p.Title, p.CreationDate,\n           CASE WHEN p.ClosedDate IS NOT NULL THEN 'Closed' ELSE 'Open' END AS PostStatus\n    FROM Posts p\n    WHERE p.CreationDate > cast('2024-10-01 12:34:56' as timestamp) - INTERVAL '30 days'\n),\nHighlyActiveUsers AS (\n    SELECT u.Id, u.DisplayName, u.Reputation\n    FROM UserReputation u\n    JOIN PostStatistics ps ON u.Id = ps.OwnerUserId\n    WHERE ps.QuestionCount + ps.AnswerCount > 10\n),\nClosedPostReasons AS (\n    SELECT ph.PostId, ph.Comment AS CloseReason, \n           ph.CreationDate AS CloseDate, \n           u.DisplayName AS ClosedBy\n    FROM PostHistory ph\n    JOIN Users u ON ph.UserId = u.Id\n    WHERE ph.PostHistoryTypeId = 10\n)\nSELECT u.DisplayName AS UserName, \n       ps.QuestionCount, \n       ps.AnswerCount, \n       ps.TotalViews,\n       ps.TotalScore,\n       rp.Title AS RecentPostTitle,\n       rp.PostStatus,\n       CPR.CloseReason,\n       CPR.CloseDate,\n       CPR.ClosedBy\nFROM HighlyActiveUsers u\nLEFT JOIN PostStatistics ps ON u.Id = ps.OwnerUserId\nLEFT JOIN RecentPosts rp ON ps.OwnerUserId = rp.Id\nLEFT JOIN ClosedPostReasons CPR ON CPR.PostId = rp.Id\nWHERE ps.TotalViews > 1000\nORDER BY ps.TotalScore DESC, ps.TotalViews DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH UserReputation AS (\n    SELECT Id, DisplayName, Reputation,\n           ROW_NUMBER() OVER (ORDER BY Reputation DESC) AS Ranking\n    FROM Users\n),\nPostStatistics AS (\n    SELECT OwnerUserId,\n           COUNT(CASE WHEN PostTypeId = 1 THEN 1 END) AS QuestionCount,\n           COUNT(CASE WHEN PostTypeId = 2 THEN 1 END) AS AnswerCount,\n           SUM(ViewCount) AS TotalViews,\n           SUM(Score) AS TotalScore\n    FROM Posts\n    GROUP BY OwnerUserId\n),\nHighlyActiveUsers AS (\n    SELECT u.Id,\n           u.DisplayName,\n           u.Reputation,\n           ps.QuestionCount,\n           ps.AnswerCount,\n           ps.TotalViews,\n           ps.TotalScore\n    FROM UserReputation u\n    JOIN PostStatistics ps ON u.Id = ps.OwnerUserId\n    WHERE ps.QuestionCount + ps.AnswerCount > 10\n)\nSELECT Id,\n       DisplayName,\n       Reputation,\n       QuestionCount,\n       AnswerCount,\n       TotalViews,\n       TotalScore\nFROM HighlyActiveUsers;", "sql2": "WITH RecentPosts AS (\n    SELECT p.Id,\n           p.Title,\n           p.CreationDate,\n           CASE WHEN p.ClosedDate IS NOT NULL THEN 'Closed' ELSE 'Open' END AS PostStatus,\n           p.OwnerUserId\n    FROM Posts p\n    WHERE p.CreationDate > CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '30' DAY\n),\nClosedPostReasons AS (\n    SELECT ph.PostId,\n           ph.Comment AS CloseReason,\n           ph.CreationDate AS CloseDate,\n           u.DisplayName AS ClosedBy\n    FROM PostHistory ph\n    JOIN Users u ON ph.UserId = u.Id\n    WHERE ph.PostHistoryTypeId = 10\n)\nSELECT s1.DisplayName AS UserName,\n       s1.QuestionCount,\n       s1.AnswerCount,\n       s1.TotalViews,\n       s1.TotalScore,\n       rp.Title AS RecentPostTitle,\n       rp.PostStatus,\n       cpr.CloseReason,\n       cpr.CloseDate,\n       cpr.ClosedBy\nFROM s1\nLEFT JOIN RecentPosts rp ON s1.Id = rp.Id\nLEFT JOIN ClosedPostReasons cpr ON cpr.PostId = rp.Id\nWHERE s1.TotalViews > 1000\nORDER BY s1.TotalScore DESC, s1.TotalViews DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "3914.sql", "original_sql": "WITH UserReputation AS (\n    SELECT Id, DisplayName, Reputation, \n           ROW_NUMBER() OVER (ORDER BY Reputation DESC) AS ReputationRank\n    FROM Users\n),\nPostStats AS (\n    SELECT OwnerUserId, COUNT(*) AS PostCount, SUM(ViewCount) AS TotalViews, \n           AVG(Score) AS AverageScore\n    FROM Posts\n    WHERE CreationDate >= cast('2024-10-01 12:34:56' as timestamp) - INTERVAL '1 year'\n    GROUP BY OwnerUserId\n),\nTopUsers AS (\n    SELECT ur.DisplayName, ur.Reputation, ps.PostCount, ps.TotalViews, ps.AverageScore\n    FROM UserReputation ur\n    JOIN PostStats ps ON ur.Id = ps.OwnerUserId\n    WHERE ur.Reputation > 1000\n),\nClosedPosts AS (\n    SELECT p.Id AS PostId, p.Title, ph.UserDisplayName, ph.CreationDate AS CloseDate\n    FROM Posts p\n    JOIN PostHistory ph ON p.Id = ph.PostId\n    WHERE ph.PostHistoryTypeId = 10\n)\nSELECT tu.DisplayName, tu.Reputation, \n       COALESCE(COUNT(cp.PostId), 0) AS ClosedPostCount,\n       SUM(CASE WHEN cp.CloseDate >= cast('2024-10-01 12:34:56' as timestamp) - INTERVAL '1 month' THEN 1 ELSE 0 END) AS RecentClosedPosts,\n       STRING_AGG(DISTINCT cp.Title, ', ') AS ClosedPostTitles\nFROM TopUsers tu\nLEFT JOIN ClosedPosts cp ON tu.DisplayName = cp.UserDisplayName\nGROUP BY tu.DisplayName, tu.Reputation\nORDER BY tu.Reputation DESC\nLIMIT 10;", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT p.Id AS PostId,\n       p.Title,\n       ph.UserDisplayName,\n       ph.CreationDate AS CloseDate\nFROM Posts p\nJOIN PostHistory ph ON p.Id = ph.PostId\nWHERE ph.PostHistoryTypeId = 10;", "sql2": "WITH UserReputation AS (\n    SELECT Id, DisplayName, Reputation,\n           ROW_NUMBER() OVER (ORDER BY Reputation DESC) AS ReputationRank\n    FROM Users\n),\nPostStats AS (\n    SELECT OwnerUserId,\n           COUNT(*) AS PostCount,\n           SUM(ViewCount) AS TotalViews,\n           AVG(Score) AS AverageScore\n    FROM Posts\n    WHERE CreationDate >= CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '1 year'\n    GROUP BY OwnerUserId\n),\nTopUsers AS (\n    SELECT ur.DisplayName,\n           ur.Reputation,\n           ps.PostCount,\n           ps.TotalViews,\n           ps.AverageScore\n    FROM UserReputation ur\n    JOIN PostStats ps ON ur.Id = ps.OwnerUserId\n    WHERE ur.Reputation > 1000\n)\nSELECT tu.DisplayName,\n       tu.Reputation,\n       COALESCE(COUNT(cp.PostId), 0) AS ClosedPostCount,\n       SUM(CASE WHEN cp.CloseDate >= CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '1 month' THEN 1 ELSE 0 END) AS RecentClosedPosts,\n       STRING_AGG(DISTINCT cp.Title, ', ') AS ClosedPostTitles\nFROM TopUsers tu\nLEFT JOIN s1 cp ON tu.DisplayName = cp.UserDisplayName\nGROUP BY tu.DisplayName, tu.Reputation\nORDER BY tu.Reputation DESC\nLIMIT 10;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "3922.sql", "original_sql": "\nWITH UserBadges AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Users U\n    LEFT JOIN \n        Badges B ON U.Id = B.UserId\n    GROUP BY \n        U.Id, U.DisplayName\n),\nPostStats AS (\n    SELECT \n        P.OwnerUserId,\n        COUNT(P.Id) AS PostCount,\n        SUM(P.ViewCount) AS TotalViews,\n        AVG(P.Score) AS AverageScore\n    FROM \n        Posts P\n    WHERE \n        P.CreationDate >= TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '1 year'\n    GROUP BY \n        P.OwnerUserId\n),\nUserPostStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COALESCE(UB.PostCount, 0) AS PostCount,\n        COALESCE(UB.TotalViews, 0) AS TotalViews,\n        COALESCE(UB.AverageScore, 0) AS AverageScore,\n        COALESCE(B.GoldBadges, 0) AS GoldBadges,\n        COALESCE(B.SilverBadges, 0) AS SilverBadges,\n        COALESCE(B.BronzeBadges, 0) AS BronzeBadges\n    FROM \n        Users U\n    LEFT JOIN \n        PostStats UB ON U.Id = UB.OwnerUserId\n    LEFT JOIN \n        UserBadges B ON U.Id = B.UserId\n)\nSELECT \n    UserId,\n    DisplayName,\n    PostCount,\n    TotalViews,\n    AverageScore,\n    GoldBadges,\n    SilverBadges,\n    BronzeBadges,\n    CASE \n        WHEN PostCount > 50 THEN 'Highly Active'\n        WHEN PostCount BETWEEN 21 AND 50 THEN 'Moderately Active'\n        ELSE 'Less Active'\n    END AS ActivityLevel\nFROM \n    UserPostStats\nWHERE \n    TotalViews > 1000\nORDER BY \n    TotalViews DESC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: SchemaError(AmbiguousReference { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"totalviews\" } }, Some(\"\"))\n", "engine_mem_mb": 500000}
{"query_id": "4587.sql", "original_sql": "\nWITH UserReputation AS (\n    SELECT Id, DisplayName, Reputation, \n           ROW_NUMBER() OVER (ORDER BY Reputation DESC) AS Rank\n    FROM Users\n), RecentPosts AS (\n    SELECT p.Id AS PostId, p.Title, p.CreationDate, p.OwnerUserId, \n           COALESCE(COUNT(c.Id), 0) AS CommentCount, \n           COALESCE(SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END), 0) AS UpvoteCount, \n           COALESCE(SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END), 0) AS DownvoteCount\n    FROM Posts p\n    LEFT JOIN Comments c ON p.Id = c.PostId\n    LEFT JOIN Votes v ON p.Id = v.PostId\n    WHERE p.CreationDate >= CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '30 days'\n    GROUP BY p.Id, p.Title, p.CreationDate, p.OwnerUserId\n), AcceptedAnswers AS (\n    SELECT p.Id AS AnswerId, p.AcceptedAnswerId, \n           COALESCE(SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END), 0) AS TotalUpvotes\n    FROM Posts p\n    LEFT JOIN Votes v ON p.Id = v.PostId\n    WHERE p.PostTypeId = 2\n    GROUP BY p.Id, p.AcceptedAnswerId\n), PostLinksSummary AS (\n    SELECT pl.PostId, \n           COUNT(DISTINCT pl.RelatedPostId) AS RelatedPostCount,\n           SUM(CASE WHEN lt.Name = 'Duplicate' THEN 1 ELSE 0 END) AS DuplicateCount\n    FROM PostLinks pl\n    JOIN LinkTypes lt ON pl.LinkTypeId = lt.Id\n    GROUP BY pl.PostId\n)\nSELECT u.DisplayName, \n       u.Reputation, \n       rp.Title, \n       rp.CreationDate, \n       rp.CommentCount, \n       rp.UpvoteCount, \n       rp.DownvoteCount, \n       aa.TotalUpvotes AS AcceptedAnswerUpvotes,\n       pls.RelatedPostCount,\n       pls.DuplicateCount\nFROM UserReputation u\nJOIN RecentPosts rp ON u.Id = rp.OwnerUserId\nLEFT JOIN AcceptedAnswers aa ON aa.AcceptedAnswerId = rp.PostId\nLEFT JOIN PostLinksSummary pls ON pls.PostId = rp.PostId\nWHERE u.Reputation > 1000 AND \n      (rp.UpvoteCount - rp.DownvoteCount) > 10\nORDER BY u.Reputation DESC, rp.CreationDate DESC\nOFFSET 0 ROWS FETCH NEXT 10 ROWS ONLY;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 178, in _run_single_node\n    out_tbl = self._run_on_duckdb(node.sql)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 104, in _run_on_duckdb\n    return self.con.execute(sql).arrow()\n           ^^^^^^^^^^^^^^^^^^^^^\nduckdb.duckdb.Error: ArrowNotImplementedError: Function 'and_kleene' has no kernel matching input types (bool, null)\n\nAt:\n  pyarrow/error.pxi(91): pyarrow.lib.check_status\n\n", "engine_mem_mb": 500000}
{"query_id": "5267.sql", "original_sql": "WITH UserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        u.Reputation,\n        COUNT(DISTINCT p.Id) AS TotalPosts,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers,\n        SUM(CASE WHEN p.PostTypeId = 1 AND p.AcceptedAnswerId IS NOT NULL THEN 1 ELSE 0 END) AS AcceptedAnswers\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    GROUP BY \n        u.Id, u.DisplayName, u.Reputation\n),\nBadgesSummary AS (\n    SELECT \n        b.UserId,\n        COUNT(CASE WHEN b.Class = 1 THEN 1 END) AS GoldBadges,\n        COUNT(CASE WHEN b.Class = 2 THEN 1 END) AS SilverBadges,\n        COUNT(CASE WHEN b.Class = 3 THEN 1 END) AS BronzeBadges\n    FROM \n        Badges b\n    GROUP BY \n        b.UserId\n),\nPostHistorySummary AS (\n    SELECT \n        ph.UserId,\n        COUNT(*) AS TotalEdits,\n        MAX(ph.CreationDate) AS LastEditDate\n    FROM \n        PostHistory ph\n    GROUP BY \n        ph.UserId\n)\nSELECT \n    us.UserId,\n    us.DisplayName,\n    us.Reputation,\n    us.TotalPosts,\n    us.TotalQuestions,\n    us.TotalAnswers,\n    us.AcceptedAnswers,\n    bs.GoldBadges,\n    bs.SilverBadges,\n    bs.BronzeBadges,\n    phs.TotalEdits,\n    phs.LastEditDate\nFROM \n    UserStats us\nLEFT JOIN \n    BadgesSummary bs ON us.UserId = bs.UserId\nLEFT JOIN \n    PostHistorySummary phs ON us.UserId = phs.UserId\nWHERE \n    us.Reputation > 100\nORDER BY \n    us.Reputation DESC, us.TotalPosts DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "WITH BadgesSummary AS ( SELECT UserId, COUNT(CASE WHEN Class = 1 THEN 1 END) AS GoldBadges, COUNT(CASE WHEN Class = 2 THEN 1 END) AS SilverBadges, COUNT(CASE WHEN Class = 3 THEN 1 END) AS BronzeBadges FROM Badges GROUP BY UserId ), PostHistorySummary AS ( SELECT UserId, COUNT(*) AS TotalEdits, MAX(CreationDate) AS LastEditDate FROM PostHistory GROUP BY UserId ) SELECT COALESCE(b.UserId, p.UserId) AS UserId, b.GoldBadges, b.SilverBadges, b.BronzeBadges, p.TotalEdits, p.LastEditDate FROM BadgesSummary b FULL OUTER JOIN PostHistorySummary p USING (UserId);", "sql2": "WITH UserStats AS ( SELECT u.Id AS UserId, u.DisplayName, u.Reputation, COUNT(DISTINCT p.Id) AS TotalPosts, SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions, SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers, SUM(CASE WHEN p.PostTypeId = 1 AND p.AcceptedAnswerId IS NOT NULL THEN 1 ELSE 0 END) AS AcceptedAnswers FROM Users u LEFT JOIN Posts p ON u.Id = p.OwnerUserId GROUP BY u.Id, u.DisplayName, u.Reputation ) SELECT us.UserId, us.DisplayName, us.Reputation, us.TotalPosts, us.TotalQuestions, us.TotalAnswers, us.AcceptedAnswers, s1.GoldBadges, s1.SilverBadges, s1.BronzeBadges, s1.TotalEdits, s1.LastEditDate FROM UserStats us LEFT JOIN s1 ON us.UserId = s1.UserId WHERE us.Reputation > 100 ORDER BY us.Reputation DESC, us.TotalPosts DESC LIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "5314.sql", "original_sql": "WITH UserActivity AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(P.Id) AS PostCount,\n        SUM(CASE WHEN P.Score > 0 THEN 1 ELSE 0 END) AS PositiveScorePosts,\n        SUM(CASE WHEN P.Score < 0 THEN 1 ELSE 0 END) AS NegativeScorePosts,\n        SUM(COALESCE(V.BountyAmount, 0)) AS TotalBounty\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    LEFT JOIN \n        Votes V ON P.Id = V.PostId AND V.VoteTypeId IN (8, 9) \n    WHERE \n        U.Reputation > 1000\n    GROUP BY \n        U.Id, U.DisplayName\n),\nPostEngagement AS (\n    SELECT \n        P.Id AS PostId,\n        P.Title,\n        COUNT(C.Id) AS CommentCount,\n        SUM(CASE WHEN P.ViewCount > 100 THEN 1 ELSE 0 END) AS HighViewCount,\n        MAX(P.CreationDate) AS LastActivity\n    FROM \n        Posts P\n    LEFT JOIN \n        Comments C ON P.Id = C.PostId\n    WHERE \n        P.CreationDate >= cast('2024-10-01 12:34:56' as timestamp) - INTERVAL '1 year'\n    GROUP BY \n        P.Id, P.Title\n)\nSELECT \n    UA.DisplayName,\n    UA.PostCount,\n    UA.PositiveScorePosts,\n    UA.NegativeScorePosts,\n    UA.TotalBounty,\n    PE.Title,\n    PE.CommentCount,\n    PE.HighViewCount,\n    PE.LastActivity\nFROM \n    UserActivity UA\nJOIN \n    PostEngagement PE ON UA.UserId = PE.PostId\nORDER BY \n    UA.TotalBounty DESC, UA.PostCount DESC\nLIMIT 50;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 'ua'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"ua\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"ua\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"pe\" }), name: \"postid\" }, Column { relation: Some(Bare { table: \"pe\" }), name: \"title\" }, Column { relation: Some(Bare { table: \"pe\" }), name: \"commentcount\" }, Column { relation: Some(Bare { table: \"pe\" }), name: \"highviewcount\" }, Column { relation: Some(Bare { table: \"pe\" }), name: \"lastactivity\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "5315.sql", "original_sql": "\nWITH RecentPosts AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.Score,\n        p.CreationDate,\n        p.OwnerUserId,\n        p.AnswerCount,\n        p.CommentCount,\n        COUNT(CASE WHEN v.VoteTypeId = 2 THEN 1 END) AS UpVotes,\n        COUNT(CASE WHEN v.VoteTypeId = 3 THEN 1 END) AS DownVotes\n    FROM \n        Posts p\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    WHERE \n        p.CreationDate > (CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '30 days')\n    GROUP BY \n        p.Id, p.Title, p.Score, p.CreationDate, p.OwnerUserId, p.AnswerCount, p.CommentCount\n),\nTopUsers AS (\n    SELECT \n        u.Id,\n        u.DisplayName,\n        SUM(COALESCE(b.Class, 0)) AS TotalBadges,\n        COUNT(DISTINCT p.Id) AS TotalPosts\n    FROM \n        Users u\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    GROUP BY \n        u.Id, u.DisplayName\n    ORDER BY \n        TotalPosts DESC, TotalBadges DESC\n    LIMIT 10\n),\nPostInteraction AS (\n    SELECT \n        rp.PostId,\n        rp.Title,\n        rp.Score,\n        rp.CreationDate,\n        u.DisplayName AS OwnerDisplayName,\n        rp.UpVotes,\n        rp.DownVotes,\n        tu.TotalBadges,\n        tu.TotalPosts\n    FROM \n        RecentPosts rp\n    JOIN \n        Users u ON rp.OwnerUserId = u.Id\n    JOIN \n        TopUsers tu ON u.Id = tu.Id\n)\nSELECT \n    pi.Title,\n    pi.CreationDate,\n    pi.OwnerDisplayName,\n    pi.Score,\n    pi.UpVotes,\n    pi.DownVotes,\n    pi.TotalBadges,\n    pi.TotalPosts\nFROM \n    PostInteraction pi\nORDER BY \n    pi.Score DESC, pi.UpVotes DESC, pi.DownVotes ASC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    p.Id AS PostId,\n    p.Title,\n    p.Score,\n    p.CreationDate,\n    p.OwnerUserId,\n    p.AnswerCount,\n    p.CommentCount,\n    COUNT(CASE WHEN v.VoteTypeId = 2 THEN 1 END) AS UpVotes,\n    COUNT(CASE WHEN v.VoteTypeId = 3 THEN 1 END) AS DownVotes\nFROM Posts p\nLEFT JOIN Votes v ON p.Id = v.PostId\nWHERE p.CreationDate > (CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '30 days')\nGROUP BY p.Id, p.Title, p.Score, p.CreationDate, p.OwnerUserId, p.AnswerCount, p.CommentCount;", "sql2": "WITH TopUsers AS (\n    SELECT \n        u.Id,\n        u.DisplayName,\n        SUM(COALESCE(b.Class, 0)) AS TotalBadges,\n        COUNT(DISTINCT p.Id) AS TotalPosts\n    FROM Users u\n    LEFT JOIN Badges b ON u.Id = b.UserId\n    LEFT JOIN Posts p ON u.Id = p.OwnerUserId\n    GROUP BY u.Id, u.DisplayName\n    ORDER BY TotalPosts DESC, TotalBadges DESC\n    LIMIT 10\n)\nSELECT \n    s1.Title,\n    s1.CreationDate,\n    u.DisplayName AS OwnerDisplayName,\n    s1.Score,\n    s1.UpVotes,\n    s1.DownVotes,\n    tu.TotalBadges,\n    tu.TotalPosts\nFROM s1\nJOIN Users u ON s1.OwnerUserId = u.Id\nJOIN TopUsers tu ON u.Id = tu.Id\nORDER BY s1.Score DESC, s1.UpVotes DESC, s1.DownVotes ASC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "5379.sql", "original_sql": "\nWITH UserStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        U.Reputation,\n        COUNT(DISTINCT P.Id) AS PostCount,\n        SUM(CASE WHEN P.Score > 0 THEN 1 ELSE 0 END) AS PositivePosts,\n        SUM(CASE WHEN P.Score < 0 THEN 1 ELSE 0 END) AS NegativePosts,\n        SUM(CASE WHEN P.ViewCount > 100 THEN 1 ELSE 0 END) AS PopularPosts,\n        AVG(P.ViewCount) AS AverageViews\n    FROM Users U\n    LEFT JOIN Posts P ON U.Id = P.OwnerUserId\n    GROUP BY U.Id, U.DisplayName, U.Reputation\n),\nBadgeStats AS (\n    SELECT \n        B.UserId, \n        COUNT(B.Id) AS BadgeCount,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Badges B\n    GROUP BY B.UserId\n),\nCombinedStats AS (\n    SELECT \n        US.UserId,\n        US.DisplayName,\n        US.Reputation,\n        US.PostCount,\n        US.PositivePosts,\n        US.NegativePosts,\n        US.PopularPosts,\n        US.AverageViews,\n        COALESCE(BS.BadgeCount, 0) AS BadgeCount,\n        COALESCE(BS.GoldBadges, 0) AS GoldBadges,\n        COALESCE(BS.SilverBadges, 0) AS SilverBadges,\n        COALESCE(BS.BronzeBadges, 0) AS BronzeBadges\n    FROM UserStats US\n    LEFT JOIN BadgeStats BS ON US.UserId = BS.UserId\n)\nSELECT \n    UserId,\n    DisplayName,\n    Reputation,\n    PostCount,\n    PositivePosts,\n    NegativePosts,\n    PopularPosts,\n    AverageViews,\n    BadgeCount,\n    GoldBadges,\n    SilverBadges,\n    BronzeBadges\nFROM CombinedStats\nWHERE Reputation > 1000\nORDER BY Reputation DESC, PostCount DESC\nLIMIT 50;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "5737.sql", "original_sql": "WITH UserStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        U.Reputation,\n        U.Views,\n        U.UpVotes,\n        U.DownVotes,\n        COUNT(DISTINCT P.Id) AS PostCount,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        SUM(CASE WHEN P.ClosedDate IS NOT NULL THEN 1 ELSE 0 END) AS ClosedPostCount\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    WHERE \n        U.Reputation > 1000\n    GROUP BY \n        U.Id, U.DisplayName, U.Reputation, U.Views, U.UpVotes, U.DownVotes\n),\nTopBadges AS (\n    SELECT \n        B.UserId,\n        COUNT(*) AS BadgeCount\n    FROM \n        Badges B\n    WHERE \n        B.Class = 1  \n    GROUP BY \n        B.UserId\n),\nPostHistoryCounts AS (\n    SELECT \n        PH.UserId,\n        COUNT(*) AS EditCount\n    FROM \n        PostHistory PH\n    WHERE \n        PH.PostHistoryTypeId IN (4, 5, 6)  \n    GROUP BY \n        PH.UserId\n),\nFinalStats AS (\n    SELECT \n        US.UserId,\n        US.DisplayName,\n        US.Reputation,\n        US.Views,\n        US.UpVotes,\n        US.DownVotes,\n        US.PostCount,\n        US.QuestionCount,\n        US.AnswerCount,\n        US.ClosedPostCount,\n        COALESCE(TB.BadgeCount, 0) AS GoldBadgeCount,\n        COALESCE(PHC.EditCount, 0) AS EditCount\n    FROM \n        UserStats US\n    LEFT JOIN \n        TopBadges TB ON US.UserId = TB.UserId\n    LEFT JOIN \n        PostHistoryCounts PHC ON US.UserId = PHC.UserId\n)\nSELECT \n    UserId,\n    DisplayName,\n    Reputation,\n    Views,\n    UpVotes,\n    DownVotes,\n    PostCount,\n    QuestionCount,\n    AnswerCount,\n    ClosedPostCount,\n    GoldBadgeCount,\n    EditCount\nFROM \n    FinalStats\nORDER BY \n    Reputation DESC, PostCount DESC\nLIMIT 10;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    U.Id AS UserId,\n    U.DisplayName,\n    U.Reputation,\n    U.Views,\n    U.UpVotes,\n    U.DownVotes,\n    COUNT(DISTINCT P.Id) AS PostCount,\n    SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n    SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n    SUM(CASE WHEN P.ClosedDate IS NOT NULL THEN 1 ELSE 0 END) AS ClosedPostCount\nFROM Users U\nLEFT JOIN Posts P ON U.Id = P.OwnerUserId\nWHERE U.Reputation > 1000\nGROUP BY U.Id, U.DisplayName, U.Reputation, U.Views, U.UpVotes, U.DownVotes;", "sql2": "WITH TopBadges AS (\n    SELECT B.UserId, COUNT(*) AS BadgeCount\n    FROM Badges B\n    WHERE B.Class = 1\n    GROUP BY B.UserId\n),\nPostHistoryCounts AS (\n    SELECT PH.UserId, COUNT(*) AS EditCount\n    FROM PostHistory PH\n    WHERE PH.PostHistoryTypeId IN (4, 5, 6)\n    GROUP BY PH.UserId\n)\nSELECT \n    s1.UserId,\n    s1.DisplayName,\n    s1.Reputation,\n    s1.Views,\n    s1.UpVotes,\n    s1.DownVotes,\n    s1.PostCount,\n    s1.QuestionCount,\n    s1.AnswerCount,\n    s1.ClosedPostCount,\n    COALESCE(tb.BadgeCount, 0) AS GoldBadgeCount,\n    COALESCE(phc.EditCount, 0) AS EditCount\nFROM s1\nLEFT JOIN TopBadges tb ON s1.UserId = tb.UserId\nLEFT JOIN PostHistoryCounts phc ON s1.UserId = phc.UserId\nORDER BY s1.Reputation DESC, s1.PostCount DESC\nLIMIT 10;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "5766.sql", "original_sql": "WITH UserBadgeCounts AS (\n    SELECT \n        u.Id AS UserId,\n        COUNT(b.Id) AS BadgeCount,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Users u\n    LEFT JOIN Badges b ON u.Id = b.UserId\n    GROUP BY u.Id\n),\nPostVoteSummary AS (\n    SELECT \n        p.Id AS PostId,\n        p.OwnerUserId,\n        COUNT(v.Id) AS VoteCount,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM Posts p\n    LEFT JOIN Votes v ON p.Id = v.PostId\n    WHERE p.CreationDate >= '2021-01-01'\n    GROUP BY p.Id, p.OwnerUserId\n),\nPostStats AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.ViewCount,\n        ps.VoteCount,\n        ps.UpVotes,\n        ps.DownVotes,\n        ub.BadgeCount AS UserBadgeCount,\n        ub.GoldBadges,\n        ub.SilverBadges,\n        ub.BronzeBadges\n    FROM Posts p\n    INNER JOIN PostVoteSummary ps ON p.Id = ps.PostId\n    LEFT JOIN UserBadgeCounts ub ON ub.UserId = ps.OwnerUserId\n)\nSELECT \n    ps.PostId,\n    ps.Title,\n    ps.ViewCount,\n    ps.VoteCount,\n    ps.UpVotes,\n    ps.DownVotes,\n    COALESCE(ps.UserBadgeCount, 0) AS UserBadgeCount,\n    COALESCE(ps.GoldBadges, 0) AS GoldBadges,\n    COALESCE(ps.SilverBadges, 0) AS SilverBadges,\n    COALESCE(ps.BronzeBadges, 0) AS BronzeBadges\nFROM PostStats ps\nWHERE ps.ViewCount > 1000\nORDER BY ps.UpVotes DESC, ps.ViewCount DESC\nLIMIT 50;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    p.Id AS PostId,\n    p.OwnerUserId,\n    COUNT(v.Id) AS VoteCount,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\nFROM Posts p\nLEFT JOIN Votes v ON p.Id = v.PostId\nWHERE p.CreationDate >= DATE '2021-01-01'\nGROUP BY p.Id, p.OwnerUserId;", "sql2": "WITH UserBadgeCounts AS (\n    SELECT \n        u.Id AS UserId,\n        COUNT(b.Id) AS BadgeCount,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Users u\n    LEFT JOIN Badges b ON u.Id = b.UserId\n    GROUP BY u.Id\n)\nSELECT \n    p.Id AS PostId,\n    p.Title,\n    p.ViewCount,\n    s1.VoteCount,\n    s1.UpVotes,\n    s1.DownVotes,\n    COALESCE(ub.BadgeCount, 0) AS UserBadgeCount,\n    COALESCE(ub.GoldBadges, 0) AS GoldBadges,\n    COALESCE(ub.SilverBadges, 0) AS SilverBadges,\n    COALESCE(ub.BronzeBadges, 0) AS BronzeBadges\nFROM Posts p\nINNER JOIN s1 ON p.Id = s1.PostId\nLEFT JOIN UserBadgeCounts ub ON ub.UserId = s1.OwnerUserId\nWHERE p.ViewCount > 1000\nORDER BY s1.UpVotes DESC, p.ViewCount DESC\nLIMIT 50;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "5798.sql", "original_sql": "WITH UserBadges AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(b.Id) AS BadgeCount,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Users u\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    GROUP BY \n        u.Id, u.DisplayName\n),\nPostStats AS (\n    SELECT \n        p.OwnerUserId,\n        COUNT(CASE WHEN p.PostTypeId = 1 THEN 1 END) AS QuestionCount,\n        COUNT(CASE WHEN p.PostTypeId = 2 THEN 1 END) AS AnswerCount,\n        SUM(p.Score) AS TotalScore,\n        SUM(p.ViewCount) AS TotalViews,\n        COUNT(DISTINCT p.Tags) AS UniqueTagCount\n    FROM \n        Posts p\n    WHERE \n        p.CreationDate >= cast('2024-10-01 12:34:56' as timestamp) - INTERVAL '1 year'\n    GROUP BY \n        p.OwnerUserId\n),\nUserPerformance AS (\n    SELECT \n        ub.UserId,\n        ub.DisplayName,\n        COALESCE(ps.QuestionCount, 0) AS QuestionCount,\n        COALESCE(ps.AnswerCount, 0) AS AnswerCount,\n        COALESCE(ps.TotalScore, 0) AS TotalScore,\n        COALESCE(ps.TotalViews, 0) AS TotalViews,\n        COALESCE(ps.UniqueTagCount, 0) AS UniqueTagCount,\n        ub.BadgeCount,\n        ub.GoldBadges,\n        ub.SilverBadges,\n        ub.BronzeBadges\n    FROM \n        UserBadges ub\n    LEFT JOIN \n        PostStats ps ON ub.UserId = ps.OwnerUserId\n)\nSELECT \n    UserId,\n    DisplayName,\n    QuestionCount,\n    AnswerCount,\n    TotalScore,\n    TotalViews,\n    UniqueTagCount,\n    BadgeCount,\n    GoldBadges,\n    SilverBadges,\n    BronzeBadges\nFROM \n    UserPerformance\nWHERE \n    TotalViews > 1000\nORDER BY \n    TotalScore DESC, QuestionCount DESC\nLIMIT 50;", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 'ub'\", span: None, notes: [DiagnosticNote { message: \"possible column ps.owneruserid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"ub\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"ub\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"owneruserid\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"questioncount\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"answercount\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"totalscore\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"totalviews\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"uniquetagcount\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "5840.sql", "original_sql": "SELECT \n    u.DisplayName AS User,\n    p.Title AS Post_Title,\n    p.CreationDate AS Post_Creation_Date,\n    p.Score AS Post_Score,\n    COALESCE(avg_comments.avg_comment_score, 0) AS Average_Comment_Score,\n    COALESCE(vote_counts.UpVotes, 0) AS Total_UpVotes,\n    COALESCE(vote_counts.DownVotes, 0) AS Total_DownVotes\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nLEFT JOIN \n    (\n        SELECT \n            c.PostId,\n            AVG(c.Score) AS avg_comment_score\n        FROM \n            Comments c\n        GROUP BY \n            c.PostId\n    ) avg_comments ON p.Id = avg_comments.PostId\nLEFT JOIN \n    (\n        SELECT \n            v.PostId,\n            SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n            SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n        FROM \n            Votes v\n        GROUP BY \n            v.PostId\n    ) vote_counts ON p.Id = vote_counts.PostId\nWHERE \n    p.PostTypeId = 1\nORDER BY \n    p.CreationDate DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT\n    p.Id AS PostId,\n    u.DisplayName AS User,\n    p.Title AS Post_Title,\n    p.CreationDate AS Post_Creation_Date,\n    p.Score AS Post_Score\nFROM Posts p\nJOIN Users u ON p.OwnerUserId = u.Id\nWHERE p.PostTypeId = 1\nORDER BY p.CreationDate DESC\nLIMIT 100;", "sql2": "WITH avg_comments AS (\n    SELECT c.PostId, AVG(c.Score) AS avg_comment_score\n    FROM Comments c\n    JOIN s1 ON c.PostId = s1.PostId\n    GROUP BY c.PostId\n),\nvote_counts AS (\n    SELECT v.PostId,\n           SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n           SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM Votes v\n    JOIN s1 ON v.PostId = s1.PostId\n    GROUP BY v.PostId\n)\nSELECT\n    s1.User,\n    s1.Post_Title,\n    s1.Post_Creation_Date,\n    s1.Post_Score,\n    COALESCE(ac.avg_comment_score, 0) AS Average_Comment_Score,\n    COALESCE(vc.UpVotes, 0) AS Total_UpVotes,\n    COALESCE(vc.DownVotes, 0) AS Total_DownVotes\nFROM s1\nLEFT JOIN avg_comments ac ON s1.PostId = ac.PostId\nLEFT JOIN vote_counts vc ON s1.PostId = vc.PostId\nORDER BY s1.Post_Creation_Date DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "5843.sql", "original_sql": "WITH UserPostStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(p.Id) AS TotalPosts,\n        COUNT(DISTINCT CASE WHEN p.PostTypeId = 1 THEN p.Id END) AS QuestionCount,\n        COUNT(DISTINCT CASE WHEN p.PostTypeId = 2 THEN p.Id END) AS AnswerCount,\n        SUM(p.ViewCount) AS TotalViews,\n        SUM(p.Score) AS TotalScore,\n        MAX(p.CreationDate) AS LastPostDate\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    GROUP BY \n        u.Id, u.DisplayName\n),\nUserBadges AS (\n    SELECT \n        b.UserId,\n        COUNT(CASE WHEN b.Class = 1 THEN 1 END) AS GoldBadges,\n        COUNT(CASE WHEN b.Class = 2 THEN 1 END) AS SilverBadges,\n        COUNT(CASE WHEN b.Class = 3 THEN 1 END) AS BronzeBadges\n    FROM \n        Badges b\n    GROUP BY \n        b.UserId\n),\nPostHistoryStats AS (\n    SELECT \n        ph.UserId,\n        COUNT(CASE WHEN ph.PostHistoryTypeId IN (10, 11) THEN 1 END) AS CloseReopenCount,\n        COUNT(CASE WHEN ph.PostHistoryTypeId IN (24, 25) THEN 1 END) AS EditSuggestionCount\n    FROM \n        PostHistory ph\n    GROUP BY \n        ph.UserId\n)\nSELECT \n    ups.UserId,\n    ups.DisplayName,\n    ups.TotalPosts,\n    ups.QuestionCount,\n    ups.AnswerCount,\n    ups.TotalViews,\n    ups.TotalScore,\n    ub.GoldBadges,\n    ub.SilverBadges,\n    ub.BronzeBadges,\n    phs.CloseReopenCount,\n    phs.EditSuggestionCount,\n    ups.LastPostDate\nFROM \n    UserPostStats ups\nLEFT JOIN \n    UserBadges ub ON ups.UserId = ub.UserId \nLEFT JOIN \n    PostHistoryStats phs ON ups.UserId = phs.UserId\nWHERE \n    ups.TotalPosts > 0\nORDER BY \n    ups.TotalScore DESC, ups.LastPostDate DESC\nLIMIT 100;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column ub.userid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"ub\" }), name: \"userid\" }, Column { relation: Some(Bare { table: \"ub\" }), name: \"goldbadges\" }, Column { relation: Some(Bare { table: \"ub\" }), name: \"silverbadges\" }, Column { relation: Some(Bare { table: \"ub\" }), name: \"bronzebadges\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "5844.sql", "original_sql": "WITH TopUsers AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        SUM(U.UpVotes) AS TotalUpVotes,\n        SUM(U.DownVotes) AS TotalDownVotes,\n        COUNT(DISTINCT P.Id) AS PostCount\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    WHERE \n        U.CreationDate >= cast('2024-10-01 12:34:56' as timestamp) - INTERVAL '1 year'\n    GROUP BY \n        U.Id, U.DisplayName\n), \nPopularTags AS (\n    SELECT \n        T.TagName,\n        COUNT(P.Id) AS PostCount,\n        SUM(P.ViewCount) AS TotalViews\n    FROM \n        Tags T\n    JOIN \n        Posts P ON P.Tags LIKE '%' || T.TagName || '%'\n    GROUP BY \n        T.TagName\n    ORDER BY \n        PostCount DESC\n    LIMIT 10\n),\nRecentActivities AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        PH.CreationDate,\n        PH.Comment,\n        P.Title AS PostTitle\n    FROM \n        PostHistory PH\n    JOIN \n        Posts P ON PH.PostId = P.Id\n    JOIN \n        Users U ON PH.UserId = U.Id\n    WHERE \n        PH.CreationDate >= cast('2024-10-01 12:34:56' as timestamp) - INTERVAL '1 month'\n)\n\nSELECT \n    TU.DisplayName AS TopUser,\n    TU.TotalUpVotes,\n    TU.TotalDownVotes,\n    TU.PostCount,\n    PT.TagName AS PopularTag,\n    PT.PostCount AS TagPostCount,\n    PT.TotalViews AS TagTotalViews,\n    RA.UserId AS ActivityUserId,\n    RA.PostTitle,\n    RA.Comment,\n    RA.CreationDate AS ActivityDate\nFROM \n    TopUsers TU\nCROSS JOIN \n    PopularTags PT\nLEFT JOIN \n    RecentActivities RA ON TU.UserId = RA.UserId\nORDER BY \n    TU.TotalUpVotes DESC, \n    PT.PostCount DESC, \n    RA.CreationDate DESC;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    T.TagName,\n    COUNT(P.Id) AS PostCount,\n    SUM(P.ViewCount) AS TotalViews\nFROM \n    Tags T\nJOIN \n    Posts P ON P.Tags LIKE '%' || T.TagName || '%'\nGROUP BY \n    T.TagName\nORDER BY \n    PostCount DESC\nLIMIT 10;", "sql2": "WITH TopUsers AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        SUM(U.UpVotes) AS TotalUpVotes,\n        SUM(U.DownVotes) AS TotalDownVotes,\n        COUNT(DISTINCT P.Id) AS PostCount\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    WHERE \n        U.CreationDate >= CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '1' YEAR\n    GROUP BY \n        U.Id, U.DisplayName\n), \nRecentActivities AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        PH.CreationDate,\n        PH.Comment,\n        P.Title AS PostTitle\n    FROM \n        PostHistory PH\n    JOIN \n        Posts P ON PH.PostId = P.Id\n    JOIN \n        Users U ON PH.UserId = U.Id\n    WHERE \n        PH.CreationDate >= CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '1' MONTH\n)\n\nSELECT \n    TU.DisplayName AS TopUser,\n    TU.TotalUpVotes,\n    TU.TotalDownVotes,\n    TU.PostCount,\n    PT.TagName AS PopularTag,\n    PT.PostCount AS TagPostCount,\n    PT.TotalViews AS TagTotalViews,\n    RA.UserId AS ActivityUserId,\n    RA.PostTitle,\n    RA.Comment,\n    RA.CreationDate AS ActivityDate\nFROM \n    TopUsers TU\nCROSS JOIN \n    s1 PT\nLEFT JOIN \n    RecentActivities RA ON TU.UserId = RA.UserId\nORDER BY \n    TU.TotalUpVotes DESC, \n    PT.PostCount DESC, \n    RA.CreationDate DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "6006.sql", "original_sql": "\nWITH UserBadges AS (\n    SELECT \n        U.Id AS UserId, \n        U.DisplayName, \n        COUNT(B.Id) AS BadgeCount,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Users U\n    LEFT JOIN \n        Badges B ON U.Id = B.UserId\n    GROUP BY \n        U.Id, U.DisplayName\n),\nPostStats AS (\n    SELECT \n        P.OwnerUserId, \n        COUNT(P.Id) AS TotalPosts, \n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions, \n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS Answers,\n        SUM(P.Score) AS TotalScore,\n        AVG(P.ViewCount) AS AvgViewCount\n    FROM \n        Posts P\n    WHERE \n        P.CreationDate > CURRENT_DATE - INTERVAL '1 year'\n    GROUP BY \n        P.OwnerUserId\n),\nActiveUsers AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        UB.BadgeCount,\n        PS.TotalPosts,\n        PS.Questions,\n        PS.Answers,\n        PS.TotalScore,\n        PS.AvgViewCount\n    FROM \n        Users U\n    JOIN \n        UserBadges UB ON U.Id = UB.UserId\n    JOIN \n        PostStats PS ON U.Id = PS.OwnerUserId\n    WHERE \n        U.LastAccessDate > CURRENT_DATE - INTERVAL '6 months'\n)\nSELECT \n    UserId, \n    DisplayName, \n    BadgeCount, \n    TotalPosts, \n    Questions, \n    Answers, \n    TotalScore, \n    AvgViewCount\nFROM \n    ActiveUsers\nORDER BY \n    TotalScore DESC, \n    BadgeCount DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT\n    P.OwnerUserId AS UserId,\n    COUNT(P.Id) AS TotalPosts,\n    SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions,\n    SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS Answers,\n    SUM(P.Score) AS TotalScore,\n    AVG(P.ViewCount) AS AvgViewCount\nFROM Posts P\nWHERE P.CreationDate > CURRENT_DATE - INTERVAL '1' YEAR\nGROUP BY P.OwnerUserId", "sql2": "SELECT\n    U.Id AS UserId,\n    U.DisplayName,\n    COALESCE(UB.BadgeCount, 0) AS BadgeCount,\n    s1.TotalPosts,\n    s1.Questions,\n    s1.Answers,\n    s1.TotalScore,\n    s1.AvgViewCount\nFROM Users U\nJOIN s1 ON U.Id = s1.UserId\nLEFT JOIN (\n    SELECT\n        B.UserId,\n        COUNT(B.Id) AS BadgeCount,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Badges B\n    GROUP BY B.UserId\n) UB ON U.Id = UB.UserId\nWHERE U.LastAccessDate > CURRENT_DATE - INTERVAL '6' MONTH\nORDER BY s1.TotalScore DESC, COALESCE(UB.BadgeCount, 0) DESC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "6030.sql", "original_sql": "\nWITH UserStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        U.Reputation,\n        U.CreationDate,\n        COUNT(DISTINCT P.Id) AS TotalPosts,\n        COUNT(DISTINCT CASE WHEN P.PostTypeId = 1 THEN P.Id END) AS TotalQuestions,\n        COUNT(DISTINCT CASE WHEN P.PostTypeId = 2 THEN P.Id END) AS TotalAnswers,\n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUpVotes,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalDownVotes\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    LEFT JOIN \n        Votes V ON P.Id = V.PostId\n    GROUP BY \n        U.Id, U.DisplayName, U.Reputation, U.CreationDate\n), BadgeStats AS (\n    SELECT \n        B.UserId,\n        COUNT(B.Id) AS TotalBadges,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Badges B\n    GROUP BY \n        B.UserId\n), CombinedStats AS (\n    SELECT \n        US.UserId,\n        US.DisplayName,\n        US.Reputation,\n        US.CreationDate,\n        US.TotalPosts,\n        US.TotalQuestions,\n        US.TotalAnswers,\n        US.TotalUpVotes,\n        US.TotalDownVotes,\n        COALESCE(BS.TotalBadges, 0) AS TotalBadges,\n        COALESCE(BS.GoldBadges, 0) AS GoldBadges,\n        COALESCE(BS.SilverBadges, 0) AS SilverBadges,\n        COALESCE(BS.BronzeBadges, 0) AS BronzeBadges\n    FROM \n        UserStats US\n    LEFT JOIN \n        BadgeStats BS ON US.UserId = BS.UserId\n)\nSELECT \n    UserId,\n    DisplayName,\n    Reputation,\n    CreationDate,\n    TotalPosts,\n    TotalQuestions,\n    TotalAnswers,\n    TotalUpVotes,\n    TotalDownVotes,\n    TotalBadges,\n    GoldBadges,\n    SilverBadges,\n    BronzeBadges\nFROM \n    CombinedStats\nWHERE \n    Reputation > 1000\nORDER BY \n    TotalPosts DESC, TotalUpVotes DESC\nFETCH FIRST 10 ROWS ONLY;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    U.Id AS UserId,\n    U.DisplayName,\n    U.Reputation,\n    U.CreationDate,\n    COUNT(DISTINCT P.Id) AS TotalPosts,\n    COUNT(DISTINCT CASE WHEN P.PostTypeId = 1 THEN P.Id END) AS TotalQuestions,\n    COUNT(DISTINCT CASE WHEN P.PostTypeId = 2 THEN P.Id END) AS TotalAnswers,\n    SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUpVotes,\n    SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalDownVotes\nFROM Users U\nLEFT JOIN Posts P ON U.Id = P.OwnerUserId\nLEFT JOIN Votes V ON P.Id = V.PostId\nGROUP BY U.Id, U.DisplayName, U.Reputation, U.CreationDate;", "sql2": "WITH BadgeStats AS (\n    SELECT\n        B.UserId,\n        COUNT(*) AS TotalBadges,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Badges B\n    GROUP BY B.UserId\n)\nSELECT\n    s1.UserId,\n    s1.DisplayName,\n    s1.Reputation,\n    s1.CreationDate,\n    s1.TotalPosts,\n    s1.TotalQuestions,\n    s1.TotalAnswers,\n    s1.TotalUpVotes,\n    s1.TotalDownVotes,\n    COALESCE(bs.TotalBadges, 0) AS TotalBadges,\n    COALESCE(bs.GoldBadges, 0) AS GoldBadges,\n    COALESCE(bs.SilverBadges, 0) AS SilverBadges,\n    COALESCE(bs.BronzeBadges, 0) AS BronzeBadges\nFROM s1\nLEFT JOIN BadgeStats bs ON s1.UserId = bs.UserId\nWHERE s1.Reputation > 1000\nORDER BY s1.TotalPosts DESC, s1.TotalUpVotes DESC\nLIMIT 10;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "6055.sql", "original_sql": "WITH UserBadgeCounts AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(b.Id) AS BadgeCount,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Users u\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    GROUP BY \n        u.Id, u.DisplayName\n),\nUserPostStats AS (\n    SELECT \n        p.OwnerUserId,\n        COUNT(p.Id) AS PostCount,\n        SUM(CASE WHEN p.Score > 0 THEN 1 ELSE 0 END) AS ScorePositive,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS Answers\n    FROM \n        Posts p\n    WHERE \n        p.CreationDate >= cast('2024-10-01' as date) - INTERVAL '1 year'\n    GROUP BY \n        p.OwnerUserId\n),\nCombinedStats AS (\n    SELECT \n        ubc.UserId,\n        ubc.DisplayName,\n        ubc.BadgeCount,\n        ubc.GoldBadges,\n        ubc.SilverBadges,\n        ubc.BronzeBadges,\n        ups.PostCount,\n        ups.ScorePositive,\n        ups.Questions,\n        ups.Answers\n    FROM \n        UserBadgeCounts ubc\n    LEFT JOIN \n        UserPostStats ups ON ubc.UserId = ups.OwnerUserId\n)\nSELECT \n    *\nFROM \n    CombinedStats\nORDER BY \n    BadgeCount DESC,\n    ScorePositive DESC,\n    PostCount DESC\nLIMIT 100;", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT\n    p.OwnerUserId AS OwnerUserId,\n    COUNT(p.Id) AS PostCount,\n    SUM(CASE WHEN p.Score > 0 THEN 1 ELSE 0 END) AS ScorePositive,\n    SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions,\n    SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS Answers\nFROM Posts p\nWHERE p.CreationDate >= CAST('2024-10-01' AS DATE) - INTERVAL '1' YEAR\nGROUP BY p.OwnerUserId;", "sql2": "WITH UserBadgeCounts AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(b.Id) AS BadgeCount,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Users u\n    LEFT JOIN Badges b ON u.Id = b.UserId\n    GROUP BY u.Id, u.DisplayName\n)\nSELECT \n    ubc.UserId,\n    ubc.DisplayName,\n    ubc.BadgeCount,\n    ubc.GoldBadges,\n    ubc.SilverBadges,\n    ubc.BronzeBadges,\n    s1.PostCount,\n    s1.ScorePositive,\n    s1.Questions,\n    s1.Answers\nFROM UserBadgeCounts ubc\nLEFT JOIN s1 ON ubc.UserId = s1.OwnerUserId\nORDER BY BadgeCount DESC, ScorePositive DESC, PostCount DESC\nLIMIT 100;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "6448.sql", "original_sql": "\nWITH UserStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        U.Reputation,\n        COUNT(B.Id) AS BadgeCount,\n        SUM(CASE WHEN Vote.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotesReceived,\n        SUM(CASE WHEN Vote.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotesReceived\n    FROM \n        Users U\n    LEFT JOIN \n        Badges B ON U.Id = B.UserId\n    LEFT JOIN \n        Votes Vote ON U.Id = Vote.UserId\n    GROUP BY \n        U.Id, U.DisplayName, U.Reputation\n), PostStats AS (\n    SELECT \n        P.OwnerUserId,\n        COUNT(P.Id) AS TotalPosts,\n        COUNT(DISTINCT CASE WHEN P.PostTypeId = 1 THEN P.Id END) AS Questions,\n        COUNT(DISTINCT CASE WHEN P.PostTypeId = 2 THEN P.Id END) AS Answers,\n        AVG(P.Score) AS AvgPostScore,\n        SUM(P.ViewCount) AS TotalViews\n    FROM \n        Posts P\n    GROUP BY \n        P.OwnerUserId\n), CombinedStats AS (\n    SELECT \n        U.UserId,\n        U.DisplayName,\n        U.Reputation,\n        U.BadgeCount,\n        U.UpVotesReceived,\n        U.DownVotesReceived,\n        P.TotalPosts,\n        P.Questions,\n        P.Answers,\n        P.AvgPostScore,\n        P.TotalViews\n    FROM \n        UserStats U\n    JOIN \n        PostStats P ON U.UserId = P.OwnerUserId\n)\nSELECT \n    C.DisplayName,\n    C.Reputation,\n    C.BadgeCount,\n    C.UpVotesReceived,\n    C.DownVotesReceived,\n    COALESCE(C.TotalPosts, 0) AS TotalPosts,\n    COALESCE(C.Questions, 0) AS TotalQuestions,\n    COALESCE(C.Answers, 0) AS TotalAnswers,\n    COALESCE(C.AvgPostScore, 0) AS AvgPostScore,\n    COALESCE(C.TotalViews, 0) AS TotalViews\nFROM \n    CombinedStats C\nORDER BY \n    C.Reputation DESC,\n    C.BadgeCount DESC,\n    C.UpVotesReceived DESC\nLIMIT 100;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column p.owneruserid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"owneruserid\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"totalposts\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"questions\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"answers\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"avgpostscore\" }, Column { relation: Some(Bare { table: \"p\" }), name: \"totalviews\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "6563.sql", "original_sql": "WITH UserReputation AS (\n    SELECT \n        U.Id AS UserId,\n        U.Reputation,\n        COUNT(DISTINCT P.Id) AS PostCount,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    GROUP BY \n        U.Id, U.Reputation\n),\nBadgeSummary AS (\n    SELECT \n        B.UserId,\n        COUNT(B.Id) AS BadgeCount,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Badges B\n    GROUP BY \n        B.UserId\n),\nTopUsers AS (\n    SELECT \n        UR.UserId,\n        UR.Reputation,\n        UR.PostCount,\n        UR.QuestionCount,\n        UR.AnswerCount,\n        COALESCE(BS.BadgeCount, 0) AS BadgeCount,\n        COALESCE(BS.GoldBadges, 0) AS GoldBadges,\n        COALESCE(BS.SilverBadges, 0) AS SilverBadges,\n        COALESCE(BS.BronzeBadges, 0) AS BronzeBadges\n    FROM \n        UserReputation UR\n    LEFT JOIN \n        BadgeSummary BS ON UR.UserId = BS.UserId\n    ORDER BY \n        UR.Reputation DESC, UR.PostCount DESC\n    LIMIT 10\n)\nSELECT \n    U.DisplayName,\n    U.Reputation,\n    T.PostCount,\n    T.QuestionCount,\n    T.AnswerCount,\n    T.BadgeCount,\n    T.GoldBadges,\n    T.SilverBadges,\n    T.BronzeBadges\nFROM \n    TopUsers T\nJOIN \n    Users U ON T.UserId = U.Id\nWHERE \n    T.QuestionCount > 5\nORDER BY \n    T.Reputation DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    UR.UserId,\n    UR.Reputation,\n    UR.PostCount,\n    UR.QuestionCount,\n    UR.AnswerCount,\n    COALESCE(BS.BadgeCount, 0) AS BadgeCount,\n    COALESCE(BS.GoldBadges, 0) AS GoldBadges,\n    COALESCE(BS.SilverBadges, 0) AS SilverBadges,\n    COALESCE(BS.BronzeBadges, 0) AS BronzeBadges\nFROM (\n    SELECT \n        U.Id AS UserId,\n        U.Reputation,\n        COUNT(DISTINCT P.Id) AS PostCount,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount\n    FROM Users U\n    LEFT JOIN Posts P ON U.Id = P.OwnerUserId\n    GROUP BY U.Id, U.Reputation\n) UR\nLEFT JOIN (\n    SELECT \n        B.UserId,\n        COUNT(*) AS BadgeCount,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Badges B\n    GROUP BY B.UserId\n) BS ON UR.UserId = BS.UserId\nORDER BY UR.Reputation DESC, UR.PostCount DESC\nLIMIT 10;", "sql2": "SELECT \n    U.DisplayName,\n    U.Reputation,\n    s1.PostCount,\n    s1.QuestionCount,\n    s1.AnswerCount,\n    s1.BadgeCount,\n    s1.GoldBadges,\n    s1.SilverBadges,\n    s1.BronzeBadges\nFROM s1\nJOIN Users U ON s1.UserId = U.Id\nWHERE s1.QuestionCount > 5\nORDER BY s1.Reputation DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "6597.sql", "original_sql": "WITH UserStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        U.Reputation,\n        COUNT(DISTINCT P.Id) AS PostCount,\n        SUM(CASE WHEN P.ViewCount > 1000 THEN 1 ELSE 0 END) AS PopularPosts,\n        SUM(CASE WHEN P.Score > 50 THEN 1 ELSE 0 END) AS HighScorePosts\n    FROM Users U\n    LEFT JOIN Posts P ON U.Id = P.OwnerUserId\n    WHERE U.Reputation > 100\n    GROUP BY U.Id, U.DisplayName, U.Reputation\n), \nBadgeCounts AS (\n    SELECT \n        B.UserId,\n        COUNT(*) AS BadgeCount\n    FROM Badges B\n    GROUP BY B.UserId\n), \nReport AS (\n    SELECT \n        US.UserId,\n        US.DisplayName,\n        US.Reputation,\n        US.PostCount,\n        US.PopularPosts,\n        US.HighScorePosts,\n        COALESCE(BC.BadgeCount, 0) AS BadgeCount\n    FROM UserStats US\n    LEFT JOIN BadgeCounts BC ON US.UserId = BC.UserId\n)\nSELECT \n    R.DisplayName,\n    R.Reputation,\n    R.PostCount,\n    R.PopularPosts,\n    R.HighScorePosts,\n    R.BadgeCount,\n    CASE \n        WHEN R.Reputation > 1000 THEN 'Elite'\n        WHEN R.Reputation > 500 THEN 'Pro'\n        ELSE 'Novice'\n    END AS UserTier\nFROM Report R\nWHERE R.PostCount > 10\nORDER BY R.Reputation DESC, R.PostCount DESC\nLIMIT 20;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT U.Id AS UserId,\n       U.DisplayName,\n       U.Reputation,\n       COUNT(DISTINCT P.Id) AS PostCount,\n       SUM(CASE WHEN P.ViewCount > 1000 THEN 1 ELSE 0 END) AS PopularPosts,\n       SUM(CASE WHEN P.Score > 50 THEN 1 ELSE 0 END) AS HighScorePosts\nFROM Users U\nLEFT JOIN Posts P ON U.Id = P.OwnerUserId\nWHERE U.Reputation > 100\nGROUP BY U.Id, U.DisplayName, U.Reputation;", "sql2": "SELECT R.DisplayName,\n       R.Reputation,\n       R.PostCount,\n       R.PopularPosts,\n       R.HighScorePosts,\n       COALESCE(BC.BadgeCount, 0) AS BadgeCount,\n       CASE WHEN R.Reputation > 1000 THEN 'Elite'\n            WHEN R.Reputation > 500 THEN 'Pro'\n            ELSE 'Novice' END AS UserTier\nFROM s1 R\nLEFT JOIN (\n    SELECT UserId, COUNT(*) AS BadgeCount\n    FROM Badges\n    GROUP BY UserId\n) BC ON R.UserId = BC.UserId\nWHERE R.PostCount > 10\nORDER BY R.Reputation DESC, R.PostCount DESC\nLIMIT 20;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "6598.sql", "original_sql": "\nWITH UserEngagement AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        u.Reputation,\n        COALESCE(SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END), 0) AS TotalUpvotes,\n        COALESCE(SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END), 0) AS TotalDownvotes,\n        COALESCE(SUM(CASE WHEN v.VoteTypeId = 10 THEN 1 ELSE 0 END), 0) AS TotalDeletions,\n        COALESCE(SUM(CASE WHEN v.VoteTypeId = 11 THEN 1 ELSE 0 END), 0) AS TotalUndeletions\n    FROM Users u\n    LEFT JOIN Votes v ON u.Id = v.UserId\n    GROUP BY u.Id, u.DisplayName, u.Reputation\n),\nPostStatistics AS (\n    SELECT \n        p.OwnerUserId,\n        COUNT(CASE WHEN p.PostTypeId = 1 THEN 1 END) AS TotalQuestions,\n        COUNT(CASE WHEN p.PostTypeId = 2 THEN 1 END) AS TotalAnswers,\n        AVG(p.Score) AS AvgScore,\n        SUM(p.ViewCount) AS TotalViews\n    FROM Posts p\n    GROUP BY p.OwnerUserId\n),\nEngagementInsights AS (\n    SELECT \n        ue.UserId,\n        ue.DisplayName,\n        ue.Reputation,\n        ue.TotalUpvotes,\n        ue.TotalDownvotes,\n        ps.TotalQuestions,\n        ps.TotalAnswers,\n        ps.AvgScore,\n        ps.TotalViews\n    FROM UserEngagement ue\n    LEFT JOIN PostStatistics ps ON ue.UserId = ps.OwnerUserId\n)\nSELECT \n    ei.DisplayName,\n    ei.Reputation,\n    ei.TotalUpvotes,\n    ei.TotalDownvotes,\n    ei.TotalQuestions,\n    ei.TotalAnswers,\n    ei.AvgScore,\n    ei.TotalViews,\n    CASE \n        WHEN ei.TotalAnswers > ei.TotalQuestions THEN 'High Answer Rate'\n        WHEN ei.TotalUpvotes > ei.TotalDownvotes THEN 'Positive Engagement'\n        ELSE 'Needs Improvement'\n    END AS EngagementCategory\nFROM EngagementInsights ei\nWHERE ei.Reputation > 100 \nORDER BY ei.Reputation DESC, ei.TotalUpvotes DESC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 'ue'\", span: None, notes: [DiagnosticNote { message: \"possible column ps.owneruserid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"ue\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"ue\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"owneruserid\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"totalquestions\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"totalanswers\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"avgscore\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"totalviews\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "6835.sql", "original_sql": "\nWITH UserStats AS (\n    SELECT \n        U.Id AS UserId, \n        U.DisplayName, \n        U.Reputation, \n        COUNT(DISTINCT P.Id) AS PostCount, \n        COUNT(DISTINCT V.Id) AS VoteCount,\n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVoteCount,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVoteCount\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    LEFT JOIN \n        Votes V ON U.Id = V.UserId\n    GROUP BY \n        U.Id, U.DisplayName, U.Reputation\n), \nPostEngagement AS (\n    SELECT \n        P.Id AS PostId, \n        P.Title, \n        COUNT(CASE WHEN C.Id IS NOT NULL THEN 1 END) AS CommentCount,\n        COUNT(DISTINCT PH.UserId) AS EditCount,\n        MAX(PH.CreationDate) AS LastEditDate\n    FROM \n        Posts P\n    LEFT JOIN \n        Comments C ON P.Id = C.PostId\n    LEFT JOIN \n        PostHistory PH ON P.Id = PH.PostId\n    WHERE \n        P.CreationDate >= '2024-10-01 12:34:56'::timestamp - INTERVAL '1 year'\n    GROUP BY \n        P.Id, P.Title\n), \nHighEngagementPosts AS (\n    SELECT \n        PE.PostId,\n        PE.Title,\n        PE.CommentCount,\n        PE.EditCount,\n        U.DisplayName,\n        U.Reputation\n    FROM \n        PostEngagement PE\n    JOIN \n        Users U ON U.Id = (SELECT OwnerUserId FROM Posts WHERE Id = PE.PostId)\n    WHERE \n        PE.CommentCount > 5 AND PE.EditCount > 2\n)\nSELECT \n    U.Id AS UserId, \n    U.DisplayName, \n    U.Reputation, \n    COUNT(HEP.PostId) AS EngagedPostCount\nFROM \n    Users U\nLEFT JOIN \n    HighEngagementPosts HEP ON U.Id = (SELECT OwnerUserId FROM Posts WHERE Id = HEP.PostId)\nGROUP BY \n    U.Id, U.DisplayName, U.Reputation\nORDER BY \n    EngagedPostCount DESC, U.Reputation DESC\nLIMIT 10;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "6949.sql", "original_sql": "\nWITH UserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        u.Reputation,\n        COUNT(DISTINCT p.Id) AS TotalPosts,\n        COUNT(DISTINCT CASE WHEN p.PostTypeId = 2 THEN p.Id END) AS TotalAnswers,\n        COUNT(DISTINCT CASE WHEN p.PostTypeId = 1 THEN p.Id END) AS TotalQuestions,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalDownVotes\n    FROM \n        Users u\n    LEFT JOIN Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN Votes v ON p.Id = v.PostId\n    GROUP BY u.Id, u.DisplayName, u.Reputation\n), \nBadgeCounts AS (\n    SELECT \n        b.UserId, \n        COUNT(b.Id) AS TotalBadges,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Badges b\n    GROUP BY b.UserId\n), \nPostHistoryStats AS (\n    SELECT \n        ph.UserId, \n        COUNT(ph.Id) AS TotalEdits, \n        COUNT(DISTINCT CASE WHEN ph.PostHistoryTypeId = 10 THEN ph.Id END) AS TotalClosedPosts\n    FROM \n        PostHistory ph\n    GROUP BY ph.UserId\n)\nSELECT \n    us.UserId,\n    us.DisplayName,\n    us.Reputation,\n    us.TotalPosts,\n    us.TotalQuestions,\n    us.TotalAnswers,\n    us.TotalUpVotes,\n    us.TotalDownVotes,\n    COALESCE(bc.TotalBadges, 0) AS TotalBadges,\n    COALESCE(bc.GoldBadges, 0) AS GoldBadges,\n    COALESCE(bc.SilverBadges, 0) AS SilverBadges,\n    COALESCE(bc.BronzeBadges, 0) AS BronzeBadges,\n    COALESCE(phs.TotalEdits, 0) AS TotalEdits,\n    COALESCE(phs.TotalClosedPosts, 0) AS TotalClosedPosts\nFROM \n    UserStats us\nLEFT JOIN \n    BadgeCounts bc ON us.UserId = bc.UserId\nLEFT JOIN \n    PostHistoryStats phs ON us.UserId = phs.UserId\nORDER BY \n    us.Reputation DESC\nLIMIT 50;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    u.Id AS UserId,\n    u.DisplayName,\n    u.Reputation,\n    COUNT(DISTINCT p.Id) AS TotalPosts,\n    COUNT(DISTINCT CASE WHEN p.PostTypeId = 2 THEN p.Id END) AS TotalAnswers,\n    COUNT(DISTINCT CASE WHEN p.PostTypeId = 1 THEN p.Id END) AS TotalQuestions,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUpVotes,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalDownVotes\nFROM Users u\nLEFT JOIN Posts p ON u.Id = p.OwnerUserId\nLEFT JOIN Votes v ON p.Id = v.PostId\nGROUP BY u.Id, u.DisplayName, u.Reputation;", "sql2": "WITH BadgeCounts AS (\n    SELECT \n        b.UserId, \n        COUNT(b.Id) AS TotalBadges,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Badges b\n    GROUP BY b.UserId\n), \nPostHistoryStats AS (\n    SELECT \n        ph.UserId, \n        COUNT(ph.Id) AS TotalEdits, \n        COUNT(DISTINCT CASE WHEN ph.PostHistoryTypeId = 10 THEN ph.Id END) AS TotalClosedPosts\n    FROM PostHistory ph\n    GROUP BY ph.UserId\n)\nSELECT \n    us.UserId,\n    us.DisplayName,\n    us.Reputation,\n    us.TotalPosts,\n    us.TotalQuestions,\n    us.TotalAnswers,\n    us.TotalUpVotes,\n    us.TotalDownVotes,\n    COALESCE(bc.TotalBadges, 0) AS TotalBadges,\n    COALESCE(bc.GoldBadges, 0) AS GoldBadges,\n    COALESCE(bc.SilverBadges, 0) AS SilverBadges,\n    COALESCE(bc.BronzeBadges, 0) AS BronzeBadges,\n    COALESCE(phs.TotalEdits, 0) AS TotalEdits,\n    COALESCE(phs.TotalClosedPosts, 0) AS TotalClosedPosts\nFROM s1 us\nLEFT JOIN BadgeCounts bc ON us.UserId = bc.UserId\nLEFT JOIN PostHistoryStats phs ON us.UserId = phs.UserId\nORDER BY us.Reputation DESC\nLIMIT 50;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "6987.sql", "original_sql": "WITH UserBadges AS (\n    SELECT \n        u.Id AS UserId,\n        COUNT(b.Id) AS TotalBadges,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Users u\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    GROUP BY \n        u.Id\n),\nPostStats AS (\n    SELECT \n        p.OwnerUserId,\n        COUNT(p.Id) AS TotalPosts,\n        COUNT(CASE WHEN p.PostTypeId = 1 THEN 1 END) AS Questions,\n        COUNT(CASE WHEN p.PostTypeId = 2 THEN 1 END) AS Answers,\n        SUM(p.Score) AS TotalScore,\n        SUM(p.ViewCount) AS TotalViewCount\n    FROM \n        Posts p\n    GROUP BY \n        p.OwnerUserId\n),\nTopUsers AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COALESCE(pb.TotalBadges, 0) AS TotalBadges,\n        COALESCE(ps.TotalPosts, 0) AS TotalPosts,\n        COALESCE(ps.Questions, 0) AS Questions,\n        COALESCE(ps.Answers, 0) AS Answers,\n        COALESCE(ps.TotalScore, 0) AS TotalScore,\n        COALESCE(ps.TotalViewCount, 0) AS TotalViewCount\n    FROM \n        Users u\n    LEFT JOIN \n        UserBadges pb ON u.Id = pb.UserId\n    LEFT JOIN \n        PostStats ps ON u.Id = ps.OwnerUserId\n    ORDER BY \n        TotalScore DESC, TotalBadges DESC\n    LIMIT 10\n)\nSELECT \n    tu.UserId,\n    tu.DisplayName,\n    tu.TotalBadges,\n    tu.TotalPosts,\n    tu.Questions,\n    tu.Answers,\n    tu.TotalScore,\n    tu.TotalViewCount\nFROM \n    TopUsers tu\nJOIN \n    (SELECT DISTINCT OwnerUserId FROM Posts) AS p ON tu.UserId = p.OwnerUserId\nORDER BY \n    tu.TotalScore DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH UserBadges AS (\n    SELECT \n        u.Id AS UserId,\n        COUNT(b.Id) AS TotalBadges,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Users u\n    LEFT JOIN Badges b ON u.Id = b.UserId\n    GROUP BY u.Id\n),\nPostStats AS (\n    SELECT \n        p.OwnerUserId,\n        COUNT(p.Id) AS TotalPosts,\n        COUNT(CASE WHEN p.PostTypeId = 1 THEN 1 END) AS Questions,\n        COUNT(CASE WHEN p.PostTypeId = 2 THEN 1 END) AS Answers,\n        SUM(p.Score) AS TotalScore,\n        SUM(p.ViewCount) AS TotalViewCount\n    FROM Posts p\n    GROUP BY p.OwnerUserId\n),\nTopUsers AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COALESCE(pb.TotalBadges, 0) AS TotalBadges,\n        COALESCE(ps.TotalPosts, 0) AS TotalPosts,\n        COALESCE(ps.Questions, 0) AS Questions,\n        COALESCE(ps.Answers, 0) AS Answers,\n        COALESCE(ps.TotalScore, 0) AS TotalScore,\n        COALESCE(ps.TotalViewCount, 0) AS TotalViewCount\n    FROM Users u\n    LEFT JOIN UserBadges pb ON u.Id = pb.UserId\n    LEFT JOIN PostStats ps ON u.Id = ps.OwnerUserId\n    ORDER BY TotalScore DESC, TotalBadges DESC\n    LIMIT 10\n)\nSELECT *\nFROM TopUsers;", "sql2": "SELECT \n    tu.UserId,\n    tu.DisplayName,\n    tu.TotalBadges,\n    tu.TotalPosts,\n    tu.Questions,\n    tu.Answers,\n    tu.TotalScore,\n    tu.TotalViewCount\nFROM s1 tu\nJOIN (SELECT DISTINCT OwnerUserId FROM Posts) p\n  ON tu.UserId = p.OwnerUserId\nORDER BY tu.TotalScore DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "7139.sql", "original_sql": "WITH PostStats AS (\n    SELECT \n        p.OwnerUserId,\n        COUNT(*) AS PostCount,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        AVG(p.Score) AS AvgScore,\n        SUM(p.ViewCount) AS TotalViews,\n        SUM(p.CommentCount) AS TotalComments\n    FROM \n        Posts p\n    GROUP BY \n        p.OwnerUserId\n),\nUserBadges AS (\n    SELECT \n        b.UserId,\n        COUNT(*) AS BadgeCount,\n        MAX(b.Class) AS HighestBadgeClass\n    FROM \n        Badges b\n    GROUP BY \n        b.UserId\n),\nActiveUsers AS (\n    SELECT \n        u.Id,\n        u.DisplayName,\n        us.PostCount,\n        us.QuestionCount,\n        us.AnswerCount,\n        us.AvgScore,\n        us.TotalViews,\n        us.TotalComments,\n        ub.BadgeCount,\n        ub.HighestBadgeClass\n    FROM \n        Users u\n    JOIN \n        PostStats us ON u.Id = us.OwnerUserId\n    LEFT JOIN \n        UserBadges ub ON u.Id = ub.UserId\n    WHERE \n        u.Reputation > 1000\n)\nSELECT \n    au.DisplayName,\n    au.PostCount,\n    au.QuestionCount,\n    au.AnswerCount,\n    au.AvgScore,\n    au.TotalViews,\n    au.TotalComments,\n    COALESCE(au.BadgeCount, 0) AS BadgeCount,\n    COALESCE(au.HighestBadgeClass, 0) AS HighestBadgeClass\nFROM \n    ActiveUsers au\nORDER BY \n    au.AvgScore DESC, \n    au.TotalViews DESC\nLIMIT 10;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH ps AS (\n    SELECT p.OwnerUserId,\n           COUNT(*) AS PostCount,\n           SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n           SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n           AVG(p.Score) AS AvgScore,\n           SUM(p.ViewCount) AS TotalViews,\n           SUM(p.CommentCount) AS TotalComments\n    FROM Posts p\n    GROUP BY p.OwnerUserId\n),\nub AS (\n    SELECT b.UserId,\n           COUNT(*) AS BadgeCount,\n           MAX(b.Class) AS HighestBadgeClass\n    FROM Badges b\n    GROUP BY b.UserId\n)\nSELECT \n    ps.OwnerUserId,\n    ps.PostCount,\n    ps.QuestionCount,\n    ps.AnswerCount,\n    ps.AvgScore,\n    ps.TotalViews,\n    ps.TotalComments,\n    COALESCE(ub.BadgeCount, 0) AS BadgeCount,\n    COALESCE(ub.HighestBadgeClass, 0) AS HighestBadgeClass\nFROM ps\nLEFT JOIN ub ON ps.OwnerUserId = ub.UserId;", "sql2": "SELECT \n    u.DisplayName,\n    s.PostCount,\n    s.QuestionCount,\n    s.AnswerCount,\n    s.AvgScore,\n    s.TotalViews,\n    s.TotalComments,\n    s.BadgeCount,\n    s.HighestBadgeClass\nFROM s1 s\nJOIN Users u ON u.Id = s.OwnerUserId\nWHERE u.Reputation > 1000\nORDER BY s.AvgScore DESC, s.TotalViews DESC\nLIMIT 10;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "7274.sql", "original_sql": "WITH UserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        u.Reputation,\n        COUNT(p.Id) AS TotalPosts,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS Answers,\n        SUM(CASE WHEN p.PostTypeId = 3 THEN 1 ELSE 0 END) AS Wikis,\n        SUM(CASE WHEN p.ViewCount > 100 THEN 1 ELSE 0 END) AS PopularPosts\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    GROUP BY \n        u.Id, u.DisplayName, u.Reputation\n),\nBadgeStats AS (\n    SELECT \n        b.UserId,\n        COUNT(b.Id) AS TotalBadges,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Badges b\n    GROUP BY \n        b.UserId\n),\nPostHistoryStats AS (\n    SELECT \n        ph.UserId,\n        COUNT(ph.Id) AS TotalEdits,\n        SUM(CASE WHEN ph.PostHistoryTypeId IN (4, 5, 6) THEN 1 ELSE 0 END) AS TitleAndBodyEdits,\n        SUM(CASE WHEN ph.PostHistoryTypeId = 10 THEN 1 ELSE 0 END) AS PostsClosed\n    FROM \n        PostHistory ph\n    GROUP BY \n        ph.UserId\n)\nSELECT \n    us.UserId,\n    us.DisplayName,\n    us.Reputation,\n    us.TotalPosts,\n    us.Questions,\n    us.Answers,\n    us.Wikis,\n    us.PopularPosts,\n    COALESCE(bs.TotalBadges, 0) AS TotalBadges,\n    COALESCE(bs.GoldBadges, 0) AS GoldBadges,\n    COALESCE(bs.SilverBadges, 0) AS SilverBadges,\n    COALESCE(bs.BronzeBadges, 0) AS BronzeBadges,\n    COALESCE(phs.TotalEdits, 0) AS TotalEdits,\n    COALESCE(phs.TitleAndBodyEdits, 0) AS TitleAndBodyEdits,\n    COALESCE(phs.PostsClosed, 0) AS PostsClosed\nFROM \n    UserStats us\nLEFT JOIN \n    BadgeStats bs ON us.UserId = bs.UserId\nLEFT JOIN \n    PostHistoryStats phs ON us.UserId = phs.UserId\nORDER BY \n    us.Reputation DESC, us.TotalPosts DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT u.Id AS UserId,\n       u.DisplayName,\n       u.Reputation,\n       COUNT(p.Id) AS TotalPosts,\n       SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions,\n       SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS Answers,\n       SUM(CASE WHEN p.PostTypeId = 3 THEN 1 ELSE 0 END) AS Wikis,\n       SUM(CASE WHEN p.ViewCount > 100 THEN 1 ELSE 0 END) AS PopularPosts\nFROM Users u\nLEFT JOIN Posts p ON u.Id = p.OwnerUserId\nGROUP BY u.Id, u.DisplayName, u.Reputation;", "sql2": "SELECT s1.UserId,\n       s1.DisplayName,\n       s1.Reputation,\n       s1.TotalPosts,\n       s1.Questions,\n       s1.Answers,\n       s1.Wikis,\n       s1.PopularPosts,\n       COALESCE(bs.TotalBadges, 0)      AS TotalBadges,\n       COALESCE(bs.GoldBadges, 0)       AS GoldBadges,\n       COALESCE(bs.SilverBadges, 0)     AS SilverBadges,\n       COALESCE(bs.BronzeBadges, 0)     AS BronzeBadges,\n       COALESCE(phs.TotalEdits, 0)      AS TotalEdits,\n       COALESCE(phs.TitleAndBodyEdits, 0) AS TitleAndBodyEdits,\n       COALESCE(phs.PostsClosed, 0)     AS PostsClosed\nFROM s1\nLEFT JOIN (\n    SELECT b.UserId,\n           COUNT(b.Id)                         AS TotalBadges,\n           SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n           SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n           SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Badges b\n    GROUP BY b.UserId\n) bs ON s1.UserId = bs.UserId\nLEFT JOIN (\n    SELECT ph.UserId,\n           COUNT(ph.Id)                         AS TotalEdits,\n           SUM(CASE WHEN ph.PostHistoryTypeId IN (4,5,6) THEN 1 ELSE 0 END) AS TitleAndBodyEdits,\n           SUM(CASE WHEN ph.PostHistoryTypeId = 10 THEN 1 ELSE 0 END)      AS PostsClosed\n    FROM PostHistory ph\n    GROUP BY ph.UserId\n) phs ON s1.UserId = phs.UserId\nORDER BY s1.Reputation DESC, s1.TotalPosts DESC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "7281.sql", "original_sql": "WITH UserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        u.Reputation,\n        COUNT(DISTINCT p.Id) AS PostCount,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        SUM(CASE WHEN p.PostTypeId = 1 AND p.AcceptedAnswerId IS NOT NULL THEN 1 ELSE 0 END) AS AcceptedAnswers,\n        SUM(CASE WHEN p.ViewCount > 100 THEN 1 ELSE 0 END) AS PopularPosts\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    GROUP BY \n        u.Id, u.DisplayName, u.Reputation\n),\nBadgeCounts AS (\n    SELECT \n        b.UserId,\n        COUNT(b.Id) AS BadgeCount,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Badges b\n    GROUP BY \n        b.UserId\n),\nCombinedStats AS (\n    SELECT \n        us.UserId,\n        us.DisplayName,\n        us.Reputation,\n        us.PostCount,\n        us.QuestionCount,\n        us.AnswerCount,\n        us.AcceptedAnswers,\n        us.PopularPosts,\n        COALESCE(bc.BadgeCount, 0) AS BadgeCount,\n        COALESCE(bc.GoldBadges, 0) AS GoldBadges,\n        COALESCE(bc.SilverBadges, 0) AS SilverBadges,\n        COALESCE(bc.BronzeBadges, 0) AS BronzeBadges\n    FROM \n        UserStats us\n    LEFT JOIN \n        BadgeCounts bc ON us.UserId = bc.UserId\n)\nSELECT \n    c.DisplayName,\n    c.Reputation,\n    c.PostCount,\n    c.QuestionCount,\n    c.AnswerCount,\n    c.AcceptedAnswers,\n    c.PopularPosts,\n    c.BadgeCount,\n    c.GoldBadges,\n    c.SilverBadges,\n    c.BronzeBadges\nFROM \n    CombinedStats c\nWHERE \n    c.Reputation > 1000 \n    AND c.PostCount > 10\nORDER BY \n    c.Reputation DESC, \n    c.PostCount DESC\nLIMIT 100;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column bc.userid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"bc\" }), name: \"userid\" }, Column { relation: Some(Bare { table: \"bc\" }), name: \"badgecount\" }, Column { relation: Some(Bare { table: \"bc\" }), name: \"goldbadges\" }, Column { relation: Some(Bare { table: \"bc\" }), name: \"silverbadges\" }, Column { relation: Some(Bare { table: \"bc\" }), name: \"bronzebadges\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "7320.sql", "original_sql": "WITH UserVoteStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n        COUNT(DISTINCT P.Id) AS TotalPosts\n    FROM \n        Users U\n    LEFT JOIN \n        Votes V ON U.Id = V.UserId\n    LEFT JOIN \n        Posts P ON V.PostId = P.Id\n    GROUP BY \n        U.Id, U.DisplayName\n),\nPostStatistics AS (\n    SELECT \n        P.OwnerUserId,\n        COUNT(P.Id) AS TotalPosts,\n        AVG(P.Score) AS AverageScore,\n        SUM(CASE WHEN PH.PostHistoryTypeId = 10 THEN 1 ELSE 0 END) AS TimesClosed,\n        SUM(CASE WHEN PH.PostHistoryTypeId = 11 THEN 1 ELSE 0 END) AS TimesReopened,\n        SUM(CASE WHEN PH.PostHistoryTypeId IN (52, 53) THEN 1 ELSE 0 END) AS HotQuestionChanges\n    FROM \n        Posts P\n    LEFT JOIN \n        PostHistory PH ON P.Id = PH.PostId\n    GROUP BY \n        P.OwnerUserId\n),\nCombinedStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        U.Reputation,\n        UVS.UpVotes,\n        UVS.DownVotes,\n        PS.TotalPosts AS UserTotalPosts,\n        PS.AverageScore,\n        PS.TimesClosed,\n        PS.TimesReopened,\n        PS.HotQuestionChanges\n    FROM \n        UserVoteStats UVS\n    JOIN \n        PostStatistics PS ON UVS.UserId = PS.OwnerUserId\n    JOIN \n        Users U ON U.Id = PS.OwnerUserId\n)\nSELECT \n    UserId,\n    DisplayName,\n    Reputation,\n    UpVotes,\n    DownVotes,\n    UserTotalPosts,\n    AverageScore,\n    TimesClosed,\n    TimesReopened,\n    HotQuestionChanges\nFROM \n    CombinedStats\nWHERE \n    Reputation > 1000\nORDER BY \n    UpVotes DESC, AverageScore DESC\nLIMIT 50;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH UserVoteStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes,\n        COUNT(DISTINCT P.Id) AS TotalPosts\n    FROM Users U\n    LEFT JOIN Votes V ON U.Id = V.UserId\n    LEFT JOIN Posts P ON V.PostId = P.Id\n    GROUP BY U.Id, U.DisplayName\n),\nPostStatistics AS (\n    SELECT \n        P.OwnerUserId,\n        COUNT(P.Id) AS TotalPosts,\n        AVG(P.Score) AS AverageScore,\n        SUM(CASE WHEN PH.PostHistoryTypeId = 10 THEN 1 ELSE 0 END) AS TimesClosed,\n        SUM(CASE WHEN PH.PostHistoryTypeId = 11 THEN 1 ELSE 0 END) AS TimesReopened,\n        SUM(CASE WHEN PH.PostHistoryTypeId IN (52, 53) THEN 1 ELSE 0 END) AS HotQuestionChanges\n    FROM Posts P\n    LEFT JOIN PostHistory PH ON P.Id = PH.PostId\n    GROUP BY P.OwnerUserId\n)\nSELECT \n    U.Id AS UserId,\n    U.DisplayName,\n    U.Reputation,\n    UVS.UpVotes,\n    UVS.DownVotes,\n    PS.TotalPosts AS UserTotalPosts,\n    PS.AverageScore,\n    PS.TimesClosed,\n    PS.TimesReopened,\n    PS.HotQuestionChanges\nFROM UserVoteStats UVS\nJOIN PostStatistics PS ON UVS.UserId = PS.OwnerUserId\nJOIN Users U ON U.Id = PS.OwnerUserId;", "sql2": "SELECT \n    UserId,\n    DisplayName,\n    Reputation,\n    UpVotes,\n    DownVotes,\n    UserTotalPosts,\n    AverageScore,\n    TimesClosed,\n    TimesReopened,\n    HotQuestionChanges\nFROM s1\nWHERE Reputation > 1000\nORDER BY UpVotes DESC, AverageScore DESC\nLIMIT 50;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "758.sql", "original_sql": "\nWITH RankedPosts AS (\n    SELECT \n        p.Id AS PostId, \n        p.Title, \n        p.Score, \n        p.CreationDate, \n        p.OwnerUserId, \n        RANK() OVER (PARTITION BY p.OwnerUserId ORDER BY p.Score DESC) AS Rank,\n        COALESCE(cc.CommentCount, 0) AS CommentCount\n    FROM \n        Posts p\n    LEFT JOIN \n        (SELECT PostId, COUNT(*) AS CommentCount \n         FROM Comments \n         GROUP BY PostId) cc ON p.Id = cc.PostId\n    WHERE \n        p.CreationDate >= (CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '1 year')\n), UserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(DISTINCT p.Id) AS TotalPosts,\n        SUM(p.Score) AS TotalScore,\n        SUM(u.UpVotes) AS UpVoteCount,\n        SUM(u.DownVotes) AS DownVoteCount,\n        AVG(COALESCE(rp.CommentCount, 0)) AS AvgCommentsPerPost\n    FROM \n        Users u\n    LEFT JOIN \n        RankedPosts rp ON u.Id = rp.OwnerUserId\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    GROUP BY \n        u.Id, u.DisplayName\n)\nSELECT \n    us.UserId,\n    us.DisplayName,\n    us.TotalPosts,\n    us.TotalScore,\n    us.UpVoteCount,\n    us.DownVoteCount,\n    us.AvgCommentsPerPost,\n    (CASE \n        WHEN us.TotalScore > 100 THEN 'High Scorer'\n        WHEN us.TotalScore BETWEEN 50 AND 100 THEN 'Medium Scorer'\n        ELSE 'Low Scorer'\n    END) AS ScoreCategory,\n    (SELECT COUNT(*) \n     FROM Badges b \n     WHERE b.UserId = us.UserId \n       AND b.Class = 1) AS GoldBadges,\n    (SELECT COUNT(*) \n     FROM Badges b \n     WHERE b.UserId = us.UserId \n       AND b.Class = 2) AS SilverBadges,\n    (SELECT COUNT(*) \n     FROM Badges b \n     WHERE b.UserId = us.UserId \n       AND b.Class = 3) AS BronzeBadges\nFROM \n    UserStats us\nWHERE \n    us.TotalPosts > 0\nORDER BY \n    us.TotalScore DESC, us.DisplayName ASC\nLIMIT 100 OFFSET 0;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "7629.sql", "original_sql": "\nWITH UserReputation AS (\n    SELECT \n        UserId,\n        SUM(CASE WHEN VoteTypeId = 2 THEN 1 ELSE 0 END) AS Upvotes,\n        SUM(CASE WHEN VoteTypeId = 3 THEN 1 ELSE 0 END) AS Downvotes,\n        SUM(CASE WHEN VoteTypeId = 2 THEN 1 ELSE -1 END) AS ReputationChange\n    FROM \n        Votes\n    GROUP BY \n        UserId\n),\n\nPostDetails AS (\n    SELECT \n        p.Id AS PostId,\n        p.OwnerUserId,\n        p.Title,\n        p.CreationDate,\n        p.Score,\n        p.ViewCount,\n        COALESCE(SUM(CASE WHEN c.Id IS NOT NULL THEN 1 ELSE 0 END), 0) AS CommentCount,\n        COALESCE(SUM(CASE WHEN ph.PostHistoryTypeId = 10 THEN 1 ELSE 0 END), 0) AS ClosedCount,\n        COALESCE(SUM(CASE WHEN ph.PostHistoryTypeId = 11 THEN 1 ELSE 0 END), 0) AS ReopenedCount\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        PostHistory ph ON p.Id = ph.PostId\n    GROUP BY \n        p.Id, p.OwnerUserId, p.Title, p.CreationDate, p.Score, p.ViewCount\n),\n\nUserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        u.Reputation,\n        ur.Upvotes,\n        ur.Downvotes,\n        ur.ReputationChange,\n        COUNT(DISTINCT pd.PostId) AS TotalPosts,\n        SUM(pd.Score) AS TotalScore,\n        COALESCE(SUM(pd.CommentCount), 0) AS TotalComments,\n        COALESCE(SUM(pd.ClosedCount), 0) AS TotalClosed,\n        COALESCE(SUM(pd.ReopenedCount), 0) AS TotalReopened\n    FROM \n        Users u\n    LEFT JOIN \n        UserReputation ur ON u.Id = ur.UserId\n    LEFT JOIN \n        PostDetails pd ON u.Id = pd.OwnerUserId\n    GROUP BY \n        u.Id, u.DisplayName, u.Reputation, ur.Upvotes, ur.Downvotes, ur.ReputationChange\n)\n\nSELECT \n    us.UserId, \n    us.DisplayName, \n    us.Reputation, \n    us.TotalPosts, \n    us.TotalScore, \n    us.TotalComments, \n    us.TotalClosed, \n    us.TotalReopened\nFROM \n    UserStats us\nWHERE \n    us.Reputation > 1000\nORDER BY \n    us.Reputation DESC, us.TotalScore DESC\nLIMIT 10;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: SchemaError(AmbiguousReference { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"totalscore\" } }, Some(\"\"))\n", "engine_mem_mb": 500000}
{"query_id": "7660.sql", "original_sql": "WITH UserBadgeCounts AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(b.Id) AS BadgeCount,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldCount,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverCount,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeCount\n    FROM Users u\n    LEFT JOIN Badges b ON u.Id = b.UserId\n    GROUP BY u.Id, u.DisplayName\n),\nPostStats AS (\n    SELECT \n        p.OwnerUserId,\n        COUNT(p.Id) AS TotalPosts,\n        COUNT(CASE WHEN p.PostTypeId = 1 THEN 1 END) AS QuestionCount,\n        COUNT(CASE WHEN p.PostTypeId = 2 THEN 1 END) AS AnswerCount,\n        SUM(p.Score) AS TotalScore\n    FROM Posts p\n    GROUP BY p.OwnerUserId\n),\nCombinedStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        u.Reputation,\n        COALESCE(ub.BadgeCount, 0) AS BadgeCount,\n        COALESCE(ub.GoldCount, 0) AS GoldCount,\n        COALESCE(ub.SilverCount, 0) AS SilverCount,\n        COALESCE(ub.BronzeCount, 0) AS BronzeCount,\n        COALESCE(ps.TotalPosts, 0) AS TotalPosts,\n        COALESCE(ps.QuestionCount, 0) AS QuestionCount,\n        COALESCE(ps.AnswerCount, 0) AS AnswerCount,\n        COALESCE(ps.TotalScore, 0) AS TotalScore\n    FROM Users u\n    LEFT JOIN UserBadgeCounts ub ON u.Id = ub.UserId\n    LEFT JOIN PostStats ps ON u.Id = ps.OwnerUserId\n)\nSELECT \n    UserId,\n    DisplayName,\n    Reputation,\n    BadgeCount,\n    GoldCount,\n    SilverCount,\n    BronzeCount,\n    TotalPosts,\n    QuestionCount,\n    AnswerCount,\n    TotalScore\nFROM CombinedStats\nWHERE TotalPosts > 0\nORDER BY TotalScore DESC, Reputation DESC\nLIMIT 10;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 's1'\", span: None, notes: [], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"u\" }), name: \"id\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"reputation\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"creationdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"displayname\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"lastaccessdate\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"websiteurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"location\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"aboutme\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"views\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"upvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"downvotes\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"profileimageurl\" }, Column { relation: Some(Bare { table: \"u\" }), name: \"accountid\" }, Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "7669.sql", "original_sql": "\nWITH UserStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        U.Reputation,\n        U.UpVotes,\n        U.DownVotes,\n        COUNT(DISTINCT P.Id) AS PostCount,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotesReceived,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotesReceived,\n        AVG(P.Score) AS AvgPostScore\n    FROM Users U\n    LEFT JOIN Posts P ON U.Id = P.OwnerUserId\n    LEFT JOIN Votes V ON P.Id = V.PostId\n    GROUP BY U.Id, U.DisplayName, U.Reputation, U.UpVotes, U.DownVotes\n),\nBadgeCounts AS (\n    SELECT \n        B.UserId,\n        COUNT(B.Id) AS BadgeCount,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Badges B\n    GROUP BY B.UserId\n),\nCombinedStats AS (\n    SELECT \n        US.UserId,\n        US.DisplayName,\n        US.Reputation,\n        US.PostCount,\n        US.QuestionCount,\n        US.AnswerCount,\n        COALESCE(BC.BadgeCount, 0) AS BadgeCount,\n        COALESCE(BC.GoldBadges, 0) AS GoldBadges,\n        COALESCE(BC.SilverBadges, 0) AS SilverBadges,\n        COALESCE(BC.BronzeBadges, 0) AS BronzeBadges,\n        US.UpVotesReceived,\n        US.DownVotesReceived,\n        US.AvgPostScore\n    FROM UserStats US\n    LEFT JOIN BadgeCounts BC ON US.UserId = BC.UserId\n)\nSELECT \n    C.DisplayName,\n    C.Reputation,\n    C.PostCount,\n    C.QuestionCount,\n    C.AnswerCount,\n    C.BadgeCount,\n    C.GoldBadges,\n    C.SilverBadges,\n    C.BronzeBadges,\n    C.UpVotesReceived,\n    C.DownVotesReceived,\n    C.AvgPostScore\nFROM CombinedStats C\nWHERE C.Reputation > 1000 \nORDER BY C.Reputation DESC, C.PostCount DESC\nLIMIT 10;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column bc.userid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"bc\" }), name: \"userid\" }, Column { relation: Some(Bare { table: \"bc\" }), name: \"badgecount\" }, Column { relation: Some(Bare { table: \"bc\" }), name: \"goldbadges\" }, Column { relation: Some(Bare { table: \"bc\" }), name: \"silverbadges\" }, Column { relation: Some(Bare { table: \"bc\" }), name: \"bronzebadges\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "7694.sql", "original_sql": "\nWITH UserPostStats AS (\n    SELECT u.Id AS UserId,\n           u.DisplayName,\n           COUNT(DISTINCT p.Id) AS TotalPosts,\n           SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n           SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers,\n           AVG(u.Reputation) AS AverageReputation,\n           SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUpvotes,\n           SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalDownvotes\n    FROM Users u\n    LEFT JOIN Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN Votes v ON p.Id = v.PostId\n    GROUP BY u.Id, u.DisplayName\n),\nPostInteractions AS (\n    SELECT p.Id AS PostId,\n           p.Title,\n           p.CreationDate,\n           COUNT(c.Id) AS CommentCount,\n           COUNT(pl.RelatedPostId) AS RelatedPostLinks,\n           MAX(CASE WHEN ph.PostHistoryTypeId = 10 THEN ph.CreationDate END) AS ClosedDate,\n           MAX(CASE WHEN ph.PostHistoryTypeId = 11 THEN ph.CreationDate END) AS ReopenedDate\n    FROM Posts p\n    LEFT JOIN Comments c ON p.Id = c.PostId\n    LEFT JOIN PostLinks pl ON p.Id = pl.PostId\n    LEFT JOIN PostHistory ph ON p.Id = ph.PostId\n    GROUP BY p.Id, p.Title, p.CreationDate\n),\nCombinedStats AS (\n    SELECT ups.UserId,\n           ups.DisplayName,\n           ups.TotalPosts,\n           ups.TotalQuestions,\n           ups.TotalAnswers,\n           ups.AverageReputation,\n           ups.TotalUpvotes,\n           ups.TotalDownvotes,\n           pi.PostId,\n           pi.Title,\n           pi.CreationDate,\n           pi.CommentCount,\n           pi.RelatedPostLinks,\n           pi.ClosedDate,\n           pi.ReopenedDate\n    FROM UserPostStats ups\n    JOIN PostInteractions pi ON ups.UserId = pi.PostId  \n)\nSELECT *,\n       CASE \n           WHEN ClosedDate IS NOT NULL THEN 'Closed'\n           WHEN ReopenedDate IS NOT NULL THEN 'Reopened'\n           ELSE 'Active'\n       END AS PostStatus\nFROM CombinedStats\nWHERE AverageReputation > 100\nORDER BY TotalPosts DESC, AverageReputation DESC\nLIMIT 50;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    u.Id AS UserId,\n    u.DisplayName,\n    COUNT(DISTINCT p.Id) AS TotalPosts,\n    SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n    SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers,\n    AVG(u.Reputation) AS AverageReputation,\n    SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUpvotes,\n    SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalDownvotes\nFROM Users u\nLEFT JOIN Posts p ON u.Id = p.OwnerUserId\nLEFT JOIN Votes v ON p.Id = v.PostId\nGROUP BY u.Id, u.DisplayName;", "sql2": "WITH PostInteractions AS (\n    SELECT\n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        COUNT(c.Id) AS CommentCount,\n        COUNT(pl.RelatedPostId) AS RelatedPostLinks,\n        MAX(CASE WHEN ph.PostHistoryTypeId = 10 THEN ph.CreationDate END) AS ClosedDate,\n        MAX(CASE WHEN ph.PostHistoryTypeId = 11 THEN ph.CreationDate END) AS ReopenedDate\n    FROM Posts p\n    LEFT JOIN Comments c ON p.Id = c.PostId\n    LEFT JOIN PostLinks pl ON p.Id = pl.PostId\n    LEFT JOIN PostHistory ph ON p.Id = ph.PostId\n    GROUP BY p.Id, p.Title, p.CreationDate\n)\nSELECT\n    s1.*, \n    pi.PostId,\n    pi.Title,\n    pi.CreationDate,\n    pi.CommentCount,\n    pi.RelatedPostLinks,\n    pi.ClosedDate,\n    pi.ReopenedDate,\n    CASE \n        WHEN pi.ClosedDate IS NOT NULL THEN 'Closed'\n        WHEN pi.ReopenedDate IS NOT NULL THEN 'Reopened'\n        ELSE 'Active'\n    END AS PostStatus\nFROM s1\nJOIN PostInteractions pi ON s1.UserId = pi.PostId\nWHERE s1.AverageReputation > 100\nORDER BY s1.TotalPosts DESC, s1.AverageReputation DESC\nLIMIT 50;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "7698.sql", "original_sql": "\nWITH UserEngagement AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        SUM(CASE WHEN v.VoteTypeId IN (2, 3) THEN 1 ELSE 0 END) AS VoteCount,\n        COUNT(DISTINCT c.Id) AS CommentCount,\n        COUNT(DISTINCT p.Id) AS PostCount\n    FROM \n        Users u\n    LEFT JOIN \n        Votes v ON u.Id = v.UserId\n    LEFT JOIN \n        Comments c ON u.Id = c.UserId\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    GROUP BY \n        u.Id, u.DisplayName\n),\nPostStatistics AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        p.ViewCount,\n        p.Score,\n        COALESCE(SUM(c.Score), 0) AS TotalCommentScore,\n        COALESCE(SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END), 0) AS UpvoteCount,\n        COALESCE(SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END), 0) AS DownvoteCount\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    WHERE \n        p.CreationDate >= CAST('2024-10-01' AS DATE) - INTERVAL '30 days'\n    GROUP BY \n        p.Id, p.Title, p.CreationDate, p.ViewCount, p.Score\n),\nTopPosts AS (\n    SELECT \n        ps.PostId,\n        ps.Title,\n        ps.CreationDate,\n        ps.ViewCount,\n        ps.Score,\n        ps.TotalCommentScore,\n        ps.UpvoteCount,\n        ps.DownvoteCount,\n        ROW_NUMBER() OVER (ORDER BY ps.Score DESC, ps.ViewCount DESC) AS Rank\n    FROM \n        PostStatistics ps\n)\nSELECT \n    ue.DisplayName,\n    tp.Title,\n    tp.ViewCount,\n    tp.Score,\n    tp.UpvoteCount,\n    tp.DownvoteCount,\n    tp.TotalCommentScore\nFROM \n    UserEngagement ue\nJOIN \n    Posts p ON ue.UserId = p.OwnerUserId\nJOIN \n    TopPosts tp ON p.Id = tp.PostId\nWHERE \n    ue.PostCount >= 5\nORDER BY \n    tp.Score DESC, tp.ViewCount DESC;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "7939.sql", "original_sql": "\nWITH UserPostStatistics AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(P.Id) AS TotalPosts,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers,\n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUpvotes,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalDownvotes\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    LEFT JOIN \n        Votes V ON P.Id = V.PostId\n    GROUP BY \n        U.Id, U.DisplayName\n),\nUserBadges AS (\n    SELECT \n        B.UserId,\n        COUNT(B.Id) AS TotalBadges,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Badges B\n    GROUP BY \n        B.UserId\n),\nPostCloseStatistics AS (\n    SELECT \n        PH.UserId,\n        COUNT(PH.Id) AS TotalPostClosures,\n        MIN(PH.CreationDate) AS FirstCloseDate,\n        MAX(PH.CreationDate) AS LastCloseDate\n    FROM \n        PostHistory PH\n    WHERE \n        PH.PostHistoryTypeId = 10\n    GROUP BY \n        PH.UserId\n)\nSELECT \n    UPS.UserId,\n    UPS.DisplayName,\n    UPS.TotalPosts,\n    UPS.TotalQuestions,\n    UPS.TotalAnswers,\n    UPS.TotalUpvotes,\n    UPS.TotalDownvotes,\n    UB.TotalBadges,\n    UB.GoldBadges,\n    UB.SilverBadges,\n    UB.BronzeBadges,\n    PCS.TotalPostClosures,\n    PCS.FirstCloseDate,\n    PCS.LastCloseDate\nFROM \n    UserPostStatistics UPS\nLEFT JOIN \n    UserBadges UB ON UPS.UserId = UB.UserId\nLEFT JOIN \n    PostCloseStatistics PCS ON UPS.UserId = PCS.UserId\nORDER BY \n    UPS.TotalPosts DESC, UPS.TotalUpvotes DESC\nFETCH FIRST 100 ROWS ONLY;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column ub.userid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"ub\" }), name: \"userid\" }, Column { relation: Some(Bare { table: \"ub\" }), name: \"totalbadges\" }, Column { relation: Some(Bare { table: \"ub\" }), name: \"goldbadges\" }, Column { relation: Some(Bare { table: \"ub\" }), name: \"silverbadges\" }, Column { relation: Some(Bare { table: \"ub\" }), name: \"bronzebadges\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "8237.sql", "original_sql": "WITH UserActivity AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(DISTINCT p.Id) AS PostCount,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpvoteCount,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownvoteCount\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    GROUP BY \n        u.Id, u.DisplayName\n),\nBadgeStats AS (\n    SELECT \n        UserId,\n        COUNT(*) AS BadgeCount,\n        SUM(CASE WHEN Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Badges\n    GROUP BY \n        UserId\n),\nPostStatistics AS (\n    SELECT \n        p.OwnerUserId,\n        COUNT(DISTINCT p.Id) AS TotalPosts,\n        AVG(COALESCE((SELECT COUNT(*) FROM Comments c WHERE c.PostId = p.Id), 0)) AS AvgCommentsPerPost,\n        MAX(p.ViewCount) AS MaxViews,\n        MIN(p.CreationDate) AS FirstPostDate,\n        MAX(p.CreationDate) AS LastPostDate\n    FROM \n        Posts p\n    GROUP BY \n        p.OwnerUserId\n)\nSELECT \n    ua.UserId,\n    ua.DisplayName,\n    ua.PostCount,\n    ua.QuestionCount,\n    ua.AnswerCount,\n    ua.UpvoteCount,\n    ua.DownvoteCount,\n    bs.BadgeCount,\n    bs.GoldBadges,\n    bs.SilverBadges,\n    bs.BronzeBadges,\n    ps.TotalPosts,\n    ps.AvgCommentsPerPost,\n    ps.MaxViews,\n    ps.FirstPostDate,\n    ps.LastPostDate\nFROM \n    UserActivity ua\nLEFT JOIN \n    BadgeStats bs ON ua.UserId = bs.UserId\nLEFT JOIN \n    PostStatistics ps ON ua.UserId = ps.OwnerUserId\nORDER BY \n    ua.PostCount DESC, \n    ua.UpvoteCount DESC\nLIMIT 100;\n", "status": "missing_whole_cache", "engine_mem_mb": 500000}
{"query_id": "8310.sql", "original_sql": "WITH UserBadgeStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(b.Id) AS BadgeCount,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadgeCount,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadgeCount,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadgeCount\n    FROM \n        Users u\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    GROUP BY \n        u.Id, u.DisplayName\n),\nPostStats AS (\n    SELECT \n        p.OwnerUserId,\n        COUNT(p.Id) AS PostCount,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        SUM(p.Score) AS TotalScore\n    FROM \n        Posts p\n    GROUP BY \n        p.OwnerUserId\n),\nUserPerformance AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COALESCE(ubs.BadgeCount, 0) AS BadgeCount,\n        COALESCE(ubs.GoldBadgeCount, 0) AS GoldBadgeCount,\n        COALESCE(ubs.SilverBadgeCount, 0) AS SilverBadgeCount,\n        COALESCE(ubs.BronzeBadgeCount, 0) AS BronzeBadgeCount,\n        COALESCE(ps.PostCount, 0) AS PostCount,\n        COALESCE(ps.QuestionCount, 0) AS QuestionCount,\n        COALESCE(ps.AnswerCount, 0) AS AnswerCount,\n        COALESCE(ps.TotalScore, 0) AS TotalScore\n    FROM \n        Users u\n    LEFT JOIN \n        UserBadgeStats ubs ON u.Id = ubs.UserId\n    LEFT JOIN \n        PostStats ps ON u.Id = ps.OwnerUserId\n)\nSELECT \n    UserId,\n    DisplayName,\n    BadgeCount,\n    GoldBadgeCount,\n    SilverBadgeCount,\n    BronzeBadgeCount,\n    PostCount,\n    QuestionCount,\n    AnswerCount,\n    TotalScore\nFROM \n    UserPerformance\nWHERE \n    TotalScore > 20 OR BadgeCount >= 5\nORDER BY \n    TotalScore DESC, BadgeCount DESC\nLIMIT 10;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    u.Id AS UserId,\n    u.DisplayName,\n    COALESCE(ubs.BadgeCount, 0) AS BadgeCount,\n    COALESCE(ubs.GoldBadgeCount, 0) AS GoldBadgeCount,\n    COALESCE(ubs.SilverBadgeCount, 0) AS SilverBadgeCount,\n    COALESCE(ubs.BronzeBadgeCount, 0) AS BronzeBadgeCount,\n    COALESCE(ps.PostCount, 0) AS PostCount,\n    COALESCE(ps.QuestionCount, 0) AS QuestionCount,\n    COALESCE(ps.AnswerCount, 0) AS AnswerCount,\n    COALESCE(ps.TotalScore, 0) AS TotalScore\nFROM Users u\nLEFT JOIN (\n    SELECT \n        b.UserId,\n        COUNT(b.Id) AS BadgeCount,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadgeCount,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadgeCount,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadgeCount\n    FROM Badges b\n    GROUP BY b.UserId\n) ubs ON u.Id = ubs.UserId\nLEFT JOIN (\n    SELECT \n        p.OwnerUserId,\n        COUNT(p.Id) AS PostCount,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        SUM(p.Score) AS TotalScore\n    FROM Posts p\n    GROUP BY p.OwnerUserId\n) ps ON u.Id = ps.OwnerUserId;", "sql2": "SELECT \n    UserId,\n    DisplayName,\n    BadgeCount,\n    GoldBadgeCount,\n    SilverBadgeCount,\n    BronzeBadgeCount,\n    PostCount,\n    QuestionCount,\n    AnswerCount,\n    TotalScore\nFROM s1\nWHERE TotalScore > 20 OR BadgeCount >= 5\nORDER BY TotalScore DESC, BadgeCount DESC\nLIMIT 10;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "8345.sql", "original_sql": "WITH UserBadges AS (\n    SELECT \n        u.Id AS UserId, \n        u.DisplayName, \n        COUNT(b.Id) AS BadgeCount,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Users u\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    GROUP BY \n        u.Id, u.DisplayName\n),\nPostStats AS (\n    SELECT \n        p.OwnerUserId, \n        COUNT(p.Id) AS TotalPosts,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS Answers,\n        SUM(p.Score) AS TotalScore,\n        SUM(p.ViewCount) AS TotalViews\n    FROM \n        Posts p\n    GROUP BY \n        p.OwnerUserId\n),\nCombinedStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COALESCE(pb.TotalPosts, 0) AS TotalPosts,\n        COALESCE(pb.Questions, 0) AS Questions,\n        COALESCE(pb.Answers, 0) AS Answers,\n        COALESCE(pb.TotalScore, 0) AS TotalScore,\n        COALESCE(pb.TotalViews, 0) AS TotalViews,\n        COALESCE(ub.BadgeCount, 0) AS BadgeCount,\n        COALESCE(ub.GoldBadges, 0) AS GoldBadges,\n        COALESCE(ub.SilverBadges, 0) AS SilverBadges,\n        COALESCE(ub.BronzeBadges, 0) AS BronzeBadges\n    FROM \n        Users u\n    LEFT JOIN \n        PostStats pb ON u.Id = pb.OwnerUserId\n    LEFT JOIN \n        UserBadges ub ON u.Id = ub.UserId\n)\nSELECT \n    UserId, \n    DisplayName, \n    TotalPosts, \n    Questions, \n    Answers, \n    TotalScore, \n    TotalViews,\n    BadgeCount,\n    GoldBadges,\n    SilverBadges,\n    BronzeBadges\nFROM \n    CombinedStats\nWHERE \n    TotalPosts > 0\nORDER BY \n    TotalScore DESC, \n    BadgeCount DESC\nLIMIT 10;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH UserBadges AS (\n    SELECT \n        u.Id AS UserId, \n        u.DisplayName, \n        COUNT(b.Id) AS BadgeCount,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Users u\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    GROUP BY \n        u.Id, u.DisplayName\n),\nPostStats AS (\n    SELECT \n        p.OwnerUserId, \n        COUNT(p.Id) AS TotalPosts,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS Answers,\n        SUM(p.Score) AS TotalScore,\n        SUM(p.ViewCount) AS TotalViews\n    FROM \n        Posts p\n    GROUP BY \n        p.OwnerUserId\n),\nCombinedStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COALESCE(pb.TotalPosts, 0) AS TotalPosts,\n        COALESCE(pb.Questions, 0) AS Questions,\n        COALESCE(pb.Answers, 0) AS Answers,\n        COALESCE(pb.TotalScore, 0) AS TotalScore,\n        COALESCE(pb.TotalViews, 0) AS TotalViews,\n        COALESCE(ub.BadgeCount, 0) AS BadgeCount,\n        COALESCE(ub.GoldBadges, 0) AS GoldBadges,\n        COALESCE(ub.SilverBadges, 0) AS SilverBadges,\n        COALESCE(ub.BronzeBadges, 0) AS BronzeBadges\n    FROM \n        Users u\n    LEFT JOIN \n        PostStats pb ON u.Id = pb.OwnerUserId\n    LEFT JOIN \n        UserBadges ub ON u.Id = ub.UserId\n)\nSELECT \n    UserId,\n    DisplayName,\n    TotalPosts,\n    Questions,\n    Answers,\n    TotalScore,\n    TotalViews,\n    BadgeCount,\n    GoldBadges,\n    SilverBadges,\n    BronzeBadges\nFROM CombinedStats;", "sql2": "SELECT \n    UserId,\n    DisplayName,\n    TotalPosts,\n    Questions,\n    Answers,\n    TotalScore,\n    TotalViews,\n    BadgeCount,\n    GoldBadges,\n    SilverBadges,\n    BronzeBadges\nFROM s1\nWHERE TotalPosts > 0\nORDER BY TotalScore DESC, BadgeCount DESC\nLIMIT 10;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "8377.sql", "original_sql": "\nWITH UserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        u.Reputation,\n        COUNT(p.Id) AS PostCount,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS Upvotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS Downvotes,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    GROUP BY \n        u.Id, u.DisplayName, u.Reputation\n),\nPostDetails AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        p.ViewCount,\n        p.Score,\n        u.DisplayName AS OwnerDisplayName,\n        pt.Name AS PostType,\n        COALESCE((\n            SELECT \n                COUNT(*) \n            FROM \n                Comments c \n            WHERE \n                c.PostId = p.Id\n        ), 0) AS CommentCount,\n        p.OwnerUserId\n    FROM \n        Posts p\n    JOIN \n        Users u ON p.OwnerUserId = u.Id\n    JOIN \n        PostTypes pt ON p.PostTypeId = pt.Id\n)\nSELECT \n    us.DisplayName,\n    us.Reputation,\n    us.PostCount,\n    us.QuestionCount,\n    us.AnswerCount,\n    us.Upvotes,\n    us.Downvotes,\n    us.GoldBadges,\n    us.SilverBadges,\n    us.BronzeBadges,\n    pd.PostId,\n    pd.Title,\n    pd.CreationDate,\n    pd.ViewCount,\n    pd.Score,\n    pd.OwnerDisplayName,\n    pd.PostType,\n    pd.CommentCount\nFROM \n    UserStats us\nJOIN \n    PostDetails pd ON us.UserId = pd.OwnerUserId\nORDER BY \n    us.Reputation DESC, pd.CreationDate DESC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT p.Id AS PostId,\n       p.Title,\n       p.CreationDate,\n       p.ViewCount,\n       p.Score,\n       u.DisplayName AS OwnerDisplayName,\n       pt.Name AS PostType,\n       COALESCE((SELECT COUNT(*) FROM Comments c WHERE c.PostId = p.Id),0) AS CommentCount,\n       p.OwnerUserId\nFROM Posts p\nJOIN Users u ON p.OwnerUserId = u.Id\nJOIN PostTypes pt ON p.PostTypeId = pt.Id;", "sql2": "SELECT us.DisplayName,\n       us.Reputation,\n       us.PostCount,\n       us.QuestionCount,\n       us.AnswerCount,\n       us.Upvotes,\n       us.Downvotes,\n       us.GoldBadges,\n       us.SilverBadges,\n       us.BronzeBadges,\n       s1.PostId,\n       s1.Title,\n       s1.CreationDate,\n       s1.ViewCount,\n       s1.Score,\n       s1.OwnerDisplayName,\n       s1.PostType,\n       s1.CommentCount\nFROM (\n    SELECT u.Id AS UserId,\n           u.DisplayName,\n           u.Reputation,\n           COUNT(p.Id) AS PostCount,\n           SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n           SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n           SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS Upvotes,\n           SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS Downvotes,\n           SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n           SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n           SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Users u\n    LEFT JOIN Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN Votes v ON p.Id = v.PostId\n    LEFT JOIN Badges b ON u.Id = b.UserId\n    GROUP BY u.Id, u.DisplayName, u.Reputation\n) us\nJOIN s1 ON us.UserId = s1.OwnerUserId\nORDER BY us.Reputation DESC, s1.CreationDate DESC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "84.sql", "original_sql": "WITH RankedPosts AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.Score,\n        u.DisplayName AS OwnerDisplayName,\n        p.CreationDate,\n        ROW_NUMBER() OVER (PARTITION BY p.PostTypeId ORDER BY p.CreationDate DESC) AS rn\n    FROM \n        Posts p\n    LEFT JOIN \n        Users u ON p.OwnerUserId = u.Id\n    WHERE \n        p.CreationDate >= cast('2024-10-01 12:34:56' as timestamp) - INTERVAL '1 year' \n        AND p.Score > 0\n),\nPostWithComments AS (\n    SELECT \n        rp.PostId,\n        rp.Title,\n        rp.Score,\n        rp.OwnerDisplayName,\n        rp.CreationDate,\n        COUNT(c.Id) AS CommentCount\n    FROM \n        RankedPosts rp\n    LEFT JOIN \n        Comments c ON rp.PostId = c.PostId\n    GROUP BY \n        rp.PostId, rp.Title, rp.Score, rp.OwnerDisplayName, rp.CreationDate\n),\nPostsWithScores AS (\n    SELECT \n        pwc.PostId,\n        pwc.Title,\n        pwc.Score,\n        pwc.OwnerDisplayName,\n        pwc.CreationDate,\n        pwc.CommentCount,\n        CASE \n            WHEN pwc.CommentCount > 10 THEN 'High Engagement'\n            WHEN pwc.CommentCount BETWEEN 1 AND 10 THEN 'Moderate Engagement'\n            ELSE 'No Engagement'\n        END AS EngagementLevel\n    FROM \n        PostWithComments pwc\n)\n\nSELECT \n    ps.PostId,\n    ps.Title,\n    ps.Score,\n    ps.OwnerDisplayName,\n    ps.CreationDate,\n    ps.CommentCount,\n    ps.EngagementLevel,\n    COALESCE(v.UpVotes, 0) AS UpVotes,\n    COALESCE(v.DownVotes, 0) AS DownVotes\nFROM \n    PostsWithScores ps\nLEFT JOIN \n    (SELECT \n        PostId, \n        SUM(CASE WHEN VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n     FROM \n        Votes \n     GROUP BY \n        PostId) v ON ps.PostId = v.PostId\nWHERE \n    ps.EngagementLevel <> 'No Engagement'\nORDER BY \n    ps.Score DESC, ps.CommentCount DESC\nLIMIT 50;", "has_cut": true, "q1_engine": "datafusion", "q2_engine": "duckdb", "sql1": "SELECT PostId,\n       SUM(CASE WHEN VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n       SUM(CASE WHEN VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\nFROM Votes\nGROUP BY PostId;", "sql2": "WITH RankedPosts AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.Score,\n        u.DisplayName AS OwnerDisplayName,\n        p.CreationDate,\n        ROW_NUMBER() OVER (PARTITION BY p.PostTypeId ORDER BY p.CreationDate DESC) AS rn\n    FROM Posts p\n    LEFT JOIN Users u ON p.OwnerUserId = u.Id\n    WHERE p.CreationDate >= CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '1 year'\n      AND p.Score > 0\n),\nPostWithComments AS (\n    SELECT \n        rp.PostId,\n        rp.Title,\n        rp.Score,\n        rp.OwnerDisplayName,\n        rp.CreationDate,\n        COUNT(c.Id) AS CommentCount\n    FROM RankedPosts rp\n    LEFT JOIN Comments c ON rp.PostId = c.PostId\n    GROUP BY rp.PostId, rp.Title, rp.Score, rp.OwnerDisplayName, rp.CreationDate\n),\nPostsWithScores AS (\n    SELECT \n        pwc.PostId,\n        pwc.Title,\n        pwc.Score,\n        pwc.OwnerDisplayName,\n        pwc.CreationDate,\n        pwc.CommentCount,\n        CASE \n            WHEN pwc.CommentCount > 10 THEN 'High Engagement'\n            WHEN pwc.CommentCount BETWEEN 1 AND 10 THEN 'Moderate Engagement'\n            ELSE 'No Engagement'\n        END AS EngagementLevel\n    FROM PostWithComments pwc\n)\nSELECT \n    ps.PostId,\n    ps.Title,\n    ps.Score,\n    ps.OwnerDisplayName,\n    ps.CreationDate,\n    ps.CommentCount,\n    ps.EngagementLevel,\n    COALESCE(s1.UpVotes, 0) AS UpVotes,\n    COALESCE(s1.DownVotes, 0) AS DownVotes\nFROM PostsWithScores ps\nLEFT JOIN s1 ON ps.PostId = s1.PostId\nWHERE ps.EngagementLevel <> 'No Engagement'\nORDER BY ps.Score DESC, ps.CommentCount DESC\nLIMIT 50;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "8487.sql", "original_sql": "WITH UserActivity AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(DISTINCT p.Id) AS PostCount,\n        SUM(vote_count) AS TotalVotes,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN p.AnswerCount ELSE 0 END) AS QuestionsAnswered,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswersGiven,\n        COUNT(DISTINCT ph.Id) AS PostEdits\n    FROM Users u\n    JOIN Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN (\n        SELECT \n            PostId, \n            COUNT(Id) AS vote_count \n        FROM Votes \n        GROUP BY PostId\n    ) v ON p.Id = v.PostId\n    LEFT JOIN PostHistory ph ON p.Id = ph.PostId\n    WHERE u.Reputation > 1000 \n    GROUP BY u.Id, u.DisplayName\n),\nPostSummary AS (\n    SELECT \n        pt.Name AS PostType,\n        COUNT(p.Id) AS PostCount,\n        AVG(p.Score) AS AverageScore,\n        SUM(p.ViewCount) AS TotalViews\n    FROM Posts p\n    JOIN PostTypes pt ON p.PostTypeId = pt.Id\n    WHERE p.CreationDate >= cast('2024-10-01 12:34:56' as timestamp) - INTERVAL '1 year'\n    GROUP BY pt.Name\n)\nSELECT \n    ua.DisplayName,\n    ua.PostCount,\n    ua.TotalVotes,\n    ua.QuestionsAnswered,\n    ua.AnswersGiven,\n    ua.PostEdits,\n    ps.PostType,\n    ps.PostCount AS TotalPostsOfType,\n    ps.AverageScore,\n    ps.TotalViews\nFROM UserActivity ua\nCROSS JOIN PostSummary ps\nORDER BY ua.TotalVotes DESC, ua.PostCount DESC, ps.TotalViews DESC\nLIMIT 100;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    u.Id AS UserId,\n    u.DisplayName,\n    COUNT(DISTINCT p.Id) AS PostCount,\n    SUM(v.vote_count) AS TotalVotes,\n    SUM(CASE WHEN p.PostTypeId = 1 THEN p.AnswerCount ELSE 0 END) AS QuestionsAnswered,\n    SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswersGiven,\n    COUNT(DISTINCT ph.Id) AS PostEdits\nFROM Users u\nJOIN Posts p ON u.Id = p.OwnerUserId\nLEFT JOIN (\n    SELECT PostId, COUNT(Id) AS vote_count\n    FROM Votes\n    GROUP BY PostId\n) v ON p.Id = v.PostId\nLEFT JOIN PostHistory ph ON p.Id = ph.PostId\nWHERE u.Reputation > 1000\nGROUP BY u.Id, u.DisplayName;", "sql2": "WITH PostSummary AS (\n    SELECT \n        pt.Name AS PostType,\n        COUNT(p.Id) AS PostCount,\n        AVG(p.Score) AS AverageScore,\n        SUM(p.ViewCount) AS TotalViews\n    FROM Posts p\n    JOIN PostTypes pt ON p.PostTypeId = pt.Id\n    WHERE p.CreationDate >= CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '1' YEAR\n    GROUP BY pt.Name\n)\nSELECT \n    ua.DisplayName,\n    ua.PostCount,\n    ua.TotalVotes,\n    ua.QuestionsAnswered,\n    ua.AnswersGiven,\n    ua.PostEdits,\n    ps.PostType,\n    ps.PostCount AS TotalPostsOfType,\n    ps.AverageScore,\n    ps.TotalViews\nFROM s1 ua\nCROSS JOIN PostSummary ps\nORDER BY ua.TotalVotes DESC, ua.PostCount DESC, ps.TotalViews DESC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "8731.sql", "original_sql": "WITH UserBadgeCounts AS (\n    SELECT \n        u.Id AS UserId,\n        COUNT(b.Id) AS BadgeCount\n    FROM \n        Users u\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    GROUP BY \n        u.Id\n),\nUserPostStats AS (\n    SELECT \n        p.OwnerUserId,\n        COUNT(p.Id) AS PostCount,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        SUM(p.ViewCount) AS TotalViews\n    FROM \n        Posts p\n    GROUP BY \n        p.OwnerUserId\n),\nPostHistoryStats AS (\n    SELECT \n        ph.UserId,\n        COUNT(ph.Id) AS EditCount,\n        SUM(CASE WHEN ph.PostHistoryTypeId IN (4, 5, 6) THEN 1 ELSE 0 END) AS TitleAndBodyEdits\n    FROM \n        PostHistory ph\n    GROUP BY \n        ph.UserId\n)\nSELECT \n    u.DisplayName,\n    u.Reputation,\n    ubc.BadgeCount,\n    ups.PostCount,\n    ups.QuestionCount,\n    ups.AnswerCount,\n    ups.TotalViews,\n    phs.EditCount,\n    phs.TitleAndBodyEdits\nFROM \n    Users u\nLEFT JOIN \n    UserBadgeCounts ubc ON u.Id = ubc.UserId\nLEFT JOIN \n    UserPostStats ups ON u.Id = ups.OwnerUserId\nLEFT JOIN \n    PostHistoryStats phs ON u.Id = phs.UserId\nWHERE \n    u.Reputation > 1000\nORDER BY \n    ubc.BadgeCount DESC, \n    ups.TotalViews DESC\nLIMIT 100;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "8735.sql", "original_sql": "\nWITH PostDetails AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate AS PostCreationDate,\n        p.OwnerUserId,\n        u.DisplayName AS OwnerDisplayName,\n        COUNT(CASE WHEN c.Id IS NOT NULL THEN 1 END) AS CommentCount,\n        COUNT(CASE WHEN a.Id IS NOT NULL THEN 1 END) AS AnswerCount,\n        COALESCE(SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END), 0) AS UpVotes,\n        COALESCE(SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END), 0) AS DownVotes\n    FROM \n        Posts p\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Posts a ON p.Id = a.ParentId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    INNER JOIN \n        Users u ON p.OwnerUserId = u.Id\n    WHERE \n        p.CreationDate >= '2023-01-01'\n    GROUP BY \n        p.Id, p.Title, p.CreationDate, p.OwnerUserId, u.DisplayName\n),\nPostHistorySummary AS (\n    SELECT \n        ph.PostId,\n        COUNT(CASE WHEN ph.PostHistoryTypeId = 10 THEN 1 END) AS CloseCount,\n        COUNT(CASE WHEN ph.PostHistoryTypeId = 11 THEN 1 END) AS ReopenCount,\n        COUNT(CASE WHEN ph.PostHistoryTypeId = 12 THEN 1 END) AS DeleteCount,\n        COUNT(CASE WHEN ph.PostHistoryTypeId = 13 THEN 1 END) AS UndeleteCount\n    FROM \n        PostHistory ph\n    GROUP BY \n        ph.PostId\n)\nSELECT \n    pd.PostId,\n    pd.Title,\n    pd.PostCreationDate,\n    pd.OwnerDisplayName,\n    pd.CommentCount,\n    pd.AnswerCount,\n    pd.UpVotes,\n    pd.DownVotes,\n    COALESCE(phs.CloseCount, 0) AS CloseCount,\n    COALESCE(phs.ReopenCount, 0) AS ReopenCount,\n    COALESCE(phs.DeleteCount, 0) AS DeleteCount,\n    COALESCE(phs.UndeleteCount, 0) AS UndeleteCount\nFROM \n    PostDetails pd\nLEFT JOIN \n    PostHistorySummary phs ON pd.PostId = phs.PostId\nORDER BY \n    pd.UpVotes DESC, pd.CommentCount DESC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'postid' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column phs.postid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"postid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"phs\" }), name: \"postid\" }, Column { relation: Some(Bare { table: \"phs\" }), name: \"closecount\" }, Column { relation: Some(Bare { table: \"phs\" }), name: \"reopencount\" }, Column { relation: Some(Bare { table: \"phs\" }), name: \"deletecount\" }, Column { relation: Some(Bare { table: \"phs\" }), name: \"undeletecount\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "8739.sql", "original_sql": "WITH UserPostStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(P.Id) AS PostCount,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        SUM(V.BountyAmount) AS TotalBounty,\n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUpVotes,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalDownVotes\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    LEFT JOIN \n        Votes V ON P.Id = V.PostId\n    WHERE \n        U.Reputation > 1000\n    GROUP BY \n        U.Id, U.DisplayName\n),\nUserBadges AS (\n    SELECT \n        B.UserId,\n        COUNT(B.Id) AS BadgeCount,\n        MAX(B.Class) AS HighestBadgeClass\n    FROM \n        Badges B\n    GROUP BY \n        B.UserId\n)\nSELECT \n    PS.UserId,\n    PS.DisplayName,\n    PS.PostCount,\n    PS.QuestionCount,\n    PS.AnswerCount,\n    PS.TotalBounty,\n    PS.TotalUpVotes,\n    PS.TotalDownVotes,\n    COALESCE(B.BadgeCount, 0) AS BadgeCount,\n    COALESCE(B.HighestBadgeClass, 0) AS HighestBadgeClass\nFROM \n    UserPostStats PS\nLEFT JOIN \n    UserBadges B ON PS.UserId = B.UserId\nORDER BY \n    PS.TotalUpVotes DESC, PS.PostCount DESC\nLIMIT 50;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 'ps'\", span: None, notes: [DiagnosticNote { message: \"possible column b.userid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"ps\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"ps\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"b\" }), name: \"userid\" }, Column { relation: Some(Bare { table: \"b\" }), name: \"badgecount\" }, Column { relation: Some(Bare { table: \"b\" }), name: \"highestbadgeclass\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "8878.sql", "original_sql": "WITH UserVotes AS (\n    SELECT V.UserId, \n           COUNT(CASE WHEN V.VoteTypeId = 2 THEN 1 END) AS UpVotes, \n           COUNT(CASE WHEN V.VoteTypeId = 3 THEN 1 END) AS DownVotes\n    FROM Votes V\n    GROUP BY V.UserId\n),\nPostStats AS (\n    SELECT P.OwnerUserId, \n           COUNT(P.Id) AS TotalPosts, \n           SUM(P.Score) AS TotalScore, \n           SUM(P.ViewCount) AS TotalViews\n    FROM Posts P\n    GROUP BY P.OwnerUserId\n),\nUserPostDetails AS (\n    SELECT U.Id AS UserId, \n           U.DisplayName, \n           COALESCE(UV.UpVotes, 0) AS UpVotes, \n           COALESCE(UV.DownVotes, 0) AS DownVotes, \n           COALESCE(PS.TotalPosts, 0) AS TotalPosts, \n           COALESCE(PS.TotalScore, 0) AS TotalScore, \n           COALESCE(PS.TotalViews, 0) AS TotalViews\n    FROM Users U\n    LEFT JOIN UserVotes UV ON U.Id = UV.UserId\n    LEFT JOIN PostStats PS ON U.Id = PS.OwnerUserId\n)\nSELECT U.DisplayName, \n       U.UpVotes, \n       U.DownVotes, \n       U.TotalPosts, \n       U.TotalScore, \n       U.TotalViews\nFROM UserPostDetails U\nWHERE U.TotalPosts > 0\nORDER BY U.TotalScore DESC, U.TotalViews DESC\nLIMIT 10;\n", "has_cut": false, "engine_mem_mb": 500000, "llm_raw": {"has_cut": false}}
{"query_id": "8887.sql", "original_sql": "\nWITH UserActivity AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(DISTINCT P.Id) AS TotalPosts,\n        COUNT(DISTINCT C.Id) AS TotalComments,\n        SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) AS TotalUpVotes,\n        SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS TotalDownVotes,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Users U\n    LEFT JOIN Posts P ON U.Id = P.OwnerUserId\n    LEFT JOIN Comments C ON P.Id = C.PostId\n    LEFT JOIN Votes V ON P.Id = V.PostId AND V.UserId = U.Id\n    LEFT JOIN Badges B ON U.Id = B.UserId\n    GROUP BY U.Id, U.DisplayName\n),\nPostStatistics AS (\n    SELECT \n        P.OwnerUserId,\n        COUNT(CASE WHEN P.PostTypeId = 1 THEN 1 END) AS Questions,\n        COUNT(CASE WHEN P.PostTypeId = 2 THEN 1 END) AS Answers,\n        AVG(P.Score) AS AverageScore,\n        SUM(P.ViewCount) AS TotalViews,\n        COUNT(DISTINCT P.Tags) AS UniqueTags\n    FROM Posts P\n    GROUP BY P.OwnerUserId\n),\nCombinedStats AS (\n    SELECT \n        UA.UserId,\n        UA.DisplayName,\n        UA.TotalPosts,\n        UA.TotalComments,\n        UA.TotalUpVotes,\n        UA.TotalDownVotes,\n        UA.GoldBadges,\n        UA.SilverBadges,\n        UA.BronzeBadges,\n        PS.Questions,\n        PS.Answers,\n        PS.AverageScore,\n        PS.TotalViews,\n        PS.UniqueTags\n    FROM UserActivity UA\n    LEFT JOIN PostStatistics PS ON UA.UserId = PS.OwnerUserId\n)\nSELECT * \nFROM CombinedStats\nORDER BY TotalPosts DESC, TotalUpVotes DESC, AverageScore DESC\nLIMIT 100;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 191, in _run_single_node\n    out_tbl = self._run_on_datafusion(node)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 108, in _run_on_datafusion\n    df = self.ctx.sql(node.sql)\n         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/miniconda3/envs/flexdata/lib/python3.12/site-packages/datafusion/context.py\", line 611, in sql\n    return DataFrame(self.ctx.sql(query))\n                     ^^^^^^^^^^^^^^^^^^^\nException: DataFusion error: Diagnostic(Diagnostic { kind: Error, message: \"column 'userid' not found in 's1'\", span: None, notes: [DiagnosticNote { message: \"possible column ps.owneruserid\", span: None }], helps: [] }, SchemaError(FieldNotFound { field: Column { relation: Some(Bare { table: \"s1\" }), name: \"userid\" }, valid_fields: [Column { relation: Some(Bare { table: \"s1\" }), name: \"count\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"owneruserid\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"questions\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"answers\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"averagescore\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"totalviews\" }, Column { relation: Some(Bare { table: \"ps\" }), name: \"uniquetags\" }] }, Some(\"\")))\n", "engine_mem_mb": 500000}
{"query_id": "8954.sql", "original_sql": "WITH UserBadgeStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(b.Id) AS BadgeCount,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Users u\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    GROUP BY \n        u.Id, u.DisplayName\n),\nPostStats AS (\n    SELECT \n        p.OwnerUserId,\n        COUNT(p.Id) AS PostCount,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        SUM(CASE WHEN p.PostTypeId = 3 THEN 1 ELSE 0 END) AS WikiCount,\n        SUM(p.Score) AS TotalScore,\n        AVG(p.ViewCount) AS AvgViewCount\n    FROM \n        Posts p\n    GROUP BY \n        p.OwnerUserId\n),\nFinalStats AS (\n    SELECT \n        u.DisplayName,\n        u.Reputation,\n        u.LastAccessDate,\n        u.Views,\n        u.UpVotes,\n        u.DownVotes,\n        ubs.BadgeCount,\n        ubs.GoldBadges,\n        ubs.SilverBadges,\n        ubs.BronzeBadges,\n        ps.PostCount,\n        ps.QuestionCount,\n        ps.AnswerCount,\n        ps.WikiCount,\n        ps.TotalScore,\n        ps.AvgViewCount\n    FROM \n        Users u\n    JOIN \n        UserBadgeStats ubs ON u.Id = ubs.UserId\n    LEFT JOIN \n        PostStats ps ON u.Id = ps.OwnerUserId\n    WHERE \n        u.Reputation > 100 AND\n        u.LastAccessDate > cast('2024-10-01 12:34:56' as timestamp) - INTERVAL '1 year'\n)\nSELECT \n    DisplayName,\n    Reputation,\n    LastAccessDate,\n    (Views + UpVotes - DownVotes) AS EngagementScore,\n    BadgeCount,\n    GoldBadges,\n    SilverBadges,\n    BronzeBadges,\n    PostCount,\n    QuestionCount,\n    AnswerCount,\n    WikiCount,\n    TotalScore,\n    AvgViewCount\nFROM \n    FinalStats\nORDER BY \n    EngagementScore DESC, Reputation DESC\nLIMIT 100;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH UserBadgeStats AS (\n    SELECT \n        u.Id AS UserId,\n        COUNT(b.Id) AS BadgeCount,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Users u\n    LEFT JOIN Badges b ON u.Id = b.UserId\n    GROUP BY u.Id\n),\nPostStats AS (\n    SELECT \n        p.OwnerUserId,\n        COUNT(p.Id) AS PostCount,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        SUM(CASE WHEN p.PostTypeId = 3 THEN 1 ELSE 0 END) AS WikiCount,\n        SUM(p.Score) AS TotalScore,\n        AVG(p.ViewCount) AS AvgViewCount\n    FROM Posts p\n    GROUP BY p.OwnerUserId\n)\nSELECT \n    u.DisplayName,\n    u.Reputation,\n    u.LastAccessDate,\n    u.Views,\n    u.UpVotes,\n    u.DownVotes,\n    ubs.BadgeCount,\n    ubs.GoldBadges,\n    ubs.SilverBadges,\n    ubs.BronzeBadges,\n    ps.PostCount,\n    ps.QuestionCount,\n    ps.AnswerCount,\n    ps.WikiCount,\n    ps.TotalScore,\n    ps.AvgViewCount\nFROM Users u\nJOIN UserBadgeStats ubs ON u.Id = ubs.UserId\nLEFT JOIN PostStats ps ON u.Id = ps.OwnerUserId\nWHERE u.Reputation > 100\n  AND u.LastAccessDate > CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '1 year';", "sql2": "SELECT \n    DisplayName,\n    Reputation,\n    LastAccessDate,\n    (Views + UpVotes - DownVotes) AS EngagementScore,\n    BadgeCount,\n    GoldBadges,\n    SilverBadges,\n    BronzeBadges,\n    PostCount,\n    QuestionCount,\n    AnswerCount,\n    WikiCount,\n    TotalScore,\n    AvgViewCount\nFROM s1\nORDER BY EngagementScore DESC, Reputation DESC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "9100.sql", "original_sql": "WITH UserBadges AS (\n    SELECT UserId, COUNT(*) AS TotalBadges\n    FROM Badges\n    GROUP BY UserId\n),\nTopUsers AS (\n    SELECT U.Id, U.DisplayName, U.Reputation, UB.TotalBadges\n    FROM Users U\n    LEFT JOIN UserBadges UB ON U.Id = UB.UserId\n    ORDER BY U.Reputation DESC, UB.TotalBadges DESC\n    LIMIT 10\n),\nPostStatistics AS (\n    SELECT P.OwnerUserId, COUNT(P.Id) AS TotalPosts, \n           SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n           SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers,\n           SUM(P.ViewCount) AS TotalViews\n    FROM Posts P\n    GROUP BY P.OwnerUserId\n),\nUserPostStats AS (\n    SELECT U.Id, U.DisplayName, PS.TotalPosts, PS.TotalQuestions, PS.TotalAnswers, PS.TotalViews\n    FROM Users U\n    JOIN PostStatistics PS ON U.Id = PS.OwnerUserId\n    WHERE U.Id IN (SELECT Id FROM TopUsers)\n)\nSELECT U.DisplayName, U.Reputation, U.TotalBadges,\n       UPS.TotalPosts, UPS.TotalQuestions, UPS.TotalAnswers, UPS.TotalViews\nFROM UserBadges UB\nJOIN UserPostStats UPS ON UB.UserId = UPS.Id\nJOIN TopUsers U ON U.Id = UPS.Id\nORDER BY U.Reputation DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH UserBadges AS (\n    SELECT UserId, COUNT(*) AS TotalBadges\n    FROM Badges\n    GROUP BY UserId\n),\nTopUsers AS (\n    SELECT U.Id,\n           U.DisplayName,\n           U.Reputation,\n           COALESCE(UB.TotalBadges, 0) AS TotalBadges\n    FROM Users U\n    LEFT JOIN UserBadges UB ON U.Id = UB.UserId\n    ORDER BY U.Reputation DESC, COALESCE(UB.TotalBadges, 0) DESC\n    LIMIT 10\n)\nSELECT Id,\n       DisplayName,\n       Reputation,\n       TotalBadges\nFROM TopUsers;", "sql2": "WITH PostStatistics AS (\n    SELECT OwnerUserId AS UserId,\n           COUNT(Id) AS TotalPosts,\n           SUM(CASE WHEN PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n           SUM(CASE WHEN PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers,\n           SUM(ViewCount) AS TotalViews\n    FROM Posts\n    GROUP BY OwnerUserId\n)\nSELECT s1.DisplayName,\n       s1.Reputation,\n       s1.TotalBadges,\n       COALESCE(ps.TotalPosts, 0) AS TotalPosts,\n       COALESCE(ps.TotalQuestions, 0) AS TotalQuestions,\n       COALESCE(ps.TotalAnswers, 0) AS TotalAnswers,\n       COALESCE(ps.TotalViews, 0) AS TotalViews\nFROM s1\nLEFT JOIN PostStatistics ps ON s1.Id = ps.UserId\nORDER BY s1.Reputation DESC;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "9110.sql", "original_sql": "\nWITH UserStats AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(DISTINCT p.Id) AS PostCount,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    GROUP BY \n        u.Id, u.DisplayName\n),\nBadgeCounts AS (\n    SELECT \n        b.UserId, \n        COUNT(b.Id) AS BadgeCount,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Badges b\n    GROUP BY \n        b.UserId\n)\nSELECT \n    us.UserId,\n    us.DisplayName,\n    us.PostCount,\n    us.QuestionCount,\n    us.AnswerCount,\n    COALESCE(bc.BadgeCount, 0) AS TotalBadges,\n    COALESCE(bc.GoldBadges, 0) AS GoldBadges,\n    COALESCE(bc.SilverBadges, 0) AS SilverBadges,\n    COALESCE(bc.BronzeBadges, 0) AS BronzeBadges,\n    us.UpVotes,\n    us.DownVotes\nFROM \n    UserStats us\nLEFT JOIN \n    BadgeCounts bc ON us.UserId = bc.UserId\nWHERE \n    us.PostCount > 10\nORDER BY \n    us.UpVotes DESC, us.DownVotes ASC\nLIMIT 100;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT u.Id AS UserId,\n       u.DisplayName,\n       COUNT(DISTINCT p.Id) AS PostCount,\n       SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS QuestionCount,\n       SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS AnswerCount,\n       SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n       SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\nFROM Users u\nLEFT JOIN Posts p ON u.Id = p.OwnerUserId\nLEFT JOIN Votes v ON p.Id = v.PostId\nGROUP BY u.Id, u.DisplayName;", "sql2": "SELECT us.UserId,\n       us.DisplayName,\n       us.PostCount,\n       us.QuestionCount,\n       us.AnswerCount,\n       COALESCE(bc.BadgeCount, 0) AS TotalBadges,\n       COALESCE(bc.GoldBadges, 0) AS GoldBadges,\n       COALESCE(bc.SilverBadges, 0) AS SilverBadges,\n       COALESCE(bc.BronzeBadges, 0) AS BronzeBadges,\n       us.UpVotes,\n       us.DownVotes\nFROM s1 us\nLEFT JOIN (\n    SELECT b.UserId,\n           COUNT(b.Id) AS BadgeCount,\n           SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n           SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n           SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Badges b\n    GROUP BY b.UserId\n) bc ON us.UserId = bc.UserId\nWHERE us.PostCount > 10\nORDER BY us.UpVotes DESC, us.DownVotes ASC\nLIMIT 100;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "9137.sql", "original_sql": "\nWITH UserBadgeStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(B.Id) AS TotalBadges,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Users U\n    LEFT JOIN \n        Badges B ON U.Id = B.UserId\n    GROUP BY \n        U.Id, U.DisplayName\n),\nPostStats AS (\n    SELECT \n        P.OwnerUserId,\n        COUNT(P.Id) AS TotalPosts,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers,\n        SUM(CASE WHEN P.PostTypeId = 4 THEN 1 ELSE 0 END) AS TotalTagWikis,\n        SUM(CASE WHEN P.Score > 0 THEN 1 ELSE 0 END) AS PositivePosts\n    FROM \n        Posts P\n    GROUP BY \n        P.OwnerUserId\n),\nActivityStats AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COALESCE(UB.TotalBadges, 0) AS TotalBadges,\n        COALESCE(PS.TotalPosts, 0) AS TotalPosts,\n        COALESCE(PS.TotalQuestions, 0) AS TotalQuestions,\n        COALESCE(PS.TotalAnswers, 0) AS TotalAnswers,\n        COALESCE(PS.TotalTagWikis, 0) AS TotalTagWikis,\n        COALESCE(PS.PositivePosts, 0) AS PositivePosts,\n        CASE \n            WHEN COALESCE(UB.TotalBadges, 0) > 10 THEN 'Active Contributor'\n            WHEN COALESCE(PS.TotalPosts, 0) > 100 THEN 'Veteran' \n            ELSE 'New Contributor' \n        END AS ContributorStatus\n    FROM \n        Users U\n    LEFT JOIN \n        UserBadgeStats UB ON U.Id = UB.UserId\n    LEFT JOIN \n        PostStats PS ON U.Id = PS.OwnerUserId\n)\nSELECT \n    UserId, \n    DisplayName, \n    TotalBadges, \n    TotalPosts, \n    TotalQuestions, \n    TotalAnswers, \n    TotalTagWikis, \n    PositivePosts, \n    ContributorStatus\nFROM \n    ActivityStats\nWHERE \n    TotalPosts > 0\nORDER BY \n    TotalPosts DESC, \n    TotalBadges DESC\nLIMIT 50;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 178, in _run_single_node\n    out_tbl = self._run_on_duckdb(node.sql)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 104, in _run_on_duckdb\n    return self.con.execute(sql).arrow()\n           ^^^^^^^^^^^^^^^^^^^^^\nduckdb.duckdb.Error: ArrowNotImplementedError: Function 'and_kleene' has no kernel matching input types (bool, null)\n\nAt:\n  pyarrow/error.pxi(91): pyarrow.lib.check_status\n\n", "engine_mem_mb": 500000}
{"query_id": "9142.sql", "original_sql": "WITH UserBadges AS (\n    SELECT \n        u.Id AS UserId,\n        COUNT(b.Id) AS TotalBadges,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Users u\n    LEFT JOIN \n        Badges b ON u.Id = b.UserId\n    GROUP BY \n        u.Id\n),\nPostStats AS (\n    SELECT \n        p.OwnerUserId,\n        COUNT(p.Id) AS TotalPosts,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS Answers,\n        SUM(p.ViewCount) AS TotalViews,\n        SUM(p.Score) AS TotalScore\n    FROM \n        Posts p\n    WHERE \n        p.CreationDate >= cast('2024-10-01 12:34:56' as timestamp) - INTERVAL '1 year'\n    GROUP BY \n        p.OwnerUserId\n),\nCombinedStats AS (\n    SELECT \n        ub.UserId,\n        ub.TotalBadges,\n        ub.GoldBadges,\n        ub.SilverBadges,\n        ub.BronzeBadges,\n        ps.TotalPosts,\n        ps.Questions,\n        ps.Answers,\n        ps.TotalViews,\n        ps.TotalScore\n    FROM \n        UserBadges ub\n    LEFT JOIN \n        PostStats ps ON ub.UserId = ps.OwnerUserId\n)\nSELECT \n    u.DisplayName, \n    cs.TotalBadges,\n    cs.GoldBadges, \n    cs.SilverBadges,\n    cs.BronzeBadges,\n    cs.TotalPosts, \n    cs.Questions, \n    cs.Answers, \n    cs.TotalViews, \n    cs.TotalScore\nFROM \n    CombinedStats cs\nJOIN \n    Users u ON cs.UserId = u.Id\nWHERE \n    cs.TotalPosts > 5\nORDER BY \n    cs.TotalScore DESC, \n    cs.TotalBadges DESC\nLIMIT 10;", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT\n    p.OwnerUserId AS UserId,\n    COUNT(p.Id) AS TotalPosts,\n    SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions,\n    SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS Answers,\n    SUM(p.ViewCount) AS TotalViews,\n    SUM(p.Score) AS TotalScore\nFROM Posts p\nWHERE p.CreationDate >= CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '1 year'\nGROUP BY p.OwnerUserId;", "sql2": "WITH UserBadges AS (\n    SELECT \n        u.Id AS UserId,\n        COUNT(b.Id) AS TotalBadges,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Users u\n    LEFT JOIN Badges b ON u.Id = b.UserId\n    GROUP BY u.Id\n)\nSELECT \n    u.DisplayName,\n    ub.TotalBadges,\n    ub.GoldBadges,\n    ub.SilverBadges,\n    ub.BronzeBadges,\n    ps.TotalPosts,\n    ps.Questions,\n    ps.Answers,\n    ps.TotalViews,\n    ps.TotalScore\nFROM UserBadges ub\nLEFT JOIN s1 ps ON ub.UserId = ps.UserId\nJOIN Users u ON ub.UserId = u.Id\nWHERE ps.TotalPosts > 5\nORDER BY ps.TotalScore DESC, ub.TotalBadges DESC\nLIMIT 10;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "9175.sql", "original_sql": "\nWITH UserActivity AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(DISTINCT P.Id) AS PostCount,\n        SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions,\n        SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS Answers,\n        SUM(CASE WHEN P.PostTypeId IN (10, 11) THEN 1 ELSE 0 END) AS ClosedPosts,\n        AVG(U.Reputation) AS AvgReputation,\n        SUM(COALESCE(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END, 0)) AS UpVotes,\n        SUM(COALESCE(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END, 0)) AS DownVotes\n    FROM \n        Users U\n    LEFT JOIN \n        Posts P ON U.Id = P.OwnerUserId\n    LEFT JOIN \n        Votes V ON P.Id = V.PostId\n    WHERE \n        U.CreationDate < CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '1 year'\n    GROUP BY \n        U.Id, U.DisplayName\n),\nTopUsers AS (\n    SELECT \n        UserId,\n        DisplayName,\n        PostCount,\n        Questions,\n        Answers,\n        ClosedPosts,\n        AvgReputation,\n        UpVotes - DownVotes AS NetVotes\n    FROM \n        UserActivity\n    WHERE \n        PostCount > 5\n    ORDER BY \n        NetVotes DESC, AvgReputation DESC\n    LIMIT 10\n)\nSELECT \n    U.UserId,\n    U.DisplayName,\n    U.PostCount,\n    U.Questions,\n    U.Answers,\n    U.ClosedPosts,\n    U.AvgReputation,\n    U.NetVotes,\n    BH.Name AS BadgeName,\n    BH.Class\nFROM \n    TopUsers U\nLEFT JOIN \n    Badges BH ON U.UserId = BH.UserId\nORDER BY \n    U.NetVotes DESC, U.AvgReputation DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    U.Id AS UserId,\n    U.DisplayName,\n    COUNT(DISTINCT P.Id) AS PostCount,\n    SUM(CASE WHEN P.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions,\n    SUM(CASE WHEN P.PostTypeId = 2 THEN 1 ELSE 0 END) AS Answers,\n    SUM(CASE WHEN P.PostTypeId IN (10, 11) THEN 1 ELSE 0 END) AS ClosedPosts,\n    AVG(U.Reputation) AS AvgReputation,\n    SUM(CASE WHEN V.VoteTypeId = 2 THEN 1 ELSE 0 END) -\n    SUM(CASE WHEN V.VoteTypeId = 3 THEN 1 ELSE 0 END) AS NetVotes\nFROM Users U\nLEFT JOIN Posts P ON U.Id = P.OwnerUserId\nLEFT JOIN Votes V ON P.Id = V.PostId\nWHERE U.CreationDate < CAST('2024-10-01 12:34:56' AS TIMESTAMP) - INTERVAL '1 year'\nGROUP BY U.Id, U.DisplayName\nHAVING COUNT(DISTINCT P.Id) > 5\nORDER BY NetVotes DESC, AvgReputation DESC\nLIMIT 10;", "sql2": "SELECT \n    s1.UserId,\n    s1.DisplayName,\n    s1.PostCount,\n    s1.Questions,\n    s1.Answers,\n    s1.ClosedPosts,\n    s1.AvgReputation,\n    s1.NetVotes,\n    BH.Name AS BadgeName,\n    BH.Class\nFROM s1\nLEFT JOIN Badges BH ON s1.UserId = BH.UserId\nORDER BY s1.NetVotes DESC, s1.AvgReputation DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "919.sql", "original_sql": "\nWITH UserBadgeCounts AS (\n    SELECT \n        U.Id AS UserId, \n        U.DisplayName,\n        COUNT(B.Id) AS TotalBadges,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Users U\n    LEFT JOIN \n        Badges B ON U.Id = B.UserId\n    GROUP BY \n        U.Id, U.DisplayName\n),\nPostStatistics AS (\n    SELECT \n        P.OwnerUserId,\n        COUNT(CASE WHEN P.PostTypeId = 1 THEN 1 END) AS QuestionCount,\n        COUNT(CASE WHEN P.PostTypeId = 2 THEN 1 END) AS AnswerCount,\n        COALESCE(SUM(P.ViewCount), 0) AS TotalViews,\n        COALESCE(AVG(P.Score), 0) AS AvgScore\n    FROM \n        Posts P\n    GROUP BY \n        P.OwnerUserId\n),\nUserPerformance AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COALESCE(UBC.TotalBadges, 0) AS BadgeCount,\n        COALESCE(PS.QuestionCount, 0) AS QuestionCount,\n        COALESCE(PS.AnswerCount, 0) AS AnswerCount,\n        COALESCE(PS.TotalViews, 0) AS TotalViews,\n        COALESCE(PS.AvgScore, 0) AS AvgScore\n    FROM \n        Users U\n    LEFT JOIN \n        UserBadgeCounts UBC ON U.Id = UBC.UserId\n    LEFT JOIN \n        PostStatistics PS ON U.Id = PS.OwnerUserId\n),\nHighestPerformingUsers AS (\n    SELECT \n        UserId,\n        DisplayName,\n        AVG(TotalViews) + SUM(BadgeCount) AS PerformanceScore\n    FROM \n        UserPerformance\n    GROUP BY \n        UserId, DisplayName\n    ORDER BY \n        PerformanceScore DESC\n    LIMIT 10\n)\nSELECT \n    U.UserId,\n    U.DisplayName,\n    U.BadgeCount,\n    U.QuestionCount,\n    U.AnswerCount,\n    U.TotalViews,\n    U.AvgScore,\n    HP.PerformanceScore\nFROM \n    UserPerformance U\nJOIN \n    HighestPerformingUsers HP ON U.UserId = HP.UserId\nWHERE \n    U.QuestionCount > 10\n    AND (U.AnswerCount > 5 OR U.BadgeCount > 5)\nORDER BY \n    U.AvgScore DESC, U.TotalViews DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    U.Id AS UserId,\n    U.DisplayName,\n    COALESCE(UBC.TotalBadges, 0) AS BadgeCount,\n    COALESCE(PS.QuestionCount, 0) AS QuestionCount,\n    COALESCE(PS.AnswerCount, 0) AS AnswerCount,\n    COALESCE(PS.TotalViews, 0) AS TotalViews,\n    COALESCE(PS.AvgScore, 0) AS AvgScore\nFROM Users U\nLEFT JOIN (\n    SELECT \n        B.UserId,\n        COUNT(*) AS TotalBadges,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM Badges B\n    GROUP BY B.UserId\n) UBC ON U.Id = UBC.UserId\nLEFT JOIN (\n    SELECT \n        P.OwnerUserId,\n        COUNT(CASE WHEN P.PostTypeId = 1 THEN 1 END) AS QuestionCount,\n        COUNT(CASE WHEN P.PostTypeId = 2 THEN 1 END) AS AnswerCount,\n        COALESCE(SUM(P.ViewCount), 0) AS TotalViews,\n        COALESCE(AVG(P.Score), 0) AS AvgScore\n    FROM Posts P\n    GROUP BY P.OwnerUserId\n) PS ON U.Id = PS.OwnerUserId;", "sql2": "WITH HighestPerformingUsers AS (\n    SELECT \n        UserId,\n        DisplayName,\n        (TotalViews + BadgeCount) AS PerformanceScore\n    FROM s1\n    ORDER BY PerformanceScore DESC\n    LIMIT 10\n)\nSELECT \n    s1.UserId,\n    s1.DisplayName,\n    s1.BadgeCount,\n    s1.QuestionCount,\n    s1.AnswerCount,\n    s1.TotalViews,\n    s1.AvgScore,\n    hp.PerformanceScore\nFROM s1\nJOIN HighestPerformingUsers hp ON s1.UserId = hp.UserId\nWHERE s1.QuestionCount > 10\n  AND (s1.AnswerCount > 5 OR s1.BadgeCount > 5)\nORDER BY s1.AvgScore DESC, s1.TotalViews DESC;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "925.sql", "original_sql": "\nWITH UserBadges AS (\n    SELECT \n        UserId, \n        COUNT(CASE WHEN Class = 1 THEN 1 END) AS GoldBadges,\n        COUNT(CASE WHEN Class = 2 THEN 1 END) AS SilverBadges,\n        COUNT(CASE WHEN Class = 3 THEN 1 END) AS BronzeBadges\n    FROM Badges\n    GROUP BY UserId\n),\nPostStatistics AS (\n    SELECT \n        p.OwnerUserId,\n        COUNT(CASE WHEN p.PostTypeId = 1 THEN 1 END) AS QuestionCount,\n        COUNT(CASE WHEN p.PostTypeId = 2 THEN 1 END) AS AnswerCount,\n        SUM(p.Score) AS TotalScore,\n        SUM(p.ViewCount) AS TotalViews\n    FROM Posts p\n    LEFT JOIN Users u ON p.OwnerUserId = u.Id\n    WHERE u.Reputation > 1000\n    GROUP BY p.OwnerUserId\n),\nRecentActivity AS (\n    SELECT \n        p.OwnerUserId,\n        MAX(p.LastActivityDate) AS LastActivityDate\n    FROM Posts p\n    GROUP BY p.OwnerUserId\n)\nSELECT \n    u.DisplayName,\n    COALESCE(ub.GoldBadges, 0) AS GoldBadges,\n    COALESCE(ub.SilverBadges, 0) AS SilverBadges,\n    COALESCE(ub.BronzeBadges, 0) AS BronzeBadges,\n    ps.QuestionCount, \n    ps.AnswerCount,\n    ps.TotalScore,\n    ps.TotalViews,\n    ra.LastActivityDate\nFROM Users u\nLEFT JOIN UserBadges ub ON u.Id = ub.UserId\nLEFT JOIN PostStatistics ps ON u.Id = ps.OwnerUserId\nLEFT JOIN RecentActivity ra ON u.Id = ra.OwnerUserId\nWHERE (ps.QuestionCount > 5 OR ps.AnswerCount > 10)\nAND ra.LastActivityDate > CURRENT_DATE - INTERVAL '6 months'\nORDER BY ps.TotalScore DESC, u.DisplayName ASC;\n", "status": "error", "traceback": "Traceback (most recent call last):\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 393, in _child_run_one_query\n    primary_result = _run_distributed_for_engines(q1_engine, q2_engine)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/run_proofOfConcept_paper.py\", line 344, in _run_distributed_for_engines\n    df_row = benchmark_distributed_only(\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/runner/benchmark.py\", line 124, in benchmark_distributed_only\n    distributed_results = runner.run(subqueries)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 226, in run\n    tbl, elapsed = self._run_single_node(node)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 178, in _run_single_node\n    out_tbl = self._run_on_duckdb(node.sql)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/u/sba/flexdata-distributed-execution-bis/python/distributed_executor/distributed_runner.py\", line 104, in _run_on_duckdb\n    return self.con.execute(sql).arrow()\n           ^^^^^^^^^^^^^^^^^^^^^\nduckdb.duckdb.ParserException: Parser Error: SELECT INTO not supported!\n", "engine_mem_mb": 500000}
{"query_id": "9412.sql", "original_sql": "WITH UserBadgeCounts AS (\n    SELECT \n        u.Id AS UserId, \n        u.DisplayName, \n        COUNT(b.Id) AS BadgeCount, \n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldCount,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverCount,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeCount\n    FROM \n        Users u \n    LEFT JOIN \n        Badges b ON u.Id = b.UserId \n    GROUP BY \n        u.Id, u.DisplayName\n), UserPostStats AS (\n    SELECT \n        p.OwnerUserId,\n        COUNT(p.Id) AS PostCount,\n        COUNT(CASE WHEN p.PostTypeId = 1 THEN 1 END) AS QuestionCount,\n        COUNT(CASE WHEN p.PostTypeId = 2 THEN 1 END) AS AnswerCount,\n        SUM(p.Score) AS TotalScore,\n        AVG(p.ViewCount) AS AvgViewCount\n    FROM \n        Posts p\n    GROUP BY \n        p.OwnerUserId\n), CombinedStats AS (\n    SELECT \n        ubc.UserId,\n        ubc.DisplayName,\n        ubc.BadgeCount,\n        ubc.GoldCount,\n        ubc.SilverCount,\n        ubc.BronzeCount,\n        ups.PostCount,\n        ups.QuestionCount,\n        ups.AnswerCount,\n        ups.TotalScore,\n        ups.AvgViewCount\n    FROM \n        UserBadgeCounts ubc\n    JOIN \n        UserPostStats ups ON ubc.UserId = ups.OwnerUserId\n)\nSELECT \n    DisplayName,\n    BadgeCount,\n    GoldCount,\n    SilverCount,\n    BronzeCount,\n    PostCount,\n    QuestionCount,\n    AnswerCount,\n    TotalScore,\n    AvgViewCount\nFROM \n    CombinedStats\nWHERE \n    BadgeCount > 0 \nORDER BY \n    TotalScore DESC, BadgeCount DESC\nLIMIT 10;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    u.Id AS UserId,\n    u.DisplayName,\n    COUNT(b.Id) AS BadgeCount,\n    SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldCount,\n    SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverCount,\n    SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeCount\nFROM Users u\nLEFT JOIN Badges b ON u.Id = b.UserId\nGROUP BY u.Id, u.DisplayName;", "sql2": "SELECT \n    s1.DisplayName,\n    s1.BadgeCount,\n    s1.GoldCount,\n    s1.SilverCount,\n    s1.BronzeCount,\n    ups.PostCount,\n    ups.QuestionCount,\n    ups.AnswerCount,\n    ups.TotalScore,\n    ups.AvgViewCount\nFROM (\n    SELECT \n        p.OwnerUserId,\n        COUNT(p.Id) AS PostCount,\n        COUNT(CASE WHEN p.PostTypeId = 1 THEN 1 END) AS QuestionCount,\n        COUNT(CASE WHEN p.PostTypeId = 2 THEN 1 END) AS AnswerCount,\n        SUM(p.Score) AS TotalScore,\n        AVG(p.ViewCount) AS AvgViewCount\n    FROM Posts p\n    GROUP BY p.OwnerUserId\n) ups\nJOIN s1 ON s1.UserId = ups.OwnerUserId\nWHERE s1.BadgeCount > 0\nORDER BY ups.TotalScore DESC, s1.BadgeCount DESC\nLIMIT 10;", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "9419.sql", "original_sql": "\nWITH RecentPosts AS (\n    SELECT \n        p.Id AS PostId, \n        p.Title, \n        p.CreationDate, \n        p.Score, \n        p.ViewCount, \n        u.DisplayName AS OwnerDisplayName,\n        COUNT(c.Id) AS CommentCount,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM \n        Posts p\n    JOIN \n        Users u ON p.OwnerUserId = u.Id\n    LEFT JOIN \n        Comments c ON p.Id = c.PostId\n    LEFT JOIN \n        Votes v ON p.Id = v.PostId\n    WHERE \n        p.CreationDate >= TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '30 days'\n    GROUP BY \n        p.Id, p.Title, p.CreationDate, p.Score, p.ViewCount, u.DisplayName\n),\nTopUsers AS (\n    SELECT \n        u.Id AS UserId, \n        u.DisplayName, \n        SUM(p.Score) AS TotalScore, \n        COUNT(DISTINCT p.Id) AS PostCount\n    FROM \n        Users u\n    JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    GROUP BY \n        u.Id, u.DisplayName\n    ORDER BY \n        TotalScore DESC\n    LIMIT 5\n),\nPostHistoryInfo AS (\n    SELECT \n        ph.PostId, \n        COUNT(*) AS EditCount, \n        MAX(ph.CreationDate) AS MostRecentEdit \n    FROM \n        PostHistory ph\n    GROUP BY \n        ph.PostId\n)\nSELECT \n    rp.PostId, \n    rp.Title, \n    rp.CreationDate, \n    rp.Score, \n    rp.ViewCount, \n    rp.OwnerDisplayName, \n    rp.CommentCount, \n    rp.UpVotes, \n    rp.DownVotes, \n    phi.EditCount, \n    phi.MostRecentEdit, \n    tu.DisplayName AS TopUserName, \n    tu.TotalScore as TopUserScore\nFROM \n    RecentPosts rp\nLEFT JOIN \n    PostHistoryInfo phi ON rp.PostId = phi.PostId\nCROSS JOIN \n    TopUsers tu\nORDER BY \n    rp.Score DESC, \n    rp.ViewCount DESC\nLIMIT 10;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "WITH RecentPosts AS (\n    SELECT \n        p.Id AS PostId,\n        p.Title,\n        p.CreationDate,\n        p.Score,\n        p.ViewCount,\n        u.DisplayName AS OwnerDisplayName,\n        COUNT(c.Id) AS CommentCount,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM Posts p\n    JOIN Users u ON p.OwnerUserId = u.Id\n    LEFT JOIN Comments c ON p.Id = c.PostId\n    LEFT JOIN Votes v ON p.Id = v.PostId\n    WHERE p.CreationDate >= TIMESTAMP '2024-10-01 12:34:56' - INTERVAL '30 days'\n    GROUP BY p.Id, p.Title, p.CreationDate, p.Score, p.ViewCount, u.DisplayName\n),\nPostHistoryInfo AS (\n    SELECT \n        ph.PostId,\n        COUNT(*) AS EditCount,\n        MAX(ph.CreationDate) AS MostRecentEdit\n    FROM PostHistory ph\n    GROUP BY ph.PostId\n)\nSELECT \n    rp.PostId,\n    rp.Title,\n    rp.CreationDate,\n    rp.Score,\n    rp.ViewCount,\n    rp.OwnerDisplayName,\n    rp.CommentCount,\n    rp.UpVotes,\n    rp.DownVotes,\n    phi.EditCount,\n    phi.MostRecentEdit\nFROM RecentPosts rp\nLEFT JOIN PostHistoryInfo phi ON rp.PostId = phi.PostId;", "sql2": "WITH TopUsers AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        SUM(p.Score) AS TotalScore,\n        COUNT(DISTINCT p.Id) AS PostCount\n    FROM Users u\n    JOIN Posts p ON u.Id = p.OwnerUserId\n    GROUP BY u.Id, u.DisplayName\n    ORDER BY TotalScore DESC\n    LIMIT 5\n)\nSELECT \n    s1.PostId,\n    s1.Title,\n    s1.CreationDate,\n    s1.Score,\n    s1.ViewCount,\n    s1.OwnerDisplayName,\n    s1.CommentCount,\n    s1.UpVotes,\n    s1.DownVotes,\n    s1.EditCount,\n    s1.MostRecentEdit,\n    tu.DisplayName AS TopUserName,\n    tu.TotalScore AS TopUserScore\nFROM s1\nCROSS JOIN TopUsers tu\nORDER BY s1.Score DESC, s1.ViewCount DESC\nLIMIT 10;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "9528.sql", "original_sql": "WITH UserVotes AS (\n    SELECT \n        v.UserId, \n        COUNT(v.Id) AS TotalVotes,\n        SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END) AS UpVotes,\n        SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END) AS DownVotes\n    FROM \n        Votes v\n    GROUP BY \n        v.UserId\n), \nUserBadges AS (\n    SELECT \n        b.UserId, \n        COUNT(b.Id) AS TotalBadges,\n        SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END) AS GoldBadges,\n        SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END) AS SilverBadges,\n        SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadges\n    FROM \n        Badges b\n    GROUP BY \n        b.UserId\n), \nPostStatistics AS (\n    SELECT \n        p.OwnerUserId,\n        COUNT(p.Id) AS TotalPosts,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS Questions,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS Answers,\n        SUM(p.ViewCount) AS TotalViews,\n        SUM(p.Score) AS TotalScore\n    FROM \n        Posts p\n    GROUP BY \n        p.OwnerUserId\n)\n\nSELECT \n    u.Id AS UserId,\n    u.DisplayName,\n    u.Reputation,\n    COALESCE(uv.TotalVotes, 0) AS TotalVotes,\n    COALESCE(uv.UpVotes, 0) AS UpVotes,\n    COALESCE(uv.DownVotes, 0) AS DownVotes,\n    COALESCE(ub.TotalBadges, 0) AS TotalBadges,\n    COALESCE(ub.GoldBadges, 0) AS GoldBadges,\n    COALESCE(ub.SilverBadges, 0) AS SilverBadges,\n    COALESCE(ub.BronzeBadges, 0) AS BronzeBadges,\n    COALESCE(ps.TotalPosts, 0) AS TotalPosts,\n    COALESCE(ps.Questions, 0) AS Questions,\n    COALESCE(ps.Answers, 0) AS Answers,\n    COALESCE(ps.TotalViews, 0) AS TotalViews,\n    COALESCE(ps.TotalScore, 0) AS TotalScore\nFROM \n    Users u\nLEFT JOIN \n    UserVotes uv ON u.Id = uv.UserId\nLEFT JOIN \n    UserBadges ub ON u.Id = ub.UserId\nLEFT JOIN \n    PostStatistics ps ON u.Id = ps.OwnerUserId\nWHERE \n    u.Reputation > 1000\nORDER BY \n    u.Reputation DESC\nLIMIT 50;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT Id AS UserId,\n       DisplayName,\n       Reputation\nFROM   Users\nWHERE  Reputation > 1000\nORDER  BY Reputation DESC\nLIMIT  50;", "sql2": "WITH UserVotes AS (\n       SELECT v.UserId,\n              COUNT(v.Id)                                           AS TotalVotes,\n              SUM(CASE WHEN v.VoteTypeId = 2 THEN 1 ELSE 0 END)    AS UpVotes,\n              SUM(CASE WHEN v.VoteTypeId = 3 THEN 1 ELSE 0 END)    AS DownVotes\n       FROM   Votes v\n       JOIN   s1 u ON v.UserId = u.UserId\n       GROUP  BY v.UserId\n),\n     UserBadges AS (\n       SELECT b.UserId,\n              COUNT(b.Id)                                           AS TotalBadges,\n              SUM(CASE WHEN b.Class = 1 THEN 1 ELSE 0 END)        AS GoldBadges,\n              SUM(CASE WHEN b.Class = 2 THEN 1 ELSE 0 END)        AS SilverBadges,\n              SUM(CASE WHEN b.Class = 3 THEN 1 ELSE 0 END)        AS BronzeBadges\n       FROM   Badges b\n       JOIN   s1 u ON b.UserId = u.UserId\n       GROUP  BY b.UserId\n),\n     PostStatistics AS (\n       SELECT p.OwnerUserId                                        AS UserId,\n              COUNT(p.Id)                                           AS TotalPosts,\n              SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END)    AS Questions,\n              SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END)    AS Answers,\n              SUM(p.ViewCount)                                      AS TotalViews,\n              SUM(p.Score)                                          AS TotalScore\n       FROM   Posts p\n       JOIN   s1 u ON p.OwnerUserId = u.UserId\n       GROUP  BY p.OwnerUserId\n)\nSELECT s1.UserId,\n       s1.DisplayName,\n       s1.Reputation,\n       COALESCE(uv.TotalVotes, 0)   AS TotalVotes,\n       COALESCE(uv.UpVotes, 0)     AS UpVotes,\n       COALESCE(uv.DownVotes, 0)   AS DownVotes,\n       COALESCE(ub.TotalBadges, 0) AS TotalBadges,\n       COALESCE(ub.GoldBadges, 0)  AS GoldBadges,\n       COALESCE(ub.SilverBadges, 0)AS SilverBadges,\n       COALESCE(ub.BronzeBadges, 0)AS BronzeBadges,\n       COALESCE(ps.TotalPosts, 0)   AS TotalPosts,\n       COALESCE(ps.Questions, 0)    AS Questions,\n       COALESCE(ps.Answers, 0)      AS Answers,\n       COALESCE(ps.TotalViews, 0)   AS TotalViews,\n       COALESCE(ps.TotalScore, 0)   AS TotalScore\nFROM   s1\nLEFT   JOIN UserVotes uv ON s1.UserId = uv.UserId\nLEFT   JOIN UserBadges ub ON s1.UserId = ub.UserId\nLEFT   JOIN PostStatistics ps ON s1.UserId = ps.UserId;", "results_match": false, "engine_mem_mb": 500000}
{"query_id": "9598.sql", "original_sql": "\nWITH UserBadges AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COUNT(B.Id) AS BadgeCount,\n        SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadgeCount,\n        SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadgeCount,\n        SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadgeCount\n    FROM \n        Users U\n    LEFT JOIN \n        Badges B ON U.Id = B.UserId\n    GROUP BY \n        U.Id, U.DisplayName\n), PostDetails AS (\n    SELECT \n        P.OwnerUserId,\n        COUNT(CASE WHEN P.PostTypeId = 1 THEN 1 END) AS QuestionCount,\n        COUNT(CASE WHEN P.PostTypeId = 2 THEN 1 END) AS AnswerCount,\n        SUM(P.Score) AS TotalScore,\n        SUM(P.ViewCount) AS TotalViews\n    FROM \n        Posts P\n    GROUP BY \n        P.OwnerUserId\n), CombinedData AS (\n    SELECT \n        U.Id AS UserId,\n        U.DisplayName,\n        COALESCE(UB.BadgeCount, 0) AS BadgeCount,\n        COALESCE(UB.GoldBadgeCount, 0) AS GoldBadgeCount,\n        COALESCE(UB.SilverBadgeCount, 0) AS SilverBadgeCount,\n        COALESCE(UB.BronzeBadgeCount, 0) AS BronzeBadgeCount,\n        COALESCE(PD.QuestionCount, 0) AS QuestionCount,\n        COALESCE(PD.AnswerCount, 0) AS AnswerCount,\n        COALESCE(PD.TotalScore, 0) AS TotalScore,\n        COALESCE(PD.TotalViews, 0) AS TotalViews\n    FROM \n        Users U\n    LEFT JOIN \n        UserBadges UB ON U.Id = UB.UserId\n    LEFT JOIN \n        PostDetails PD ON U.Id = PD.OwnerUserId\n)\nSELECT \n    UserId,\n    DisplayName,\n    BadgeCount,\n    GoldBadgeCount,\n    SilverBadgeCount,\n    BronzeBadgeCount,\n    QuestionCount,\n    AnswerCount,\n    TotalScore,\n    TotalViews\nFROM \n    CombinedData\nORDER BY \n    TotalScore DESC, BadgeCount DESC, DisplayName ASC\nFETCH FIRST 100 ROWS ONLY;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT U.Id AS UserId,\n       U.DisplayName,\n       COUNT(B.Id) AS BadgeCount,\n       SUM(CASE WHEN B.Class = 1 THEN 1 ELSE 0 END) AS GoldBadgeCount,\n       SUM(CASE WHEN B.Class = 2 THEN 1 ELSE 0 END) AS SilverBadgeCount,\n       SUM(CASE WHEN B.Class = 3 THEN 1 ELSE 0 END) AS BronzeBadgeCount\nFROM Users U\nLEFT JOIN Badges B ON U.Id = B.UserId\nGROUP BY U.Id, U.DisplayName", "sql2": "SELECT s1.UserId,\n       s1.DisplayName,\n       s1.BadgeCount,\n       s1.GoldBadgeCount,\n       s1.SilverBadgeCount,\n       s1.BronzeBadgeCount,\n       COALESCE(PD.QuestionCount, 0) AS QuestionCount,\n       COALESCE(PD.AnswerCount, 0) AS AnswerCount,\n       COALESCE(PD.TotalScore, 0) AS TotalScore,\n       COALESCE(PD.TotalViews, 0) AS TotalViews\nFROM s1\nLEFT JOIN (\n    SELECT P.OwnerUserId AS UserId,\n           COUNT(CASE WHEN P.PostTypeId = 1 THEN 1 END) AS QuestionCount,\n           COUNT(CASE WHEN P.PostTypeId = 2 THEN 1 END) AS AnswerCount,\n           SUM(P.Score) AS TotalScore,\n           SUM(P.ViewCount) AS TotalViews\n    FROM Posts P\n    GROUP BY P.OwnerUserId\n) PD ON s1.UserId = PD.UserId\nORDER BY TotalScore DESC, BadgeCount DESC, DisplayName ASC\nLIMIT 100", "results_match": true, "engine_mem_mb": 500000}
{"query_id": "9943.sql", "original_sql": "\nWITH UserStatistics AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(DISTINCT p.Id) AS TotalPosts,\n        SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n        SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers,\n        SUM(p.Score) AS TotalScore,\n        AVG(p.ViewCount) AS AvgViews,\n        MAX(p.CreationDate) AS LastPostDate\n    FROM \n        Users u\n    LEFT JOIN \n        Posts p ON u.Id = p.OwnerUserId\n    GROUP BY \n        u.Id, u.DisplayName\n),\nActiveUsers AS (\n    SELECT \n        us.UserId,\n        us.DisplayName,\n        us.TotalPosts,\n        us.TotalQuestions,\n        us.TotalAnswers,\n        us.TotalScore,\n        us.AvgViews,\n        us.LastPostDate\n    FROM \n        UserStatistics us\n    WHERE \n        us.TotalPosts > 5 AND \n        us.TotalScore > 100\n),\nRecentActivity AS (\n    SELECT \n        u.Id AS UserId,\n        u.DisplayName,\n        COUNT(c.Id) AS TotalComments,\n        MAX(c.CreationDate) AS LastCommentDate\n    FROM \n        Users u\n    LEFT JOIN \n        Comments c ON u.Id = c.UserId\n    GROUP BY \n        u.Id, u.DisplayName\n)\nSELECT \n    au.UserId,\n    au.DisplayName,\n    au.TotalPosts,\n    au.TotalQuestions,\n    au.TotalAnswers,\n    au.TotalScore,\n    au.AvgViews,\n    ra.TotalComments,\n    ra.LastCommentDate,\n    au.LastPostDate\nFROM \n    ActiveUsers au\nLEFT JOIN \n    RecentActivity ra ON au.UserId = ra.UserId\nORDER BY \n    au.TotalScore DESC, au.LastPostDate DESC;\n", "has_cut": true, "q1_engine": "duckdb", "q2_engine": "datafusion", "sql1": "SELECT \n    u.Id AS UserId,\n    u.DisplayName,\n    COUNT(DISTINCT p.Id) AS TotalPosts,\n    SUM(CASE WHEN p.PostTypeId = 1 THEN 1 ELSE 0 END) AS TotalQuestions,\n    SUM(CASE WHEN p.PostTypeId = 2 THEN 1 ELSE 0 END) AS TotalAnswers,\n    SUM(p.Score) AS TotalScore,\n    AVG(p.ViewCount) AS AvgViews,\n    MAX(p.CreationDate) AS LastPostDate\nFROM Users u\nLEFT JOIN Posts p ON u.Id = p.OwnerUserId\nGROUP BY u.Id, u.DisplayName\nHAVING COUNT(DISTINCT p.Id) > 5 AND SUM(p.Score) > 100;", "sql2": "SELECT \n    s1.UserId,\n    s1.DisplayName,\n    s1.TotalPosts,\n    s1.TotalQuestions,\n    s1.TotalAnswers,\n    s1.TotalScore,\n    s1.AvgViews,\n    ra.TotalComments,\n    ra.LastCommentDate,\n    s1.LastPostDate\nFROM s1\nLEFT JOIN (\n    SELECT \n        u.Id AS UserId,\n        COUNT(c.Id) AS TotalComments,\n        MAX(c.CreationDate) AS LastCommentDate\n    FROM Users u\n    LEFT JOIN Comments c ON u.Id = c.UserId\n    GROUP BY u.Id\n) AS ra\nON s1.UserId = ra.UserId\nORDER BY s1.TotalScore DESC, s1.LastPostDate DESC;", "results_match": true, "engine_mem_mb": 500000}
