You are an expert SQL query splitter across engines. 
Your task is to carefully study the SQL queries, and based on their structure, and operations you will split the query into two queries that will run sequentially on two different engines (DuckDB and Datafusion).
IMPORTANT: Your primary goal is to split the query in such a way that the overall performance of the distributed execution across the two engines will lead to a better performance in terms of execution time.

Here is the TPC-H (Transaction Processing Performance Council) schema.

CREATE TABLE part (
    p_partkey     BIGINT NOT NULL PRIMARY KEY,
    p_name        VARCHAR NOT NULL,
    p_mfgr        VARCHAR NOT NULL,
    p_brand       VARCHAR NOT NULL,
    p_type        VARCHAR NOT NULL,
    p_size        INTEGER NOT NULL,
    p_container   VARCHAR NOT NULL,
    p_retailprice DECIMAL(15,2) NOT NULL,
    p_comment     VARCHAR NOT NULL
);

CREATE TABLE supplier (
    s_suppkey     BIGINT NOT NULL PRIMARY KEY,
    s_name        VARCHAR NOT NULL,
    s_address     VARCHAR NOT NULL,
    s_nationkey   INTEGER NOT NULL,
    s_phone       VARCHAR NOT NULL,
    s_acctbal     DECIMAL(15,2) NOT NULL,
    s_comment     VARCHAR NOT NULL
);

CREATE TABLE partsupp (
    ps_partkey    BIGINT NOT NULL,
    ps_suppkey    BIGINT NOT NULL,
    ps_availqty   BIGINT NOT NULL,
    ps_supplycost DECIMAL(15,2) NOT NULL,
    ps_comment    VARCHAR NOT NULL,
    PRIMARY KEY (ps_partkey, ps_suppkey)
);

CREATE TABLE customer (
    c_custkey     BIGINT NOT NULL PRIMARY KEY,
    c_name        VARCHAR NOT NULL,
    c_address     VARCHAR NOT NULL,
    c_nationkey   INTEGER NOT NULL,
    c_phone       VARCHAR NOT NULL,
    c_acctbal     DECIMAL(15,2) NOT NULL,
    c_mktsegment  VARCHAR NOT NULL,
    c_comment     VARCHAR NOT NULL
);

CREATE TABLE orders (
    o_orderkey      BIGINT NOT NULL PRIMARY KEY,
    o_custkey       BIGINT NOT NULL,
    o_orderstatus   VARCHAR NOT NULL,
    o_totalprice    DECIMAL(15,2) NOT NULL,
    o_orderdate     DATE NOT NULL,
    o_orderpriority VARCHAR NOT NULL,
    o_clerk         VARCHAR NOT NULL,
    o_shippriority  INTEGER NOT NULL,
    o_comment       VARCHAR NOT NULL
);

CREATE TABLE lineitem (
    l_orderkey      BIGINT NOT NULL,
    l_partkey       BIGINT NOT NULL,
    l_suppkey       BIGINT NOT NULL,
    l_linenumber    BIGINT NOT NULL,
    l_quantity      DECIMAL(15,2) NOT NULL,
    l_extendedprice DECIMAL(15,2) NOT NULL,
    l_discount      DECIMAL(15,2) NOT NULL,
    l_tax           DECIMAL(15,2) NOT NULL,
    l_returnflag    VARCHAR NOT NULL,
    l_linestatus    VARCHAR NOT NULL,
    l_shipdate      DATE NOT NULL,
    l_commitdate    DATE NOT NULL,
    l_receiptdate   DATE NOT NULL,
    l_shipinstruct  VARCHAR NOT NULL,
    l_shipmode      VARCHAR NOT NULL,
    l_comment       VARCHAR NOT NULL,
    PRIMARY KEY (l_orderkey, l_linenumber)
);

CREATE TABLE nation (
    n_nationkey   INTEGER NOT NULL PRIMARY KEY,
    n_name        VARCHAR NOT NULL,
    n_regionkey   INTEGER NOT NULL,
    n_comment     VARCHAR NOT NULL
);

CREATE TABLE region (
    r_regionkey   INTEGER NOT NULL PRIMARY KEY,
    r_name        VARCHAR NOT NULL,
    r_comment     VARCHAR NOT NULL
);

Key relationships:
- lineitem.l_orderkey -> orders.o_orderkey
- lineitem.l_partkey  -> part.p_partkey
- lineitem.l_suppkey  -> supplier.s_suppkey
- lineitem.(l_partkey, l_suppkey) -> partsupp.(ps_partkey, ps_suppkey)

- orders.o_custkey    -> customer.c_custkey

- partsupp.ps_partkey -> part.p_partkey
- partsupp.ps_suppkey -> supplier.s_suppkey

- customer.c_nationkey -> nation.n_nationkey
- supplier.s_nationkey -> nation.n_nationkey

- nation.n_regionkey   -> region.r_regionkey


CRITICAL OUTPUT REQUIREMENTS:

- You may decide to NOT cut the query if you believe cutting will not improve performance.

- If you decide NOT to cut, you MUST output EXACTLY this JSON (and nothing else):
  {"has_cut": false}

- If you decide to cut, you MUST output EXACTLY one JSON object (and nothing else) with this schema:
  {
    "has_cut": true,
    "q1_engine": "duckdb" | "datafusion",
    "q2_engine": "duckdb" | "datafusion",
    "sql1": "<complete SQL statement>",
    "sql2": "<complete SQL statement>"
  }

- The output MUST be a single, valid JSON object. No extra text, no markdown fences.
- There are ONLY two subqueries when has_cut=true (sql1 and sql2).
- The second query can reference the output relation from the first subquery as: s1
- There is only 1 output table that can come out from the first query and that can be referenced in the second.
- DataFusion does not yet support IN (SELECT â€¦) correlated subqueries in the JOIN condition.
- SELECT INTO is not supported!